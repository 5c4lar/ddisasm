.comp StructRecovery {
    .type type_description = [Offset:number, Size:unsigned, Type:symbol]
    .type layout = [Prev:layout, Description:type_description]
    .type value_desc = [EA:address, Base:register, Offset:number, Type:symbol]

    .decl value_def(Val: value_desc)
    .decl value_used(Val: value_desc)
    .output value_used
    .decl value_must_def(Val:value_desc)
    .decl value_defined_in_block(Block:address, Val: value_desc)
    .decl value_used_in_block(Block:address, Val:value_desc)
    .decl value_block_last_def(EA:address, Val:value_desc)
    .decl value_last_def(Block:address, Val:value_desc)
    .decl value_def_used(Def:value_desc, Used:value_desc, Type:symbol)
    .output value_def_used
    .decl defined_value(Val:value_desc)
    .output defined_value
    .decl value_edge(Src:value_desc, Dst:value_desc)
    .output value_edge
    // calculate relative addresses, add, sub, mult
    .decl value_arithmetic_edge(Dst: value_desc, Op1: value_desc, Op2:value_desc, Op3:value_desc, Operation:symbol)
    .output value_arithmetic_edge
    .decl resolve_calc(Calc: value_desc, Src: value_desc, Offset:number)
    .output resolve_calc
    .decl value_root(Val: value_desc, Root: value_desc)
    .output value_root
    .decl value_src(Src: value_desc, Ref: address, From:symbol)
    .output value_src
    .decl src_for_address(Src: value_desc)
    .output src_for_address
    .decl value_used_for_address(Mem:value_desc, Size:unsigned, Direction:symbol, Base_value: value_desc)
    .output value_used_for_address
    
    .decl pattern_tape(Src: value_desc, Offset: number, Type: layout)
    .output pattern_tape
    .decl should_not_merge(Src1: value_desc, Src2: value_desc)
    .output should_not_merge
    .decl merge_hint(Src1: value_desc, Src2: value_desc, Offset:number)
    .output merge_hint
    .decl merged_tape(Src: value_desc, Offset: number, Type: layout)
    .output merged_tape
}
.init struct_recovery = StructRecovery

struct_recovery.value_def([EA, Base, Offset, "mem"]):-
    arch.mov(EA),
    code(EA),
    instruction_get_dest_op(EA,_,DestOp),
    op_indirect(DestOp,"NONE",Base,"NONE",_,Offset,_),
    !arch.pc_register(Base).

struct_recovery.value_def([EA, Reg, 0, "reg"]):-
    code(EA),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg).

struct_recovery.value_def([EA, Reg, 0, "reg"]):-
    code(EA),
    instruction_get_operation(EA,Operation),
    arch.call_operation(Operation),
    !arch.delay_slot(EA,_),
    arch.function_non_maintained_reg(Reg).

struct_recovery.value_def([EA, Reg, 0, "reg"]):-
    code(EA),
    instruction_get_operation(Call,Operation),
    arch.call_operation(Operation),
    arch.delay_slot(Call,EA),
    arch.function_non_maintained_reg(Reg).

struct_recovery.value_def([EA, Reg, 0, "calc"]):-
    code(EA),
    instruction_get_operation(EA, Operation),
    (Operation="PUSH";Operation="POP"),
    arch.stack_pointer(Reg).

struct_recovery.value_def([EA, Base, Address, "global"]):-
    arch.mov(EA),
    code(EA),
    instruction_get_dest_op(EA,_,Op),
    op_indirect(Op,"NONE",Base,"NONE",_,Offset,_),
    arch.pc_register(Base),
    next(EA, PC),
    Address = as(Offset, number) + as(PC, number).

struct_recovery.value_def([EA, Reg, as(Size, number), "mem"]):-
    code(EA),
    instruction_get_operation(EA, Operation),
    Operation="PUSH",
    arch.pointer_size(Size),
    arch.stack_pointer(Reg).

struct_recovery.value_arithmetic_edge([EA, Reg, 0, "calc"], [EA, Reg, 0, "reg"], nil, [EA, "NONE", as(Immediate,number), "immediate"], ArithOp):-
    code(EA),
    arch.stack_pointer(Reg),
    instruction_get_operation(EA, Operation),
    arch.pointer_size(Immediate),
    (Operation="PUSH",ArithOp="sub";Operation="POP",ArithOp="add").

struct_recovery.value_must_def([EA, Base, Offset, Type]):-
    code(EA),
    struct_recovery.value_def([EA, Base, Offset, Type]),
    instruction_get_operation(EA, Op),
    !arch.conditional_operation(Op).

struct_recovery.value_used([EA, Base, Offset, "mem"]):-
    arch.mov(EA),
    code(EA),
    instruction_get_src_op(EA,_,SrcOp),
    op_indirect(SrcOp,"NONE",Base,"NONE",_,Offset,_),
    !arch.pc_register(Base).

struct_recovery.value_used([EA, Base, Address, "global"]):-
    arch.mov(EA),
    code(EA),
    instruction_get_src_op(EA,_,SrcOp),
    op_indirect(SrcOp,"NONE",Base,"NONE",_,Offset,_),
    arch.pc_register(Base),
    next(EA, PC),
    Address = as(Offset, number) + as(PC, number).

struct_recovery.value_used([EA, Reg, 0, "reg"]):-
    code(EA),
    instruction_get_src_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg),
    !is_xor_reset(EA).

struct_recovery.value_used([EA, Reg, 0, "base"]):-
    code(EA),
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_,Reg,_,_,_,_),
    Reg != "NONE".

struct_recovery.value_used([EA, Reg, 0, "idx"]):-
    code(EA),
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_,_,Reg,_,_,_),
    Reg != "NONE".

struct_recovery.value_used([EA, Reg, 0, "reg"]):-
    code(EA),
    instruction_get_operation(Call,Operation),
    arch.call_operation(Operation),
    arch.delay_slot(Call,EA),
    arch.function_non_maintained_reg(Reg).

struct_recovery.value_used([EA, Reg, 0, "reg"]):-
    code(EA),
    instruction_get_operation(EA, Operation),
    (Operation="PUSH";Operation="POP"),
    arch.stack_pointer(Reg).

struct_recovery.value_used([EA, Reg, 0, "base"]):-
    code(EA),
    instruction_get_operation(EA, Operation),
    (Operation="PUSH";Operation="POP"),
    arch.stack_pointer(Reg).
    
struct_recovery.value_used([EA, Reg, 0, "mem"]):-
    code(EA),
    instruction_get_operation(EA, Operation),
    Operation="POP",
    arch.stack_pointer(Reg).

struct_recovery.value_defined_in_block(Block, [EA, Base, Offset, Type]):-
    struct_recovery.value_def([EA, Base, Offset, Type]),
    code_in_refined_block(EA, Block).

struct_recovery.value_used_in_block(Block, [EA, Base, Offset, Type]):-
    struct_recovery.value_used([EA, Base, Offset, Type]),
    code_in_refined_block(EA, Block).

struct_recovery.value_block_last_def(EA_next, [EA, Base, Offset, Type]):-
    struct_recovery.value_def([EA, Base, Offset, Type]),
    local_next(EA, EA_next).

struct_recovery.value_block_last_def(EA_next, [EA_def, Base, Offset, Type]):-
    struct_recovery.value_block_last_def(EA, [EA_def, Base, Offset, Type]),
    !struct_recovery.value_must_def([EA, Base, Offset, Type]),
    local_next(EA, EA_next).

struct_recovery.value_last_def(Block, [EA, Base, Offset, Type]):-
    struct_recovery.value_def([EA, Base, Offset, Type]),
    block_next(EA, Block),
    !flow_def(EA, Base, Block, _).

struct_recovery.value_last_def(Block, [EA, Base, Offset, Type]):-
    struct_recovery.value_block_last_def(Block_end, [EA, Base, Offset, Type]),
    !struct_recovery.value_must_def([Block_end, Base, Offset, Type]),
    block_next(Block_end, Block),
    !flow_def(Block_end, Base, Block, _).

struct_recovery.value_last_def(Block_next, [EA, Base, Offset, Type]):-
    struct_recovery.value_last_def(Block, [EA, Base, Offset, Type]),
    struct_recovery.value_def( [EA_dummy, Base, Offset, Type]),
    !struct_recovery.value_block_last_def(EA, [EA_dummy, Base, Offset, Type]),
    block_last_instruction(Block, Block_end),
    block_next(Block_end, Block_next),
    !flow_def(Block_end, Base, Block, _).

struct_recovery.value_last_def(Block_next, [Block_end, Reg, 0, "reg"]):-
    flow_def(Block_end,Reg,Block_next,_).

struct_recovery.value_def_used([EA_def, Base, Offset, Type], [EA, Base, Offset, Type1], "intra"):-
    struct_recovery.value_used([EA, Base, Offset, Type1]),
    struct_recovery.value_block_last_def(EA, [EA_def, Base, Offset, Type]),
    (Type = Type1; Type = "reg"; Type="calc", Type1="reg").

struct_recovery.value_def_used([EA_def, Base, Offset, Type], [EA, Base, Offset, Type1], "intra"):-
    struct_recovery.value_last_def(Block, [EA_def, Base, Offset, Type]),
    code_in_refined_block(EA, Block),
    struct_recovery.value_def( [EA_dummy, Base, Offset, Type]),
    !struct_recovery.value_block_last_def(EA, [EA_dummy, Base, Offset, Type]),
    struct_recovery.value_used([EA, Base, Offset, Type1]),
    (Type = Type1; Type = "reg"; Type="calc", Type1="reg").

struct_recovery.value_def_used([EA_def, Reg, 0, "reg"], [EA_used, Reg, 0, Type], "callee"):-
    def_used_return_val_reg(EA_def, _, Reg, EA_used, _),
    struct_recovery.value_used([EA_used, Reg, 0, Type]).

struct_recovery.defined_value(Val):-
    struct_recovery.value_def_used(_, Val, _).

struct_recovery.value_src([Function, Reg, 0, "reg"], EA, "caller"):-
    struct_recovery.value_used([EA,Reg,0,Type]),
    !arch.pc_register(Reg),
    code_in_refined_block(EA,Block),
    function_inference.in_function(Block, Function),
    !struct_recovery.defined_value([EA, Reg, 0, Type]),
    (Type="reg";Type="base";Type="idx").

struct_recovery.value_src([EA, Reg, 0, "calc"], EA, "calc"):-
    struct_recovery.value_def([EA, Reg, 0, "calc"]).

struct_recovery.value_src([EA, Reg, 0, "reg"], EA_used, "callee"):-
    instruction_get_operation(EA,Operation),
    arch.call_operation(Operation),
    arch.function_non_maintained_reg(Reg),
    struct_recovery.value_def_used([EA, Reg, 0, "reg"], [EA_used, Reg, 0, "reg"], _).

struct_recovery.value_src([EA, Reg, 0, "reg"], EA, "known"):-
    value_reg(EA, Reg, EA, "NONE", 0, _, _).

struct_recovery.value_src([Function, Base, Offset, "mem"], Ref, "stack_arg"):-
    !struct_recovery.defined_value([Ref, Base, Offset, "mem"]),
    (arch.frame_pointer(Base) ; arch.stack_pointer(Base)),
    code_in_refined_block(Ref,Block),
    function_inference.in_function(Block, Function),
    struct_recovery.value_used([Ref, Base, Offset, "mem"]).

struct_recovery.value_src([EA, Base, Offset, "mem"], EA, "immediate"):-
    struct_recovery.value_def([EA, Base, Offset, "mem"]),
    arch.mov(EA),
    code(EA),
    instruction_get_src_op(EA,_,SrcOp),
    op_immediate(SrcOp, _).

struct_recovery.value_src([EA, Base, Address, "global"], EA, "global"):-
    struct_recovery.value_used([EA, Base, Address, "global"]).

struct_recovery.value_edge([EA, Base_src, Offset_src, Type_src], [EA, Base_dst, Offset_dst, Type_dst]):-
    arch.mov(EA),
    struct_recovery.value_def([EA, Base_dst, Offset_dst, Type_dst]),
    struct_recovery.value_used([EA, Base_src, Offset_src, Type_src]),
    (Type_src="reg";Type_src="mem";Type_src="global").

struct_recovery.value_edge([EA, Base, 0, "mem"], [EA, Reg, 0, "reg"]):-
    code(EA),
    instruction_get_operation(EA, Operation),
    Operation="POP",
    arch.stack_pointer(Base),
    instruction_get_dest_op(EA, _, DestOp),
    op_regdirect_contains_reg(DestOp, Reg).
    
struct_recovery.value_edge([EA, Reg, 0, "reg"], [EA, Base, 8, "mem"]):-
    code(EA),
    instruction_get_operation(EA, Operation),
    Operation="PUSH",
    arch.stack_pointer(Base),
    instruction_get_src_op(EA, _, SrcOp),
    op_regdirect_contains_reg(SrcOp, Reg).

// def value root for src and its ref.
struct_recovery.value_root([EA_ref, Base, Offset, Type1], [EA_def, Base, Offset, Type]):-
    struct_recovery.value_src([EA_def, Base, Offset, Type], EA_ref, _),
    struct_recovery.value_used([EA_ref, Base, Offset, Type1]),
    !Type="calc".

// def value root for immediate and calc
struct_recovery.value_root([EA_ref, Base, Offset, Type], [EA_def, Base, Offset, Type]):-
    struct_recovery.value_src([EA_def, Base, Offset, Type], EA_ref, _),
    struct_recovery.value_def([EA_ref, Base, Offset, Type]).

struct_recovery.value_root(Used, Root):-
    struct_recovery.value_root(Def, Root),
    struct_recovery.value_def_used(Def, Used, _).

struct_recovery.value_root(Dst, Root):-
    struct_recovery.value_root(Src, Root),
    struct_recovery.value_edge(Src, Dst).
    
struct_recovery.resolve_calc([EA, Base, 0, "calc"], Root, Offset):-
    struct_recovery.value_arithmetic_edge([EA, Base, 0, "calc"], Src, nil, [EA, "NONE", Immediate, "immediate"], Operation),
    struct_recovery.value_root(Src, Root),
    (Operation="add",Offset=Immediate;
    Operation="sub",Offset=-Immediate).

struct_recovery.value_used_for_address([EA, Base, Offset, "mem"], Size, Direction, Value):-
    struct_recovery.src_for_address(Root),
    (struct_recovery.value_root(Value, Root);Value=Root),
    (struct_recovery.value_used([EA, Base, Offset, "mem"]),Direction="load";
    struct_recovery.value_def([EA, Base, Offset, "mem"]),Direction="store"),
    struct_recovery.value_root([EA, Base, 0, "base"], Root),
    instruction_memory_access_size(EA, _, Size).

struct_recovery.value_used_for_address([EA, Base, Offset, "global"], Size, Direction, [0, Base, 0, "global"]):-
    struct_recovery.value_src([EA, Base, Offset, "global"], EA, "global"),
    (struct_recovery.value_used([EA, Base, Offset, "global"]),Direction="load";
    struct_recovery.value_def([EA, Base, Offset, "global"]),Direction="store"),
    instruction_memory_access_size(EA, _, Size).

struct_recovery.src_for_address(Src):-
    struct_recovery.value_src(Src, _, _),
    struct_recovery.value_root([_, _, _, Type], Src),
    Type="base".

struct_recovery.src_for_address([0, Base, 0, "global"]):-
    struct_recovery.value_used_for_address([_, Base, _, "global"], _, _, [0, Base, 0, "global"]).

struct_recovery.pattern_tape(Base, Offset, [nil, [0, Size, Type]]):-
    struct_recovery.src_for_address(Base),
    !struct_recovery.resolve_calc(Base,_,_),
    struct_recovery.value_used_for_address([EA, Mem_base, Offset, "mem"], Size, _, Base),
    struct_recovery.value_root([EA, Mem_base, Offset, "mem"], Root),
    (struct_recovery.src_for_address(Root), Type="ptr";
    !struct_recovery.src_for_address(Root), Type="data").

struct_recovery.pattern_tape(Base, Address, [nil, [0, Size, Type]]):-
    struct_recovery.value_used_for_address([EA, Reg, Address, "global"], Size, _, Base),
    struct_recovery.value_root([EA, Reg, Address, "global"], Root),
    (struct_recovery.src_for_address(Root), Type="ptr";
    !struct_recovery.src_for_address(Root), Type="data").

struct_recovery.pattern_tape(Base, Offset_res, [nil, [0, Size, Type]]):-
    struct_recovery.src_for_address(Calc),
    struct_recovery.resolve_calc(Calc, Base, Offset_calc),
    struct_recovery.value_used_for_address([EA, Mem_base, Offset, "mem"], Size, _, Calc),
    struct_recovery.value_root([EA, Mem_base, Offset, "mem"], Root),
    Offset_res=Offset_calc+Offset,
    (struct_recovery.src_for_address(Root), Type="ptr";
    !struct_recovery.src_for_address(Root), Type="data").

struct_recovery.pattern_tape(Id, Offset1, [[Prev, [TypeOffset1, Size1, Type1]], [TypeOffset2, Size2, Type2]]):-
    struct_recovery.pattern_tape(Id, Offset1, [Prev, [TypeOffset1, Size1, Type1]]),
    struct_recovery.pattern_tape(Id, Offset2, [nil, [0, Size2, Type2]]),
    Offset1 + TypeOffset1 + as(Size1, number) <= Offset2,
    TypeOffset2 = Offset2 - Offset1.

struct_recovery.should_not_merge(Id1, Id2):-
    Id1 != Id2,
    struct_recovery.pattern_tape(Id1, Offset1, [nil, [0, Size1, _]]),
    struct_recovery.pattern_tape(Id2, Offset2, [nil, [0, Size2, _]]),
    Offset1 = Offset2,
    Size1 != Size2.

struct_recovery.should_not_merge(Id1, Id2):-
    Id1 != Id2,
    struct_recovery.pattern_tape(Id1, Offset1, [nil, [0, Size1, _]]),
    struct_recovery.pattern_tape(Id2, Offset2, [nil, [0, _, _]]),
    Offset1 < Offset2,
    Offset1 + as(Size1, number) > Offset2.

struct_recovery.merge_hint(Base_value1, Base_value2, Offset):-
    struct_recovery.value_root([EA1, Base1, Offset1, Type1], Root),
    struct_recovery.value_root([EA2, Base2, Offset2, Type2], Root),
    struct_recovery.src_for_address(Base_value1),
    struct_recovery.src_for_address(Base_value2),
    struct_recovery.value_used_for_address([EA1, Base1, Offset1, Type1], _, _, Base_value1),
    struct_recovery.value_used_for_address([EA2, Base2, Offset2, Type2], _, _, Base_value2),
    Offset = Offset2 - Offset1,
    Type1 != "global",  // Don't merge all global onto stack
    Base_value1 != Base_value2.

struct_recovery.merged_tape(Id, Offset, Type):-
    struct_recovery.pattern_tape(Id, Offset, Type).

struct_recovery.merged_tape(Id, Offset1, [[Prev, [TypeOffset1, Size1, Type1]], [TypeOffset2, Size2, Type2]]):-
    struct_recovery.merged_tape(Id, Offset1, [Prev, [TypeOffset1, Size1, Type1]]),
    struct_recovery.merged_tape(Id, Offset2, [nil, [0, Size2, Type2]]),
    Offset1 + TypeOffset1 + as(Size1, number) <= Offset2,
    TypeOffset2 = Offset2 - Offset1.

struct_recovery.merged_tape(Id2, Offset, [nil, Type]):-
    !(struct_recovery.should_not_merge(Id1, Id2);struct_recovery.should_not_merge(Id2, Id1)),
    struct_recovery.pattern_tape(Id1, Offset1, [nil, Type]),
    struct_recovery.pattern_tape(Id2, _, _),
    Id1 != Id2,
    Offset = Offset1 + Offset_merge,
    struct_recovery.merge_hint(Id1, Id2, Offset_merge).

