.comp StructRecovery {
    .type type_description = [Offset:number, Size:unsigned, Type:symbol]
    .type layout = [Prev:layout, Description:type_description]
    .type value_desc = [EA:address, Base:register, Offset:number, Type:symbol]
    .type loc_desc = [Base:register, Offset:number, Type:symbol]

    .decl local_next(EA:address, EA_next:address)
    .decl value_def(Val: value_desc)
    .output value_def
    .decl value_used(Val: value_desc)
    .output value_used
    .decl value_must_def(Val:value_desc)
    // loc defined intrax
    .decl loc_defined_in_block(EA:address, Loc: loc_desc)
    // .output loc_defined_in_block
    // def at block level
    .decl loc_defined_in(Block:address, Loc: loc_desc)
    // .output loc_defined_in
    .decl value_used_in_block(Block:address, Val:value_desc)
    .decl value_block_last_def(EA:address, Val:value_desc)
    .output value_block_last_def
    .decl value_last_def(Block:address, Val:value_desc)
    // .output value_last_def

    // value def_used intraprocedural
    .decl value_def_used(Def:value_desc, Used:value_desc, Type:symbol)
    .output value_def_used

    .decl def_usable_type(Type:symbol, Type1:symbol)
    .decl defined_value(Val:value_desc)
    .decl used_value(Val:value_desc)
    // edges connecting values
    .decl value_edge(Src:value_desc, Dst:value_desc, Type:symbol)
    .output value_edge

    .decl value_arithmetic_operation(EA:address, Dst:value_desc, Op1:value_desc, Op2:value_desc, Mult:number, Offset:number)
    // .output value_arithmetic_operation
    // calculate relative addresses, Dst = Op1 + Op2 * Mult + Offset
    .decl value_arithmetic_edge(Dst: value_desc, Op1: value_desc, Op2:value_desc, Mult:number, Offset:number)
    .output value_arithmetic_edge
    .decl resolve_calc(Calc: value_desc, Src: value_desc, Idx:value_desc, Mult:number, Offset:number)
    .output resolve_calc

    // where values are from
    .decl value_src(Src: value_desc, Ref: address, From:symbol)
    // .output value_src
    // edges from value to source
    .decl value_root(Val: value_desc, Root: value_desc, Type:symbol)
    .output value_root
    
    // locate sources for addresses, i.e. pointers.
    .decl src_for_address(Src: value_desc)
    .decl not_for_address(Val:value_desc)
    .output src_for_address
    // Mem is accessed with Size and source of the base pointer is Base_value
    .decl value_used_for_address(Mem:value_desc, Size:unsigned, Direction:symbol, Base_value: value_desc)
    .output value_used_for_address
    
    .decl value_type_helper(Location:value_desc, Type:symbol)
    // .output value_type_helper
    // value_type of Location, "ptr" or "data"
    .decl value_type(Location:value_desc, Type:symbol)
    .output value_type
    // value at Base[Offset] is pointing to Target 
    .decl point_to(Base: value_desc, Offset:number, Target: value_desc, Idx: value_desc, Mult:number, Target_offset:number)
    .output point_to
    .decl array_desc(Base:value_desc, Offset:number, Unit:layout, Len:number, Unit_size:number)
    .output array_desc

    // Combine all access pattern originate from the pointer Src
    .decl pattern_tape(Src: value_desc, Idx: value_desc, Mult:number, Offset: number, Type: layout)
    .output pattern_tape
    .decl access_handle(Src:value_desc, Idx: value_desc, Mult:number, Offset: number, Handle:value_desc)
    .output access_handle
    // Merge pattern defined for the same object
    .decl merged_tape(Src: value_desc, Idx: value_desc, Mult:number, Offset: number, Type: layout, Last_elem:number)
    .output merged_tape
    // Select the best object candidate from merged_tape.
    .decl object_candidate_helper(Src:value_desc, Idx: value_desc, Mult:number, Offset:number, Type: layout, Max_offset:number)
    .output object_candidate_helper
    .decl object_candidate(Src:value_desc, Idx: value_desc, Mult:number, Offset: number, Type: layout)
    .output object_candidate

    // detect loop for array recongnition
    .decl loop_detected(Start:number, End:number, Steps:number, Counter:value_desc)
    .output loop_detected
    // detect function args
    .decl function_reg_arg(Caller:address, Callee:address, Arg:value_desc)
    .output function_reg_arg

    .decl function_prototype(Name:symbol, Idx:unsigned, Type:symbol)
    .input function_prototype
    .decl arg_idx(Reg:symbol, Idx: unsigned)
    arg_idx("RDI", 1).
    arg_idx("RSI", 2).
    arg_idx("RDX", 3).
    arg_idx("RCX", 4).
    arg_idx("R8", 5).
    arg_idx("R9", 6).
}
.init struct_recovery = StructRecovery

struct_recovery.local_next(EA, EA_next):-
    code_in_refined_block(EA,Block),
    may_fallthrough(EA,EA_next),
    code_in_refined_block(EA_next,Block).

struct_recovery.def_usable_type(Type, Type1):-
    (Type="reg";Type="calc"),
    (Type1="reg";Type1="base";Type1="idx").

struct_recovery.def_usable_type("mem", "mem").
struct_recovery.def_usable_type("mem_calc", "mem").
// struct_recovery.def_usable_type("mem_bias", "mem_bias").

struct_recovery.def_usable_type("global", "global").

struct_recovery.value_def([EA, Base, Offset, "mem"]):-
    arch.mov(EA),
    code(EA),
    instruction_get_dest_op(EA,_,DestOp),
    op_indirect(DestOp,"NONE",Base,"NONE",_,Offset,_),
    !arch.pc_register(Base).

struct_recovery.value_def([EA, Base, Offset, "mem_bias"]):-
    arch.mov(EA),
    code(EA),
    instruction_get_dest_op(EA,_,DestOp),
    op_indirect(DestOp,"NONE",Base,Idx,_,Offset,_),
    Idx != "NONE",
    !arch.pc_register(Base).

struct_recovery.value_def([EA, Reg, 0, "reg"]):-
    code(EA),
    !arch.reg_reg_arithmetic_operation(EA, Reg, _, _, _, _),
    !arch.reg_arithmetic_operation(EA,Reg,_,_,_),
    instruction_get_operation(EA,Operation),
    Operation != "LEA",
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg).

struct_recovery.value_def([EA, Reg, 0, "calc"]):-
    code(EA),
    (arch.reg_arithmetic_operation(EA,Reg,_,_,_);
    arch.reg_reg_arithmetic_operation(EA,Reg,_,_,_,_);
    instruction_get_operation(EA,Operation),
    Operation = "LEA",
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg)).

struct_recovery.value_def([EA, Reg, 0, "reg"]):-
    code(EA),
    instruction_get_operation(EA,Operation),
    arch.call_operation(Operation),
    !arch.delay_slot(EA,_),
    arch.function_non_maintained_reg(Reg).

struct_recovery.value_def([EA, Reg, 0, "reg"]):-
    code(EA),
    instruction_get_operation(Call,Operation),
    arch.call_operation(Operation),
    arch.delay_slot(Call,EA),
    arch.function_non_maintained_reg(Reg).

struct_recovery.value_def([EA, Reg, 0, "calc"]):-
    code(EA),
    instruction_get_operation(EA, Operation),
    (Operation="PUSH";Operation="POP"),
    arch.stack_pointer(Reg).

struct_recovery.value_def([EA, Base, Address, "global"]):-
    arch.mov(EA),
    code(EA),
    instruction_get_dest_op(EA,_,Op),
    op_indirect(Op,"NONE",Base,"NONE",_,Offset,_),
    arch.pc_register(Base),
    next(EA, PC),
    Address = as(Offset, number) + as(PC, number).

struct_recovery.value_def([EA, Idx, Offset, "global_bias"]):-
    arch.mov(EA),
    code(EA),
    instruction_get_dest_op(EA,_,Op),
    op_indirect(Op,"NONE","NONE",Idx,_,Offset,_).

struct_recovery.value_def([EA, Reg, as(Size, number), "mem"]):-
    code(EA),
    instruction_get_operation(EA, Operation),
    Operation="PUSH",
    arch.pointer_size(Size),
    arch.stack_pointer(Reg).

struct_recovery.value_def(Def):-
    struct_recovery.value_arithmetic_operation(_, Def, _, _, _, _).

struct_recovery.value_arithmetic_operation(EA, [EA, Base, Offset, "mem_calc"], [EA, Base, Offset, "mem"], nil, 1, Offset_res):-
    code(EA),
    instruction_get_operation(EA, Operation),
    instruction_get_dest_op(EA, Idx1, Op1),
    instruction_get_src_op(EA, Idx1, Op1),
    instruction_get_src_op(EA, Idx2, Op2),
    Idx2 != Idx1,
    op_indirect(Op1,"NONE",Base,"NONE",_,Offset,_),
    op_immediate(Op2, Immediate),
    (Operation="ADD",Offset_res=as(Immediate, number); Operation="SUB",Offset_res=-as(Immediate, number)).
    
struct_recovery.value_arithmetic_edge([EA, Reg, 0, "calc"], [EA, Reg1, 0, "reg"], nil, 1, Offset):-
    code(EA),
    arch.reg_arithmetic_operation(EA, Reg, Reg1, 1, Offset).

struct_recovery.value_arithmetic_edge([EA, Reg, 0, "calc"], nil, [EA, Reg1, 0, Type], Mult, Offset):-
    code(EA),
    instruction_get_operation(EA, Operation),
    (Operation != "LEA", Type="reg";
    Operation = "LEA", Type="idx"),
    arch.reg_arithmetic_operation(EA, Reg, Reg1, Mult, Offset),
    Mult != 1.

struct_recovery.value_arithmetic_edge([EA, Reg1, 0, "calc"], [EA, Reg1, 0, "reg"], [EA, Reg2, 0, Type], Mult, Offset):-
    code(EA),
    instruction_get_operation(EA, Operation),
    (Operation != "LEA", Type="reg";
    Operation = "LEA", Type="idx"),
    arch.reg_reg_arithmetic_operation(EA, Reg1, Reg1, Reg2, Mult, Offset).
  
struct_recovery.value_arithmetic_edge([EA, Reg, 0, "calc"], [EA, Base, 0, "base"], [EA, Idx, 0, "idx"], Mult, Offset):-
    (struct_recovery.value_def([EA, Reg, _, "mem_bias"]);
    struct_recovery.value_used([EA, Reg, _, "mem_bias"])),
    arch.mov(EA),
    code(EA),
    instruction_get_op(EA,_,DestOp),
    op_indirect(DestOp,"NONE",Base,Idx,Mult,Offset,_).

struct_recovery.value_arithmetic_edge([EA, Reg, 0, "calc"], [EA, Idx, 0, "idx"], [EA, Base, 0, "base"], 1, Offset):-
    (struct_recovery.value_def([EA, Reg, _, "mem_bias"]);
    struct_recovery.value_used([EA, Reg, _, "mem_bias"])),
    arch.mov(EA),
    code(EA),
    instruction_get_op(EA,_,DestOp),
    op_indirect(DestOp,"NONE",Base,Idx,1,Offset,_).
  
struct_recovery.value_arithmetic_edge(Dst, Src, nil, Mult, Offset):-
    struct_recovery.value_arithmetic_operation(_, Dst, Src, nil, Mult, Offset).

struct_recovery.loop_detected(Start, End, Steps, Counter):-
    code(EA),
    instruction_get_operation(EA, Operation),
    arch.cmp_operation(Operation),
    code_in_refined_block(EA, Block),
    block_last_instruction(Block, Block_end),
    instruction_get_op(EA,Idx1,Op1),
    instruction_get_op(EA,Idx2,Op2),
    Idx1 != Idx2,
    op_indirect(Op1,"NONE",Base,"NONE",_,Offset,_),
    op_immediate(Op2, End_imm),
    struct_recovery.value_root([EA, Base, Offset, Type], Src1, _),
    struct_recovery.value_root([EA, Base, Offset, Type], Src2, _),
    Src1 != Src2,
    Counter=Src1,
    struct_recovery.resolve_calc(Src1, nil, nil, 1, Start),
    struct_recovery.value_arithmetic_edge(Src2, Val, _, _, Unit),
    struct_recovery.value_root(Val, Src1, _),
    Steps = Unit,
    instruction_get_operation(Block_end, Operation_jmp),
    (Operation_jmp="JLE",
    (End = End_imm + 1, Steps > 0;End = End_imm,Steps < 0)).

struct_recovery.resolve_calc([EA, Reg, 0, "calc"], [0, "NONE", 0, "global"], nil, 1, Address):-
    value_reg(EA, Reg, EA, "NONE", 0, Address, _).

struct_recovery.resolve_calc([EA, Base, Address, "global"], [0, "NONE", 0, "global"], nil, 1, Address):-
    struct_recovery.value_def([EA, Base, Address, "global"]);
    struct_recovery.value_used([EA, Base, Address, "global"]).

struct_recovery.resolve_calc([EA, Idx, Address, "global_bias"], [0, "NONE", 0, "global"], Root_idx, Mult, Address):-
    (struct_recovery.value_def([EA, Idx, Address, "global_bias"]),
    instruction_get_dest_op(EA,_,Op),
    op_indirect(Op,"NONE","NONE",Idx,Mult,_,_);
    struct_recovery.value_used([EA, Idx, Address, "global_bias"]),
    instruction_get_src_op(EA,_,Op),
    op_indirect(Op,"NONE","NONE",Idx,Mult,_,_)),
    struct_recovery.value_root([EA, Idx, 0, "idx"], Root_idx, _).

// resolve to root
struct_recovery.resolve_calc([EA, Base, 0, "calc"], Root, Idx, Mult, Offset):-
    struct_recovery.value_arithmetic_edge([EA, Base, 0, "calc"], Op1, Op2, Mult, Offset),
    struct_recovery.value_root(Op1, Root, _),
    struct_recovery.value_root(Op2, Idx , _),
    ((Root = [EA_root, Base_root, Offset_root, Type_root],
    EA_root=EA_root, Base_root=Base_root, Offset_root=Offset_root,
    Type_root != "calc");
    Root = nil),
    ((Idx = [EA_idx, Base_idx, Offset_idx, Type_idx],
    EA_idx=EA_idx, Base_idx=Base_idx, Offset_idx=Offset_idx,
    Type_idx != "calc", Type_idx != "mem_calc");
    Idx = nil).

// resolve idx
struct_recovery.resolve_calc([EA, Base, 0, "calc"], Root, Idx, Mult_res, Offset_res):-
    struct_recovery.value_arithmetic_edge([EA, Base, 0, "calc"], Op1, Op2, Mult, Offset),
    struct_recovery.value_root(Op1, Root, _),
    struct_recovery.value_root(Op2, [EA_idx, Base_idx, 0, "calc"], _),
    ((Root = [EA_root, Base_root, Offset_root, Type_root],
    EA_root=EA_root, Base_root=Base_root, Offset_root=Offset_root,
    Type_root != "calc");
    Root = nil),
    EA!=EA_idx,
    struct_recovery.resolve_calc([EA_idx, Base_idx, 0, "calc"], nil, Idx, Mult_idx, Offset_idx),
    Mult_res = Mult * Mult_idx,
    Offset_res = Offset + Mult * Offset_idx.

// resolve base
struct_recovery.resolve_calc([EA, Base, 0, "calc"], Root, Idx, Mult, Offset):-
    struct_recovery.value_arithmetic_edge([EA, Base, 0, "calc"], Op1, Op2, Mult, Offset1),
    struct_recovery.value_root(Op1, [EA_root, Base_root, Offset_root, "calc"], _),
    struct_recovery.value_root(Op2, Idx, _),
    ((Idx = [EA_idx, Base_idx, Offset_idx, Type_idx],
    EA_idx=EA_idx, Base_idx=Base_idx, Offset_idx=Offset_idx,
    Type_idx != "calc", Type_idx != "mem_calc");
    Idx = nil),
    struct_recovery.resolve_calc([EA_root, Base_root, Offset_root, "calc"], Root, nil, 1, Offset2),
    EA!=EA_root,
    Offset=Offset1+Offset2.

// resolve both
struct_recovery.resolve_calc([EA, Base, 0, "calc"], Root, Idx, Mult_res, Offset_res):-
    struct_recovery.value_arithmetic_edge([EA, Base, 0, "calc"], Op1, Op2, Mult, Offset1),
    struct_recovery.value_root(Op1, [EA_root, Base_root, Offset_root, "calc"], _),
    struct_recovery.value_root(Op2, [EA_idx, Base_idx, Offset_idx, "calc"], _),
    struct_recovery.resolve_calc([EA_root, Base_root, Offset_root, "calc"], Root, nil, 1, Offset2),
    struct_recovery.resolve_calc([EA_idx, Base_idx, Offset_idx, "calc"], nil, Idx, Mult_idx, Offset3),
    EA!=EA_root,
    EA!=EA_idx,
    Mult_res = Mult * Mult_idx,
    Offset=Offset1+Offset2,
    Offset_res = Offset + Mult * Offset3.

struct_recovery.resolve_calc([EA, Base, Offset, Type], [EA, Base, Offset, Type], nil, 1, 0):-
    struct_recovery.value_used_for_address(_, _, _, [EA, Base, Offset, Type]),
    !struct_recovery.value_src([EA, Base, Offset, Type], EA, "global_ptr"),
    Type!="calc",Type!="global",Type!="global_bias".

struct_recovery.resolve_calc([EA, Base, Offset, Type], nil, nil, 1, Immediate):-
    struct_recovery.value_src([EA, Base, Offset, Type], EA, "immediate"),
    arch.mov(EA),
    code(EA),
    instruction_get_src_op(EA,_,SrcOp),
    op_immediate(SrcOp, Immediate).

struct_recovery.value_must_def([EA, Base, Offset, Type]):-
    code(EA),
    struct_recovery.value_def([EA, Base, Offset, Type]),
    instruction_get_operation(EA, Op),
    !arch.conditional_operation(Op).

struct_recovery.value_used([EA, Base, Offset, "mem"]):-
    instruction_get_operation(EA, Operation),
    Operation!="LEA",
    code(EA),
    instruction_get_src_op(EA,_,SrcOp),
    op_indirect(SrcOp,"NONE",Base,"NONE",_,Offset,_),
    !arch.pc_register(Base).

struct_recovery.value_used([EA, Base, Offset, "mem_bias"]):-
    instruction_get_operation(EA, Operation),
    Operation!="LEA",
    code(EA),
    instruction_get_src_op(EA,_,SrcOp),
    op_indirect(SrcOp,"NONE",Base,Idx,_,Offset,_),
    Idx != "NONE",
    !arch.pc_register(Base).

struct_recovery.value_used([EA, Base, Address, "global"]):-
    arch.mov(EA),
    code(EA),
    instruction_get_src_op(EA,_,SrcOp),
    op_indirect(SrcOp,"NONE",Base,"NONE",_,Offset,_),
    arch.pc_register(Base),
    next(EA, PC),
    Address = as(Offset, number) + as(PC, number).

struct_recovery.value_used([EA, Reg, 0, "reg"]):-
    code(EA),
    instruction_get_src_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg),
    !is_xor_reset(EA).

struct_recovery.value_used([EA, Reg, 0, "reg"]):-
    code(EA),
    (arch.reg_arithmetic_operation(EA,Reg,Reg,_,_);
    arch.reg_reg_arithmetic_operation(EA,Reg,Reg,_,_,_)).

struct_recovery.value_used([EA, Reg, 0, "base"]):-
    code(EA),
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_,Reg,_,_,_,_),
    Reg != "NONE".

struct_recovery.value_used([EA, Reg, 0, "idx"]):-
    code(EA),
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_,_,Reg,_,_,_),
    Reg != "NONE".

struct_recovery.value_used([EA, Reg, 0, "reg"]):-
    code(EA),
    instruction_get_operation(Call,Operation),
    arch.call_operation(Operation),
    arch.delay_slot(Call,EA),
    arch.function_non_maintained_reg(Reg).

struct_recovery.value_used([EA, Idx, Offset, "global_bias"]):-
    arch.mov(EA),
    code(EA),
    instruction_get_src_op(EA,_,Op),
    op_indirect(Op,"NONE","NONE",Idx,_,Offset,_).

struct_recovery.loc_defined_in(Block, [Base, Offset, Type]):-
    struct_recovery.value_def([EA, Base, Offset, Type1]),
    code_in_refined_block(EA, Block),
    struct_recovery.def_usable_type(Type1, Type).

struct_recovery.loc_defined_in_block(EA, [Base, Offset, Type]):-
    struct_recovery.value_def([EA, Base, Offset, Type]).

struct_recovery.loc_defined_in_block(EA, [Base, Offset, Type1]):-
    struct_recovery.value_block_last_def(EA, [EA1, Base, Offset, Type]),
    struct_recovery.value_def([EA1, Base, Offset, Type]),
    struct_recovery.value_used([EA, Base, Offset, _]),
    struct_recovery.def_usable_type(Type, Type1).

struct_recovery.value_used_in_block(Block, [EA, Base, Offset, Type]):-
    struct_recovery.value_used([EA, Base, Offset, Type]),
    code_in_refined_block(EA, Block).

struct_recovery.value_block_last_def(EA_next, [EA, Base, Offset, Type]):-
    struct_recovery.value_def([EA, Base, Offset, Type]),
    struct_recovery.local_next(EA, EA_next).

struct_recovery.value_block_last_def(EA_next, [EA_def, Base, Offset, Type]):-
    struct_recovery.value_block_last_def(EA, [EA_def, Base, Offset, Type]),
    !struct_recovery.value_must_def([EA, Base, Offset, Type]),
    !struct_recovery.value_def([EA, Base, Offset, "calc"]),
    !struct_recovery.value_def([EA, Base, Offset, "reg"]),
    struct_recovery.local_next(EA, EA_next).

struct_recovery.value_last_def(Block, [EA, Base, Offset, Type]):-
    struct_recovery.value_def([EA, Base, Offset, Type]),
    block_next(EA, Block),
    !flow_def(EA, Base, Block, _).

// flow from def block to next block
struct_recovery.value_last_def(Block, [EA, Base, Offset, Type]):-
    struct_recovery.value_block_last_def(Block_end, [EA, Base, Offset, Type]),
    !struct_recovery.value_must_def([Block_end, Base, Offset, Type]),
    !struct_recovery.value_def([Block_end, Base, Offset, "calc"]),
    !struct_recovery.value_def([Block_end, Base, Offset, "reg"]),
    block_next(Block_end, Block),
    !flow_def(Block_end, Base, Block, _).

// flow through another block
struct_recovery.value_last_def(Block_next, [EA, Base, Offset, Type]):-
    struct_recovery.value_last_def(Block, [EA, Base, Offset, Type]),
    !struct_recovery.loc_defined_in(Block, [Base, Offset, Type]),
    block_last_instruction(Block, Block_end),
    block_next(Block_end, Block_next),
    !flow_def(Block_end, Base, Block, _).

// flow def
struct_recovery.value_last_def(Block_next, [Block_end, Reg, 0, "reg"]):-
    flow_def(Block_end,Reg,Block_next,_).

struct_recovery.value_def_used([EA_def, Base, Offset, Type], [EA, Base, Offset, Type1], "intra_block"):-
    struct_recovery.value_used([EA, Base, Offset, Type1]),
    struct_recovery.value_block_last_def(EA, [EA_def, Base, Offset, Type]),
    struct_recovery.def_usable_type(Type, Type1).

struct_recovery.value_def_used([EA_def, Base, Offset, Type], [EA, Base, Offset, Type1], "inter_block"):-
    struct_recovery.value_used([EA, Base, Offset, Type1]),
    code_in_refined_block(EA, Block),
    struct_recovery.value_last_def(Block, [EA_def, Base, Offset, Type]),
    !struct_recovery.loc_defined_in_block(EA, [Base, Offset, Type1]),
    struct_recovery.def_usable_type(Type, Type1).

struct_recovery.defined_value(Val):-
    struct_recovery.value_def_used(_, Val, _).

struct_recovery.used_value(Val):-
    struct_recovery.value_def_used(Val, _, _).

struct_recovery.value_src([EA_call, Reg, 0, "reg"], EA_call, "function"):-
    direct_call(EA_call, Callee),
    arch.return_val_reg(Reg),
    cfg_edge_to_symbol(Callee, _, _).

struct_recovery.value_src([EA, Reg, 0, "calc"], EA, "calc"):-
    struct_recovery.value_def([EA, Reg, 0, "calc"]).

struct_recovery.value_src([EA, Base, Offset, "mem_calc"], EA, "mem_calc"):-
    struct_recovery.value_def([EA, Base, Offset, "mem_calc"]).

struct_recovery.value_src([EA, Reg, 0, "reg"], EA, "global_ptr"):-
    value_reg(EA, Reg, EA, "NONE", 0, _, _).

struct_recovery.value_src([EA, Base, Offset, Type], EA, "immediate"):-
    struct_recovery.value_def([EA, Base, Offset, Type]),
    arch.mov(EA),
    code(EA),
    instruction_get_src_op(EA,_,SrcOp),
    op_immediate(SrcOp, _).

struct_recovery.value_src([EA, Base, Address, "global"], EA, "global"):-
    struct_recovery.value_used([EA, Base, Address, "global"]),
    initialized_data_segment(Begin, End),
    as(Address, address) >= Begin,
    as(Address, address) < End.

struct_recovery.value_src([Function, Reg, 0, "reg"], EA, "stack"):-
    code_in_refined_block(EA, EA_block),
    function_inference.in_function(EA_block, Function),
    struct_recovery.value_def([EA, Reg, 0, "reg"]),
    arch.frame_pointer(Reg).

struct_recovery.value_edge([EA, Base_src, Offset_src, Type_src], [EA, Base_dst, Offset_dst, Type_dst], "mov"):-
    arch.mov(EA),
    struct_recovery.value_def([EA, Base_dst, Offset_dst, Type_dst]),
    struct_recovery.value_used([EA, Base_src, Offset_src, Type_src]),
    (Type_src="reg";Type_src="mem";Type_src="global";Type_src="global_bias").

// Reg args
struct_recovery.value_edge([EA_def,Reg,0,Type], [EA,Reg,0,Type], "caller"):-
    struct_recovery.value_used([EA,Reg,0,Type]),
    !arch.pc_register(Reg),
    !arch.stack_pointer(Reg),
    !arch.frame_pointer(Reg),
    code_in_refined_block(EA,Block),
    function_inference.in_function(Block, Function),
    !struct_recovery.defined_value([EA, Reg, 0, Type]),
    direct_call(EA_call, Function),
    (Type="reg";Type="base";Type="idx"),
    (
        block_last_def(EA_call,EA_def,Reg)
        ;
        !block_last_def(EA_call,_,Reg),
        code_in_refined_block(EA_call, EA_call_block),
        last_def(EA_call_block,EA_def,Reg)
    ).

struct_recovery.value_edge([EA_def, Reg, 0, "reg"], [EA_used, Reg, 0, Type], "callee"):-
    def_used_return_val_reg(EA_def, _, Reg, EA_used, _),
    struct_recovery.value_used([EA_used, Reg, 0, Type]).
    

// def value root for src and its ref.
struct_recovery.value_root([EA_ref, Base, Offset, Type1], [EA_def, Base, Offset, Type], "self"):-
    struct_recovery.value_src([EA_def, Base, Offset, Type], EA_ref, _),
    struct_recovery.value_used([EA_ref, Base, Offset, Type1]),
    (Type1=Type;EA_ref!=EA_def).

// def value root for immediate and calc
struct_recovery.value_root([EA_ref, Base, Offset, Type], [EA_def, Base, Offset, Type], "value_def"):-
    struct_recovery.value_src([EA_def, Base, Offset, Type], EA_ref, _),
    struct_recovery.value_def([EA_ref, Base, Offset, Type]).

// passed by def_used
struct_recovery.value_root(Used, Root, "def_used"):-
    struct_recovery.value_root(Def, Root, _),
    struct_recovery.value_def_used(Def, Used, _).

// passed by value_edge
struct_recovery.value_root(Dst, Root, "value_edge"):-
    struct_recovery.value_root(Src, Root, _),
    struct_recovery.value_edge(Src, Dst, _).

// passed by global mem
struct_recovery.value_root([EA, Idx, Address, Type], Root, "global"):-
    struct_recovery.value_root([_, _, Address, Type], Root, _),
    struct_recovery.value_used([EA, Idx, Address, Type]),
    (Type="global";Type="global_bias").

// null
struct_recovery.value_root(nil, nil, "null").

struct_recovery.value_used_for_address([EA, Base, Offset, "mem"], Size, Direction, Value):-
    struct_recovery.src_for_address(Root),
    (struct_recovery.value_root(Value, Root, _);Value=Root),
    (struct_recovery.value_used([EA, Base, Offset, "mem"]),Direction="load";
    struct_recovery.value_def([EA, Base, Offset, "mem"]),Direction="store"),
    struct_recovery.value_root([EA, Base, 0, "base"], Root, _),
    instruction_memory_access_size(EA, _, Size).
    
struct_recovery.value_used_for_address([EA, Base, Offset, "mem_bias"], Size, Direction, Value):-
    struct_recovery.src_for_address(Root),
    (struct_recovery.value_root(Value, Root, _);Value=Root),
    (struct_recovery.value_used([EA, Base, Offset, "mem_bias"]),Direction="load";
    struct_recovery.value_def([EA, Base, Offset, "mem_bias"]),Direction="store"),
    struct_recovery.value_root([EA, _, 0, Type], Root, _),
    (Type = "idx"; Type = "base"),
    instruction_memory_access_size(EA, _, Size).

struct_recovery.value_used_for_address([EA, Base, Offset, Type], Size, Direction, [EA, Base, Offset, Type]):-
    (struct_recovery.value_used([EA, Base, Offset, Type]),Direction="load";
    struct_recovery.value_def([EA, Base, Offset, Type]),Direction="store"),
    instruction_memory_access_size(EA, _, Size),
    (Type="global";Type="global_bias").

struct_recovery.src_for_address(Src):-
    struct_recovery.value_src(Src, _, _),
    struct_recovery.value_root([_, _, _, "base"], Src, _).

struct_recovery.src_for_address(Src):-
    struct_recovery.value_src(Src, _, _),
    struct_recovery.value_root([EA, Reg, _, "idx"], Src, _),
    (struct_recovery.value_def([EA, _, _, "mem_bias"]);
    struct_recovery.value_used([EA, _, _, "mem_bias"])),
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_,_,Reg,Mult,_,_),
    Mult = 1,
    Reg != "NONE".

struct_recovery.not_for_address(Root):-
    instruction_memory_access_size(EA, _, Size),
    (struct_recovery.value_used([EA, Base, Offset, Value_type]);
    struct_recovery.value_def([EA, Base, Offset, Value_type])),
    (Value_type="mem";Value_type="global";Value_type="global_bias"),
    arch.pointer_size(Ptr_size),
    Ptr_size != Size,
    struct_recovery.value_root([EA, Base, Offset, Value_type], Root, _).

struct_recovery.value_type_helper([EA, Mem_base, Offset, Value_type], Type):-
    struct_recovery.value_root([EA, Mem_base, Offset, Value_type], Root, _),
    (Value_type="mem";Value_type="mem_bias";Value_type="global";Value_type="global_bias"),
    struct_recovery.src_for_address(Root), Type="ptr".

struct_recovery.value_type_helper([EA, Mem_base, Offset, Value_type], Type):-
    struct_recovery.value_root([EA, Mem_base, Offset, Value_type], Root, _),
    struct_recovery.value_root([EA_arg, Reg, 0, "reg"], Root, _),
    (Value_type="mem";Value_type="mem_bias";Value_type="global";Value_type="global_bias"),
    code_in_refined_block(EA, Block),
    function_inference.in_function(Block, Caller),
    struct_recovery.function_reg_arg(Caller, Callee, [EA_arg, Reg, 0, "reg"]),
    struct_recovery.function_prototype(Function_symbol, Idx, Type),
    cfg_edge_to_symbol(Callee, Function_symbol, _),
    struct_recovery.arg_idx(Reg, Idx),
    Idx > 0.

struct_recovery.value_type_helper([EA, Mem_base, Offset, Value_type], Type):-
    struct_recovery.value_root([EA, Mem_base, Offset, Value_type], Root, _),
    (Value_type="mem";Value_type="mem_bias";Value_type="global";Value_type="global_bias"),
    struct_recovery.value_src(Root, EA_call, "function"),
    code(EA_call),
    direct_call(EA_call, Callee),
    struct_recovery.function_prototype(Function_symbol, 0, Type),
    cfg_edge_to_symbol(Callee, Function_symbol, _).

struct_recovery.value_type([EA, Mem_base, Offset, Value_type], Type):-
    struct_recovery.value_type_helper([EA, Mem_base, Offset, Value_type], Type).

struct_recovery.value_type([EA, Mem_base, Offset, Value_type], "data"):-
    struct_recovery.value_root([EA, Mem_base, Offset, Value_type], _, _),
    (Value_type="mem";Value_type="mem_bias";Value_type="global";Value_type="global_bias"),
    !struct_recovery.value_type_helper([EA, Mem_base, Offset, Value_type], "ptr").

struct_recovery.point_to(Base, Offset_res, Root_base, Root_idx, Root_mult, Root_offset):-
    struct_recovery.src_for_address(Calc),
    struct_recovery.resolve_calc(Calc, Base, nil, 1, Offset_calc),
    struct_recovery.value_used_for_address([EA, Mem_base, Offset, Value_type], _, _, Calc),
    struct_recovery.value_root([EA, Mem_base, Offset, Value_type], Root, _),
    struct_recovery.resolve_calc(Root, Root_base, Root_idx, Root_mult, Root_offset),
    Offset_res=Offset + Offset_calc,
    struct_recovery.value_type([EA, Mem_base, Offset, Value_type], "ptr").

struct_recovery.point_to(Base, Offset_res, Root_base, Root_idx, Root_mult, Root_offset):-
    Calc=[EA_base, Reg_base, Offset_base, Type_base],
    (Type_base="global";Type_base="global_bias"),
    EA_base=EA_base, Reg_base=Reg_base, Offset_base=Offset_base,
    struct_recovery.resolve_calc(Calc, Base, nil, 1, Offset_calc),
    struct_recovery.value_used_for_address([EA, Mem_base, Offset, Value_type], _, _, Calc),
    struct_recovery.value_root([EA, Mem_base, Offset, Value_type], Root, _),
    struct_recovery.resolve_calc(Root, Root_base, Root_idx, Root_mult, Root_offset),
    Offset_res=Offset_calc,
    struct_recovery.value_type([EA, Mem_base, Offset, Value_type], "ptr").

struct_recovery.array_desc(Base, Offset_res, Unit, Len, Mult):-
    struct_recovery.object_candidate(Base, Idx, Mult, Offset_res, Unit),
    struct_recovery.loop_detected(Start, End, Steps, Idx),
    Len = (End - Start) / Steps.

struct_recovery.pattern_tape(Base, nil, 1, Offset_res, [nil, [0, Size, Type]]):-
    struct_recovery.src_for_address(Calc),
    struct_recovery.resolve_calc(Calc, Base, nil, 1, Offset_calc),
    struct_recovery.value_used_for_address([EA, Mem_base, Offset, MType], Size, _, Calc),
    Offset_res=Offset_calc +Offset,
    MType="mem",
    struct_recovery.value_type([EA, Mem_base, Offset, MType], Type).

struct_recovery.access_handle(Base, nil, 1, Offset_res, Calc):-
    struct_recovery.src_for_address(Calc),
    struct_recovery.resolve_calc(Calc, Base, nil, 1, Offset_calc),
    struct_recovery.value_used_for_address([EA, Mem_base, Offset, MType], _, _, Calc),
    MType="mem",
    EA=EA, Mem_base=Mem_base,
    Offset_res=Offset_calc +Offset.

struct_recovery.pattern_tape(Base, Idx, Mult, Offset_res, [nil, [0, Size, Type]]):-
    struct_recovery.src_for_address(Calc),
    struct_recovery.resolve_calc([EA, Mem_base, Offset, "calc"], Base, Idx, Mult, Offset_calc),
    struct_recovery.value_used_for_address([EA, Mem_base, Offset, MType], Size, _, Calc),
    Offset_res=Offset_calc,
    MType="mem_bias",
    struct_recovery.value_type([EA, Mem_base, Offset, MType], Type).

struct_recovery.access_handle(Base, Idx, Mult, Offset_res, Calc):-
    struct_recovery.src_for_address(Calc),
    struct_recovery.resolve_calc([EA, Mem_base, Offset, "calc"], Base, Idx, Mult, Offset_calc),
    struct_recovery.value_used_for_address([EA, Mem_base, Offset, MType], _, _, Calc),
    MType="mem_bias",
    EA=EA, Mem_base=Mem_base,
    Offset_res=Offset_calc.

struct_recovery.pattern_tape(Base, nil, 1, 0, [nil, [0, Size, Type]]):-
    struct_recovery.value_used_for_address([EA, Reg, Address, GType], Size, _, Calc),
    struct_recovery.resolve_calc(Calc, Base, nil, 1, 0),
    struct_recovery.value_type([EA, Reg, Address, GType], Type),
    Base != nil,
    (GType="global";GType="global_bias").

struct_recovery.access_handle(Base, nil, 1, 0, Calc):-
    struct_recovery.value_used_for_address([EA, Reg, Address, GType], _, _, Calc),
    EA=EA, Reg=Reg, Address=Address,
    struct_recovery.resolve_calc(Calc, Base, nil, 1, 0),
    Base != nil,
    (GType="global";GType="global_bias").

// global array field
struct_recovery.pattern_tape(Base, Idx, Mult, Offset_res, [nil, [0, Size, Type]]):-
    struct_recovery.value_used_for_address([EA, Reg, Address, GType], Size, _, Calc),
    struct_recovery.resolve_calc(Calc, Base, Idx, Mult, Offset_calc),
    Offset_res=Offset_calc,
    Base != nil,
    struct_recovery.value_type([EA, Reg, Address, GType], Type),
    (GType="global";GType="global_bias").

struct_recovery.access_handle(Base, Idx, Mult, Offset_res, Calc):-
    struct_recovery.value_used_for_address([EA, Reg, Address, GType], _, _, Calc),
    EA=EA, Reg=Reg, Address=Address,
    struct_recovery.resolve_calc(Calc, Base, Idx, Mult, Offset_calc),
    Offset_res=Offset_calc,
    Base != nil,
    (GType="global";GType="global_bias").

// array field
struct_recovery.pattern_tape(Base, Idx, Mult, Offset_res, [nil, [0, Size, Type]]):-
    struct_recovery.src_for_address(Calc),
    struct_recovery.resolve_calc(Calc, Base, Idx, Mult, Offset_calc),
    struct_recovery.value_used_for_address([EA, Mem_base, Offset, "mem"], Size, _, Calc),
    Offset_res=Offset_calc +Offset,
    struct_recovery.value_type([EA, Mem_base, Offset, "mem"], Type).

struct_recovery.access_handle(Base, Idx, Mult, Offset_res, Calc):-
    struct_recovery.src_for_address(Calc),
    struct_recovery.resolve_calc(Calc, Base, Idx, Mult, Offset_calc),
    struct_recovery.value_used_for_address([EA, Mem_base, Offset, "mem"], _, _, Calc),
    EA=EA, Mem_base=Mem_base,
    Offset_res=Offset_calc +Offset.

struct_recovery.merged_tape([EA, Reg, B_offset, BType], Idx, Mult, Offset, [nil, [0, Size, Type]], Offset):-
    struct_recovery.pattern_tape([EA, Reg, B_offset, BType], Idx, Mult, Offset, [nil, [0, Size, Type]]),
    !arch.frame_pointer(Reg),
    !arch.stack_pointer(Reg).
    
struct_recovery.merged_tape(Id, Idx, Mult, Offset1, [[Prev, [TypeOffset1, Size1, Type1]], [TypeOffset2, Size2, Type2]], Last_elem):-
    struct_recovery.merged_tape(Id, Idx, Mult, Offset1, [Prev, [TypeOffset1, Size1, Type1]], Last_elem1),
    struct_recovery.pattern_tape(Id, Idx, Mult, Offset2, [nil, [0, Size2, Type2]]),
    struct_recovery.access_handle(Id, Idx, Mult, Offset1, Handle),
    struct_recovery.access_handle(Id, Idx, Mult, Offset2, Handle),
    Offset2=min Offset2:{struct_recovery.pattern_tape(Id, Idx, Mult, Offset2, _), Offset2 >= Last_elem1 + as(Size1, number)},
    TypeOffset2 = Offset2 - Offset1,
    Last_elem = TypeOffset2 + Offset1.

struct_recovery.merged_tape(Id, Idx, Mult, Offset1, [[Prev, [TypeOffset1, Size1, Type1]], [TypeOffset2, Size2, Type2]], Last_elem):-
    struct_recovery.merged_tape(Id, Idx, Mult, Offset1, [Prev, [TypeOffset1, Size1, Type1]], Last_elem1),
    struct_recovery.pattern_tape(Id, Idx, Mult, Offset2, [nil, [0, Size2, Type2]]),
    struct_recovery.access_handle(Id, Idx, Mult, Offset1, Handle1),
    struct_recovery.access_handle(Id, Idx, Mult, Offset2, Handle2),
    Id != [0, "NONE", 0, "global"],
    Handle1_start = min Offset: struct_recovery.access_handle(Id, Idx, Mult, Offset, Handle1),
    Handle2_start = min Offset: struct_recovery.access_handle(Id, Idx, Mult, Offset, Handle2),
    Handle1_start < Handle2_start,
    Offset2=min Offset2:{struct_recovery.pattern_tape(Id, Idx, Mult, Offset2, _), Offset2 >= Last_elem1 + as(Size1, number)},
    TypeOffset2 = Offset2 - Offset1,
    Last_elem = TypeOffset2 + Offset1.

struct_recovery.merged_tape([0, "NONE", 0, "global"], Idx, Mult, Offset1, [[Prev, [TypeOffset1, Size1, Type1]], [TypeOffset2, Size2, Type2]], Last_elem):-
    struct_recovery.merged_tape([0, "NONE", 0, "global"], Idx1, Mult, Offset1, [Prev, [TypeOffset1, Size1, Type1]], Last_elem1),
    struct_recovery.pattern_tape([0, "NONE", 0, "global"], Idx2, Mult, Offset2, [nil, [0, Size2, Type2]]),
    struct_recovery.loop_detected(_, _, Steps, Idx1),
    struct_recovery.loop_detected(_, _, Steps, Idx2),
    Offset1 + Mult > Offset2,
    Offset2=min Offset2:{struct_recovery.pattern_tape([0, "NONE", 0, "global"], Idx, Mult, Offset2, _), Offset2 >= Last_elem1 + as(Size1, number)},
    TypeOffset2 = Offset2 - Offset1,
    Last_elem = TypeOffset2 + Offset1.

struct_recovery.object_candidate_helper(Id, Idx, Mult, Offset, [Prev, [Offset1, Size1, Type1]], Offset1):-
    Offset = min Offset :struct_recovery.merged_tape(Id, Idx, Mult, Offset, _, _),
    Id != [0, "NONE", 0, "global"],
    struct_recovery.merged_tape(Id, Idx, Mult, Offset, [Prev, [Offset1, Size1, Type1]], _).

struct_recovery.object_candidate_helper([0, "NONE", 0, "global"], Idx, Mult, Offset2, [Prev, [Offset1, Size1, Type1]], Offset1):-
    struct_recovery.merged_tape([0, "NONE", 0, "global"], Idx, Mult, Offset2, [Prev, [Offset1, Size1, Type1]], Last_elem),
    Offset2 = min Offset :struct_recovery.merged_tape([0, "NONE", 0, "global"], Idx, Mult, Offset, _, Last_elem).

struct_recovery.object_candidate_helper(Id, Idx, Mult, Offset, [Prev, [Offset1, Size1, Type1]], Offset1):-
    struct_recovery.merged_tape(Id, Idx, Mult, Offset, [Prev, [Offset1, Size1, Type1]], _),
    struct_recovery.point_to(_, _, Id, Idx, Mult, Offset).

struct_recovery.object_candidate(Id, Idx, Mult, Offset, [Prev, [Offset1, Size2, Type2]]):-
    Offset1 = max Offset1 :{struct_recovery.object_candidate_helper(Id, Idx, Mult, Offset, _, Offset1)},
    struct_recovery.object_candidate_helper(Id, Idx, Mult, Offset, [Prev, [Offset1, Size2, Type2]], Offset1).

struct_recovery.function_reg_arg(Caller, Callee, Arg):-
    code(EA),
    direct_call(EA, Callee),
    code_in_refined_block(EA, Block),
    function_inference.in_function(Block, Caller),
    struct_recovery.value_block_last_def(EA, [EA_def, Base, Offset, "reg"]),
    !struct_recovery.used_value([EA_def, Base, Offset, "reg"]),
    !arch.stack_pointer(Base),
    !arch.frame_pointer(Base),
    Arg=[EA_def, Base, Offset, "reg"].
// TODO: interprocedural global def used
// TODO: solve adjacent global objects