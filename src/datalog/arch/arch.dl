//===- arch.dl ----------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019-2022 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module provides a generic implementation of arch component. This allows
declaring all relations of the interface, and defining default rules for some
of them.
*/

#ifdef ARCH_ARM64
    #include "../arm_binaries.dl"
    #include "../arm64_binaries.dl"
    #include "arm64/arch_arm64.dl"
    .init arch = ARM64
#elif defined(ARCH_IA32)
    #include "intel/arch_x86_32.dl"
    .init arch = X86_32
#elif defined(ARCH_AMD64)
    #include "intel/arch_x86_64.dl"
    .init arch = X86_64
#else
    #error "Undefined architecture"
#endif

.comp Arch {

/**
Define a set of floating point operations
*/
.decl float_operation(operation:symbol)

.decl interrupt_operation(n:symbol)

.decl jump_operation(n:symbol)
.decl unconditional_jump_operation(n:symbol)

.decl jump_equal_operation(n:symbol)
.decl jump_unequal_operation(n:symbol)

.decl jump_operation_op_index(Operation:symbol,operand_index:operand_index)

.decl call_operation_op_index(Operation:symbol,operand_index:operand_index)

// Define all variants of the move operation.
.decl move_operation(Operation:symbol)

.decl load_operation(Operation:symbol)

.decl load_word_operation(Operation:symbol)

.decl store_operation(Operation:symbol)

/* Define all variants of a conditional move operation */
.decl conditional_mov(EA:address)

/* Find all addresses where a move instruction is used */
.decl mov(EA:address)

.decl is_nop(EA:address)

// Returns
.decl return(n:address)

/*
Unconditional return

NOTE: unconditional_return_operation must be used with 'return' rule.
*/
.decl unconditional_return_operation(operation:symbol)

.decl conditional_return_operation(operation:symbol)

.decl is_conditional_operation(Operation:symbol)

.decl delay_slot(BranchEA:address,EA:address)

.decl jump(EA:address)

.decl op_does_not_read_dest_reg(Operation:symbol)

.decl arithmetic_operation(Operation:symbol)

.decl multiplication_operation(Operation:symbol)

.decl logic_operation(Operation:symbol)

.decl read_only_operation(Operation:symbol)

.decl write_only_operation(Operation:symbol)

.decl one_op_write(Operation:symbol)

.decl call_operation(operation:symbol)

.decl syscall_operation(operation:symbol)

.decl return_operation(operation:symbol)

.decl halt_operation(operation:symbol)

.decl cmp_operation(Operation:symbol)

// These operations are either special like LEA (does not read memory) or
// are not decoded corectly from capstone
.decl operation_size_exception(EA:address,Op_index:operand_index,Size:unsigned)

// arithmetic operation on two source registers
.decl reg_reg_arithmetic_operation(EA:address,Reg_dest:register,Reg1:register,Reg2:register,Mult:number,Offset:number)
.output reg_reg_arithmetic_operation

/**
 * The location and register where the address of main is loaded.
 */
.decl main_load_reg(EA:address,Reg:register)

// Limit the registers that are tracked and transform the names to their 64-bit
// versions.
.decl track_register(RegName:register,RegGenericName:register)

// This specifies the registers whose value is not kept through a function call.
.decl function_non_maintained_reg(reg:register)

.decl pc_register(reg:register)

.decl frame_pointer(reg:register)

.decl stack_pointer(reg:register)

.decl return_val_reg(reg:register)


}
