//===- arch_arm.dl ------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to abstract from ARM specific instruction set
and characteristics
*/


.comp ARM : Arch {

#include "float_operations.dl"
#include "jump_operations.dl"
#include "interrupt_operations.dl"
#include "registers.dl"

move_operation(Operation) :-
    instruction_get_operation(_, Operation),
    contains("MOV", Operation).

move_operation("MVN").

load_operation(Operation):-
    instruction_get_operation(_,Operation),
    (
        contains("LDR", Operation)
        ;
        contains("LDM", Operation)
    ).

load_word_operation(Operation):-
    instruction_get_operation(_,Operation),
    substr(Operation,0,3) = "LDR",
    (
        strlen(Operation) = 3; // unconditional
        strlen(Operation) = 5  // conditional ldr
    ).

store_operation(Operation):-
    instruction_get_operation(_,Operation),
    (
        contains("STR", Operation)
        ;
        contains("STM", Operation)
    ).

mov(EA):-
    instruction_get_operation(EA,Operation),
    (
        move_operation(Operation);
        load_operation(Operation)
    ).

is_nop(EA):-
    instruction_get_operation(EA,"NOP").

// We have no return_operation, so we override.
.override return
return(EA):-
    instruction_get_operation(EA,"BX"),
    instruction_get_op(EA,_,Op),
    op_regdirect_contains_reg(Op,"LR").

return(EA):-
    instruction_get_operation(EA,Operation),
    substr(Operation,0,3) = "POP",
    instruction_get_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg),
    pc_register(Reg).

return(EA):-
    instruction_get_operation(EA,"MOV"),
    instruction_get_dest_op(EA,_,DestOp),
    op_regdirect_contains_reg(DestOp,PC),
    pc_register(PC),
    instruction_get_src_op(EA,_,SrcOp),
    op_regdirect_contains_reg(SrcOp,"LR").

.decl long_operation(operation:symbol)

long_operation(Operation):-
    instruction_get_operation(_,Operation),
    strlen(Operation) > 2.

/**
ARM Condition codes
*/
.decl condition_code(CC:symbol)
condition_code("EQ").
condition_code("NE").
condition_code("GT").
condition_code("LT").
condition_code("GE").
condition_code("LE").
condition_code("CS").
condition_code("HS").
condition_code("CC").
condition_code("LO").
condition_code("MI").
condition_code("PL").
condition_code("VS").
condition_code("VC").
condition_code("HI").
condition_code("LS").

conditional_operation(Operation):-
    long_operation(Operation),
    instruction_get_operation(_,Operation),
    Size = strlen(Operation),
    Operation != "TEQ", Operation != "SMMLS",
    Operation != "MLS", Operation != "HVC",
    CC = substr(Operation,Size-2,2),
    condition_code(CC).

// Does not override - extends with `ldr pc, [...]`
jump(EA):-
    instruction_get_operation(EA,Operation),
    load_operation(Operation),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect(Op,Reg),
    pc_register(Reg).

op_does_not_read_dest_reg(Operation):-
    // TODO: There could be more.
    load_operation(Operation).

arithmetic_operation(Operation):-
    instruction_get_operation(_,Operation),
    Op = substr(Operation,0,3),
    (
        Op = "ADD";
        Op = "ADC";
        Op = "DEC";
        Op = "MUL";
        Op = "MLA";
        Op = "MVN";
        Op = "RSB";
        Op = "RSC";
        Op = "SBC";
        Op = "SHL";
        Op = "SUB"
    ).

multiplication_operation(Operation):-
    instruction_get_operation(_,Operation),
    Op = substr(Operation,0,3),
    (
        Op = "MUL";
        Op = "MLA";
        Op = "MLS"
    ).

logic_operation(Operation):-
    instruction_get_operation(_,Operation),
    Op = substr(Operation,0,3),
    (
        Op = "BIC";
        Op = "EOR";
        Op = "AND";
        Op = "XOR";
        Op = "ORR";
        Op = "TST";
        Op = "MVN"
    ).

read_only_operation(Operation):-
    instruction_get_operation(_,Operation),
    Op = substr(Operation,0,3),
    (
        Op = "CMN";
        Op = "CMP";
        Op = "TEQ";
        Op = "TST"
    ).

// TODO:
write_only_operation(""):-
    false.

// TODO:
one_op_write(""):-
    false.

pointer_size(4).

call_operation("BL").
call_operation("BLEQ").
call_operation("BLNE").
call_operation("BLCS").
call_operation("BLCC").
call_operation("BLMI").
call_operation("BLPL").
call_operation("BLVS").
call_operation("BLVC").
call_operation("BLHI").
call_operation("BLLS").
call_operation("BLGE").
call_operation("BLLT").
call_operation("BLGT").
call_operation("BLLE").
call_operation("BLAL").

call_operation("BLX").
call_operation("BLXEQ").
call_operation("BLXNE").
call_operation("BLXCS").
call_operation("BLXCC").
call_operation("BLXMI").
call_operation("BLXPL").
call_operation("BLXVS").
call_operation("BLXVC").
call_operation("BLXHI").
call_operation("BLXLS").
call_operation("BLXGE").
call_operation("BLXLT").
call_operation("BLXGT").
call_operation("BLXLE").
call_operation("BLXAL").

syscall_operation("SWI").

// TODO:
return_operation(""):-
    false.

cmp_operation(Operation):-
    instruction_get_operation(_,Operation),
    Op = substr(Operation,0,3),
    (
        Op = "CMP";
        Op = "CMN";
        Op = "TEQ";
        Op = "TST"
    ).

// ADD/SUB reg, #imm (two operands: Thumb)
reg_arithmetic_operation(EA,Reg,Reg,1,Sign*Immediate):-
    instruction(EA,_,_,Operation,Op1,Op2,0,0,_,_),
    (
        Operation = "ADD", Sign = 1;
        Operation = "SUB", Sign = -1
    ),
    op_immediate(Op1,Immediate),
    op_regdirect_contains_reg(Op2,Reg).

// ADD/SUB reg, reg, #imm
reg_arithmetic_operation(EA,Dst,Src,1,Sign*Immediate):-
    instruction(EA,_,_,Operation,Op1,Op2,Op3,0,_,_),
    (
        Operation = "ADD", Sign = 1;
        Operation = "SUB", Sign = -1
    ),
    op_regdirect_contains_reg(Op1,Src),
    op_immediate(Op2,Immediate),
    op_regdirect_contains_reg(Op3,Dst).

// ADD/SUB reg, reg (two operands: Thumb)
reg_reg_arithmetic_operation(EA,Reg2,Reg2,Reg1,Sign,0):-
    instruction(EA,_,_,Operation,Op1,Op2,0,0,_,_),
    (
        Operation = "ADD", Sign = 1;
        Operation = "SUB", Sign = -1
    ),
    op_regdirect_contains_reg(Op2,Reg2),
    op_regdirect_contains_reg(Op1,Reg1).

// ADD/SUB reg, reg, reg
reg_reg_arithmetic_operation(EA,Dst,Src1,Src2,Sign,0):-
    instruction(EA,_,_,Operation,Op1,Op2,Op3,0,_,_),
    (
        Operation = "ADD", Sign = 1;
        Operation = "SUB", Sign = -1
    ),
    op_regdirect_contains_reg(Op1,Src1),
    op_regdirect_contains_reg(Op2,Src2),
    op_regdirect_contains_reg(Op3,Dst).

// ADD Reg1, Reg2, N, M
reg_reg_arithmetic_operation(EA,DstReg,Reg,"NONE",1,Val):-
    instruction(EA,_,_,"ADD",Op1,Op2,Op3,DstOp,_,_),
    op_regdirect_contains_reg(Op1,Reg),
    op_immediate(Op2,N),
    op_immediate(Op3,M),
    op_regdirect_contains_reg(DstOp,DstReg),
    N >= 0,
    // N right-rotate M
    Val = (N bshr M) bor (N bshl (32-M)).

inferred_main_in_reg(EA,"R0"):-
    inferred_main_dispatch(EA).

}
