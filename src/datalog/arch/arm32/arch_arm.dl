//===- arch_arm.dl ------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to abstract from ARM specific instruction set
and characteristics
*/


.comp ARM : Arch {

#include "float_operations.dl"
#include "jump_operations.dl"
#include "interrupt_operations.dl"
#include "registers.dl"
#include "memory_access.dl"

move_operation(Operation) :-
    instruction_get_operation(_, Operation),
    contains("MOV", Operation).

load_operation(Operation):-
    instruction_get_operation(_,Operation),
    (
        contains("LDR", Operation)
        ;
        contains("LDM", Operation)
    ).

load_word_operation(Operation):-
    instruction_get_operation(_,Operation),
    substr(Operation,0,3) = "LDR",
    (
        strlen(Operation) = 3; // unconditional
        strlen(Operation) = 5  // conditional ldr
    ).

store_operation(Operation):-
    instruction_get_operation(_,Operation),
    (
        contains("STR", Operation)
        ;
        contains("STM", Operation)
    ).

is_nop(EA):-
    instruction_get_operation(EA,"NOP").

// We have no return_operation, so we override.
.override return
return(EA):-
    instruction_get_operation(EA,Operation),
    substr(Operation,0,2) = "BX",
    instruction_get_op(EA,_,Op),
    op_regdirect_contains_reg(Op,"LR").

return(EA):-
    instruction_get_operation(EA,Operation),
    substr(Operation,0,3) = "POP",
    instruction_get_op(EA,_,Op),
    op_register_bitfield(Op,_,Reg),
    pc_register(Reg).

return(EA):-
    instruction_get_operation(EA,Operation),
    substr(Operation,0,3) = "MOV",
    instruction_get_dest_op(EA,_,DestOp),
    op_regdirect(DestOp,PC),
    pc_register(PC),
    instruction_get_src_op(EA,_,SrcOp),
    op_regdirect_contains_reg(SrcOp,"LR").

.decl long_operation(operation:symbol)

long_operation(Operation):-
    instruction_get_operation(_,Operation),
    strlen(Operation) > 2.

conditional_operation(Operation,CC):-
    long_operation(Operation),
    instruction_get_operation(_,Operation),
    Size = strlen(Operation),
    Operation != "TEQ", Operation != "SMMLS",
    Operation != "MLS", Operation != "HVC",
    Suffix = substr(Operation,Size-2,2),
    condition_code_map(Suffix,CC).

// Conditional instructions implicitly use the CPSR, which capstone doesn't
// seem to indicate reliably in cs_reg_access.
uses_reg(EA,"CPSR"):-
    conditional(EA,_).

/**
PC stores the address of the current instruction plus 8 (two ARM
instructions) in ARM state, and the current instruction plus 4
(two Thumb instructions) in Thumb state.
This is used for computing PC-relative addresses.

NOTE: More specifically, in Thumb state,
for B, BL, CBNZ, and CBZ instructions, the value of the PC is the address of
the current instruction plus 4 bytes.
For all other instructions that use labels, the value of the PC is the address
of the current instruction plus 4 bytes, with bit[1] of the result
cleared to 0 to make it word-aligned.
The word-alignment needs to be handled where this is used.
*/
.decl pc_relative_disp(EA:address,Disp:number) inline

pc_relative_disp(EA,Disp):-
    (EA band 1) = 0,  Disp = 8  // ARM mode
    ;
    (EA band 1) != 0, Disp = 4. // Thumb mode

pc_relative_addr(EA,Reg,Val):-
    instruction(EA,_,_,Operation,OffsetOp,DestOp,0,_,_,_),
    substr(Operation,0,3) = "ADR",
    op_immediate(OffsetOp, Offset),
    op_regdirect_contains_reg(DestOp,Reg),
    pc_relative_disp(EA,Disp),
    Val = as(EA - (EA band 1),number) + Offset + Disp.

pc_relative_addr(EA,Reg,Val):-
    instruction(EA,_,_,Operation,PCOp,OffsetOp,DestOp,0,_,_),
    substr(Operation,0,3) = "ADD",
    op_immediate(OffsetOp, Offset),
    op_regdirect_contains_reg(DestOp,Reg),
    op_regdirect(PCOp,PC),
    arch.pc_register(PC),
    pc_relative_disp(EA,Disp),
    Val = as(EA - (EA band 1),number) + Offset + Disp.

/**
IT: The IT (If-Then) instruction makes up to four following instructions
(the IT block) conditional.

ITxyz
x,y,z: specifies the condition switch for the second, third, and fourth
instruction in the IT block, respectively.

The condition switch in the IT block can be either: T (Then) or E (Else).

This predicate determines if EA is a IT block instruction.
*/
.decl it_conditional(EA:address,IT:address)
.output it_conditional

it_conditional(EA,IT):-
    instruction_get_operation(IT,Operation),
    substr(Operation,0,2) = "IT",
    next(IT,EA).

it_conditional(EA,IT):-
    instruction_get_operation(IT,Operation),
    substr(Operation,0,2) = "IT",
    strlen(Operation) >= 3,
    next(IT,Prev1),
    next(Prev1,EA).

it_conditional(EA,IT):-
    instruction_get_operation(IT,Operation),
    substr(Operation,0,2) = "IT",
    strlen(Operation) >= 4,
    next(IT,Prev2),
    next(Prev2,Prev1),
    next(Prev1,EA).

it_conditional(EA,IT):-
    instruction_get_operation(IT,Operation),
    substr(Operation,0,2) = "IT",
    strlen(Operation) = 5,
    next(IT,Prev3),
    next(Prev3,Prev2),
    next(Prev2,Prev1),
    next(Prev1,EA).

conditional(EA,CC):-
    it_conditional(EA,IT),
    instruction_get_op(IT,1,Op),
    op_special(Op,"it",ArmCC),
    condition_code_map(ArmCC,CC).

// Does not override - extends with `ldr pc, [...] or mov pc, reg`
jump(EA):-
    load(EA,_,_,Reg,_,_,_,_),
    pc_register(Reg),
    !arch.return(EA).

op_does_not_read_dest_reg(Operation):-
    // TODO: There could be more.
    load_operation(Operation).

arithmetic_operation(Operation):-
    instruction_get_operation(_,Operation),
    Op = substr(Operation,0,3),
    (
        Op = "ADD";
        Op = "ADC";
        Op = "DEC";
        Op = "MUL";
        Op = "MLA";
        Op = "MVN";
        Op = "RSB";
        Op = "RSC";
        Op = "SBC";
        Op = "SHL";
        Op = "SUB"
    ).

multiplication_operation(Operation):-
    instruction_get_operation(_,Operation),
    Op = substr(Operation,0,3),
    (
        Op = "MUL";
        Op = "MLA";
        Op = "MLS";
        Op = "LSL"
    ).

shift_rotate_operation(Operation):-
    instruction_get_operation(_,Operation),
    Op = substr(Operation,0,3),
    (
        Op = "ASR";
        Op = "LSL";
        Op = "LSR";
        Op = "ROR";
        Op = "RRX"
    ).

logic_operation(Operation):-
    instruction_get_operation(_,Operation),
    Op = substr(Operation,0,3),
    (
        Op = "BIC";
        Op = "EOR";
        Op = "AND";
        Op = "XOR";
        Op = "ORR";
        Op = "TST";
        Op = "MVN"
    ).

read_only_operation(Operation):-
    instruction_get_operation(_,Operation),
    Op = substr(Operation,0,3),
    (
        Op = "CMN";
        Op = "CMP";
        Op = "TEQ";
        Op = "TST"
    ).

// TODO:
write_only_operation(Operation):-
    instruction_get_operation(_,Operation),
    substr(Operation,0,3) = "POP".

// TODO:
one_op_write(""):-
    false.

pointer_size(4).

call_operation("BL").
call_operation("BLEQ").
call_operation("BLNE").
call_operation("BLCS").
call_operation("BLCC").
call_operation("BLMI").
call_operation("BLPL").
call_operation("BLVS").
call_operation("BLVC").
call_operation("BLHI").
call_operation("BLLS").
call_operation("BLGE").
call_operation("BLLT").
call_operation("BLGT").
call_operation("BLLE").
call_operation("BLAL").

call_operation("BLX").
call_operation("BLXEQ").
call_operation("BLXNE").
call_operation("BLXCS").
call_operation("BLXCC").
call_operation("BLXMI").
call_operation("BLXPL").
call_operation("BLXVS").
call_operation("BLXVC").
call_operation("BLXHI").
call_operation("BLXLS").
call_operation("BLXGE").
call_operation("BLXLT").
call_operation("BLXGT").
call_operation("BLXLE").
call_operation("BLXAL").

syscall_operation("SWI").

// TODO:
return_operation(""):-
    false.

cmp_operation(Operation):-
    instruction_get_operation(_,Operation),
    Op = substr(Operation,0,3),
    (
        Op = "CMP";
        Op = "CMN";
        Op = "TEQ";
        Op = "TST"
    ).

// ADD/SUB reg, #imm (two operands: Thumb)
reg_arithmetic_operation(EA,Reg,Reg,1,Sign*Immediate):-
    instruction(EA,_,_,Operation,Op1,Op2,0,0,_,_),
    (
        Operation = "ADD", Sign = 1;
        Operation = "SUB", Sign = -1
    ),
    op_immediate(Op1,Immediate),
    op_regdirect_contains_reg(Op2,Reg).

// ADD/SUB reg, reg, #imm
reg_arithmetic_operation(EA,Dst,Src,1,Sign*Immediate):-
    instruction(EA,_,_,Operation,Op1,Op2,Op3,0,_,_),
    (
        Operation = "ADD", Sign = 1;
        Operation = "SUB", Sign = -1
    ),
    op_regdirect_contains_reg(Op1,Src),
    op_immediate(Op2,Immediate),
    op_regdirect_contains_reg(Op3,Dst).

// ADD Reg1, Reg2, N, M
reg_arithmetic_operation(EA,DstReg,Reg,1,Val):-
    instruction(EA,_,_,"ADD",Op1,Op2,Op3,DstOp,_,_),
    op_regdirect_contains_reg(Op1,Reg),
    op_immediate(Op2,N),
    op_immediate(Op3,M),
    op_regdirect_contains_reg(DstOp,DstReg),
    N >= 0,
    // N right-rotate M
    Val = (N bshr M) bor (N bshl (32-M)).

// ADD/SUB reg, reg (two operands: Thumb)
reg_reg_arithmetic_operation(EA,Reg2,Reg2,Reg1,Sign,0):-
    instruction(EA,_,_,Operation,Op1,Op2,0,0,_,_),
    (
        Operation = "ADD", Sign = 1;
        Operation = "SUB", Sign = -1
    ),
    op_regdirect_contains_reg(Op2,Reg2),
    op_regdirect_contains_reg(Op1,Reg1).

// ADD/SUB reg, reg, reg
reg_reg_arithmetic_operation(EA,Dst,Src1,Src2,Sign,0):-
    instruction(EA,_,_,Operation,Op1,Op2,Op3,0,_,_),
    (
        Operation = "ADD", Sign = 1;
        Operation = "SUB", Sign = -1
    ),
    op_regdirect_contains_reg(Op1,Src1),
    op_regdirect_contains_reg(Op2,Src2),
    op_regdirect_contains_reg(Op3,Dst).

inferred_main_in_reg(EA,"R0"):-
    inferred_main_dispatch(EA).

}
