//===- arch_arm.dl ------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to abstract from ARM specific instruction set
and characteristics
*/


.comp ARM {

#include "jump_operations.dl"
#include "interrupt_operations.dl"
#include "registers.dl"

// Define all variants of the move operation.
.decl move_operation(Operation:symbol)
move_operation(Operation) :-
    instruction_get_operation(_, Operation),
    contains("MOV", Operation).

move_operation("MVN").

.decl load_operation(Operation:symbol)

load_operation(Operation):-
    instruction_get_operation(_,Operation),
    (
        contains("LDR", Operation)
        ;
        contains("LDM", Operation)
    ).

.decl load_word_operation(Operation:symbol)

load_word_operation(Operation):-
    instruction_get_operation(_,Operation),
    substr(Operation,0,3) = "LDR",
    (
        strlen(Operation) = 3; // unconditional
        strlen(Operation) = 5  // conditional ldr
    ).

.decl store_operation(Operation:symbol)

store_operation(Operation):-
    instruction_get_operation(_,Operation),
    (
        contains("STR", Operation)
        ;
        contains("STM", Operation)
    ).

// TODO:
.decl conditional_mov(EA:address)

conditional_mov(0):-
    false.

.decl mov(EA:address)

mov(EA):-
    instruction_get_operation(EA,Operation),
    (
        move_operation(Operation);
        load_operation(Operation)
    ).

.decl is_nop(EA:address)

is_nop(EA):-
    instruction_get_operation(EA,"NOP").

// Returns
.decl return(n:address)

return(EA):-
    instruction_get_operation(EA,"BX"),
    instruction_get_op(EA,_,Op),
    op_regdirect_contains_reg(Op,"LR").

return(EA):-
    instruction_get_operation(EA,Operation),
    contains("POP", Operation),
    instruction_get_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg),
    pc_register(Reg).

return(EA):-
    instruction_get_operation(EA,"MOV"),
    instruction_get_dest_op(EA,_,DestOp),
    op_regdirect_contains_reg(DestOp,PC),
    pc_register(PC),
    instruction_get_src_op(EA,_,SrcOp),
    op_regdirect_contains_reg(SrcOp,"LR").

.decl unconditional_return_operation(operation:symbol)

// NOTE: unconditional_return_operation must be used with 'return' rule.
unconditional_return_operation(Operation):-
    instruction_get_operation(_,Operation),
    (
        Operation = "BX";
        Operation = "MOV";
        Operation = "POP"
    ),
    !conditional_return_operation(Operation).

.decl conditional_return_operation(operation:symbol)

conditional_return_operation(Operation):-
    instruction_get_operation(_,Operation),
    contains("POP", Operation),
    strlen(Operation) != 3.

.decl long_operation(operation:symbol)

long_operation(Operation):-
    instruction_get_operation(_,Operation),
    strlen(Operation) > 2.

.decl is_conditional_operation(Operation:symbol)

is_conditional_operation(Operation):-
    long_operation(Operation),
    instruction_get_operation(_,Operation),
    Size = strlen(Operation),
    Operation != "TEQ", Operation != "SMMLS",
    Operation != "MLS", Operation != "HVC",
    CC = substr(Operation,Size-2,2),
    (
        CC = "EQ"; CC = "NE"; CC = "CS"; CC = "HS";
        CC = "CC"; CC = "LO"; CC = "MI"; CC = "PL";
        CC = "VS"; CC = "VC"; CC = "HI"; CC = "LS";
        CC = "GE"; CC = "LT"; CC = "GT"; CC = "LE"
    ).

.decl delay_slot(BranchEA:address,EA:address)

// No rule for delay_slot
delay_slot(0,0):-
    false.

.decl jump(EA:address)
.output jump

jump(EA):-
    instruction_get_operation(EA,Operation),
    jump_operation(Operation).

jump(EA):-
    instruction_get_operation(EA,Operation),
    load_operation(Operation),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect(Op,Reg),
    pc_register(Reg).

.decl op_does_not_read_dest_reg(Operation:symbol)

op_does_not_read_dest_reg(Operation):-
    // TODO: There could be more.
    load_operation(Operation).

.decl arithmetic_operation(Operation:symbol)

arithmetic_operation("ADD").
arithmetic_operation("ADC").
arithmetic_operation("DEC").
arithmetic_operation("MUL").
arithmetic_operation("MLA").
arithmetic_operation("MVN").
arithmetic_operation("RSB").
arithmetic_operation("RSC").
arithmetic_operation("SBC").
arithmetic_operation("SHL").
arithmetic_operation("SUB").

.decl multiplication_operation(Operation:symbol)

multiplication_operation("MUL").
multiplication_operation("MLA").
multiplication_operation("MLS").
multiplication_operation("MULS").

.decl logic_operation(Operation:symbol)

logic_operation("BIC").
logic_operation("EOR").
logic_operation("AND").
logic_operation("XOR").
logic_operation("OR").
logic_operation("TEST").

.decl read_only_operation(Operation:symbol)

read_only_operation("CMN").
read_only_operation("CMP").
read_only_operation("TEQ").
read_only_operation("TST").

.decl write_only_operation(Operation:symbol)

write_only_operation(""):-
    false.

// TODO:
.decl one_op_write(Operation:symbol)

one_op_write(""):-
    false.

.decl pointer_size(n:unsigned) inline

pointer_size(4).

// TODO:
.decl loop_operation(operation:symbol)

loop_operation(""):-
    false.

// TODO:
.decl loop_prefix(prefix:symbol)

loop_prefix(""):-
    false.

.decl call_operation(operation:symbol)

call_operation("BL").
call_operation("BLEQ").
call_operation("BLNE").
call_operation("BLCS").
call_operation("BLCC").
call_operation("BLMI").
call_operation("BLPL").
call_operation("BLVS").
call_operation("BLVC").
call_operation("BLHI").
call_operation("BLLS").
call_operation("BLGE").
call_operation("BLLT").
call_operation("BLGT").
call_operation("BLLE").
call_operation("BLAL").

call_operation("BLX").
call_operation("BLXEQ").
call_operation("BLXNE").
call_operation("BLXCS").
call_operation("BLXCC").
call_operation("BLXMI").
call_operation("BLXPL").
call_operation("BLXVS").
call_operation("BLXVC").
call_operation("BLXHI").
call_operation("BLXLS").
call_operation("BLXGE").
call_operation("BLXLT").
call_operation("BLXGT").
call_operation("BLXLE").
call_operation("BLXAL").

.decl syscall_operation(operation:symbol)

syscall_operation("SWI").

// TODO:
.decl halt_operation(operation:symbol)

halt_operation(""):-
    false.

.decl cmp_operation(Operation:symbol)

cmp_operation("CMP").
cmp_operation("CMN").
cmp_operation("TEQ").
cmp_operation("TST").

// TODO:
.decl operation_size_exception(EA:address,Op_index:operand_index,Size:unsigned)

operation_size_exception(0,0,0):-
    false.

// TODO:
// arithmetic operation on two source registers
.decl reg_reg_arithmetic_operation(EA:address,Reg_dest:register,Reg1:register,Reg2:register,Mult:number,Offset:number)
.output reg_reg_arithmetic_operation

reg_reg_arithmetic_operation(EA,Reg2,Reg2,Reg1,-1,0):-
    instruction(EA,_,_,"SUB",Op1,Op2,0,0,_,_), Op1 != Op2,
    op_regdirect_contains_reg(Op1,Reg1),
    op_regdirect_contains_reg(Op2,Reg2).

reg_reg_arithmetic_operation(EA,Reg2,Reg1,Reg2,1,0):-
    instruction(EA,_,_,"ADD",Op1,Op2,0,0,_,_), Op1 != Op2,
    op_regdirect_contains_reg(Op2,Reg2),
    op_regdirect_contains_reg(Op1,Reg1).

// ADD Reg1, Reg2, N
reg_reg_arithmetic_operation(EA,DstReg,Reg,"NONE",1,N):-
    instruction(EA,_,_,"ADD",Op1,Op2,DstOp,0,_,_),
    op_regdirect_contains_reg(Op1,Reg),
    op_immediate(Op2,N),
    op_regdirect_contains_reg(DstOp,DstReg).

// ADD Reg1, Reg2, N, M
reg_reg_arithmetic_operation(EA,DstReg,Reg,"NONE",1,Val):-
    instruction(EA,_,_,"ADD",Op1,Op2,Op3,DstOp,_,_),
    op_regdirect_contains_reg(Op1,Reg),
    op_immediate(Op2,N),
    op_immediate(Op3,M),
    op_regdirect_contains_reg(DstOp,DstReg),
    N >= 0,
    // N right-rotate M
    Val = (N bshr M) bor (N bshl (32-M)).

reg_reg_arithmetic_operation(EA,Reg_def,Reg2,Reg1,1,0):-
    reg_reg_arithmetic_operation(EA,Reg_def,Reg1,Reg2,1,0).

.decl main_function(Main_location:address,Main_dispatch:address)
main_function(Main_location,Main_dispatch):-
    def_used(EA_def,"R0",Main_dispatch,_),
    value_reg(EA_def,"R0",_,"NONE",_,Offset,_),
    Main_location = as(Offset, address),
    code(Main_location).

// Inform the use_def analysis that R0 is used here as an address.
used(Main_dispatch,Reg,0),used_for_address(Main_dispatch,Reg):-
    Reg = "R0",
    main_function_dispatch(Main_dispatch).

}
