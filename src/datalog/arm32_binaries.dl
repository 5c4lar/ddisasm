//===- arm32_binaries.dl ------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019-2022 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to abstract from ARM32 specific instruction set
and characteristics
*/

// doubleword operations require an even,odd pair of registers, e.g., r2,r3
// Rt2 isn't really encoded in the instruction, it's derived from Rt, so we
// just need to ensure Rt is even.
invalid(EA,"arm: doubleword op Rt is odd"):-
    arch.memory_access(_,EA,_,_,Rt,_,_,_,Offset), // memory access for Rt
    arch.memory_access(_,EA,_,_,_,_,_,_,Offset2), // memory access for Rt2
    Offset < Offset2,
    instruction_get_operation(EA,Operation),
    OperationRoot = substr(Operation,0,4),
    (
        OperationRoot = "LDRD";
        OperationRoot = "STRD"
    ),
    (EA band 1) = 0, // ARM mode only
    (
        // If Rt is odd, the instruction is invalid.
        arch.reg_index(Rt,Index),
        (Index band 1) = 1
        ;
        // If Rt is LR, the instruction is invalid.
        Rt = "LR"
    ).

// For T32 instructions, you must not specify SP or PC for either Rt or Rt2.
// LDRD Rt, Rt2, [Rn]
// LDRD Rt, Rt2, [Rn], #offset
invalid(EA,"thumb: doubleword op registers invalid"):-
    arch.memory_access(_,EA,_,_,Rt,_,_,_,_),
    (EA band 1) = 1, // Thumb mode only
    instruction_get_operation(EA,Operation),
    substr(Operation,0,4) = "LDRD",
    (
        Rt = "SP";
        Rt = "PC"
    ).

// Applies to all of STR,LDR,STRD,LDRD
invalid(EA,"arm: pre/post-index disallows Rt[2] eq Rn"):-
    // For LDRD operations, there will be an arch.memory_access for each of Rt
    // and Rt2, so this rule will check both for conflict with Rn.
    arch.memory_access(_,EA,_,_,Rt,Rn,_,_,_),
    instruction_writeback(EA),
    Rt = Rn.

// Rm must be different from Rt and Rt2 in LDRD instructions.
// LDRD{cond} Rt, Rt2, [Rn], ±Rm
// LDRD{cond} Rt, Rt2, [Rn, ±Rm]
// LDRD{cond} Rt, Rt2, [Rn, ±Rm]!
invalid(EA,"arm: doubleword rm/rt conflict"):-
    (
        arch.memory_access(_,EA,_,_,Rt,_,Rm,_,_), Rm != "NONE";
        // Post-index form: Rm is not part of the memory access, since it is
        // only incremented afterward.
        arch.memory_access(_,EA,_,_,Rt,Rn,"NONE",_,_),
        arch.reg_reg_arithmetic_operation(EA,Rn,Rn,Rm,_,0)
    ),
    (EA band 1) = 0, // ARM mode only
    instruction_get_operation(EA,Operation),
    substr(Operation,0,4) = "LDRD",
    // For LDRD operations, there will be an arch.memory_access for each of Rt
    // and Rt2, so this rule will check both for conflict with Rm.
    Rt = Rm.

invalid(EA,"arm: pc is not allowed as dest"):-
    instruction_get_operation(EA,Operation),
    (
        contains("AND",Operation);
        contains("BIC",Operation);
        contains("MOVT",Operation);
        contains("MOVW",Operation)
    ),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA,"arm: pc is not allowed as src"):-
    instruction_get_operation(EA,Operation),
    (
        // ldm pc, {...}
        contains("LDM",Operation)
        ;
        // mov sp, pc
        contains("MOV",Operation),
        instruction_get_dest_op(EA,_,DestOp),
        op_regdirect_contains_reg(DestOp,SP),
        arch.stack_pointer(SP)
    ),
    instruction_get_src_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA,"arm: sp is not allowed in AND"):-
    instruction_get_operation(EA,Operation),
    substr(Operation,0,3) = "AND",
    instruction_get_src_op(EA,_,Op),
    op_regdirect_contains_reg(Op,SP),
    arch.stack_pointer(SP).

invalid(EA,"arm: deprecated bx"):-
    instruction_get_operation(EA,"BX"),
    instruction_get_op(EA,1,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.stack_pointer(Reg).

invalid(EA,"arm: pc cannot be used as index register"):-
    instruction_get_op(EA,_,Op),
    op_indirect_mapped(Op,_,_,PC,_,_,_),
    arch.pc_reg(PC).

invalid(EA,"arm: invalid mul operand (pc)"):-
    instruction_get_operation(EA,Operation),
    contains("MUL",Operation),
    instruction_get_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.pc_reg(Reg).

invalid(EA,"arm: deprecated bx"):-
    instruction_get_operation(EA,"BX"),
    instruction_get_op(EA,1,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.stack_pointer(Reg).

// The following instructions do not allow PC as the destination register.
invalid(EA,"arm: invalid pc"):-
    instruction_get_operation(EA,Operation),
    (
        Operation = "MLAHS";
        Operation = "MLASHS";
        Operation = "LDRSHEQ";
        Operation = "LDRSHTEQ";
        Operation = "LDRSHTLO";
        Operation = "LDRSHTVC";
        Operation = "LDRBEQ";
        Operation = "LDRSBEQ";
        Operation = "LDRHHS";
        Operation = "LDRHTHS";
        Operation = "LDRSBHS";
        Operation = "LDRSHHS";
        Operation = "LDRSBTHS";
        Operation = "LDRSHTHS";
        contains("LDRSB",Operation);
        contains("LDRBVC",Operation);
        contains("LDRBLO",Operation)
    ),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA,"arm: invalid arithmetic instruction with suffix s"):-
    instruction_get_operation(EA,Operation),
    strlen(Operation) >= 4,
    substr(Operation,0,3) = OP,
    (
        OP = "ADD"; OP = "SUB"; OP = "RSB";
        OP = "ADC"; OP = "SBC"; OP = "RSC"
    ),
    substr(Operation,3,1) = "S",
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA, "arm: invalid stm/ldm"):-
    instruction(EA,_,_,Operation,RegListOp,RegOp,0,_,_,_),
    BaseOperation = substr(Operation,0,3),
    (
         BaseOperation = "STM";
         BaseOperation = "LDM"
    ),
    instruction_writeback(EA),
    op_regdirect_contains_reg(RegOp,Reg),
    op_regdirect_contains_reg(RegListOp,Reg),
    (
        // Reg is not the lowest-indexed register in the reglist.
        op_regdirect_contains_reg(RegListOp,Reg2),
        arch.reg_index(Reg,RegIdx),
        arch.reg_index(Reg2,Reg2Idx),
        Reg2Idx < RegIdx
        ;
        // Reg is not allowed in the reglist in 32-bit Thumb instructions
        EA band 1 = 1, Size = 4
        ;
        // Reg is not allowed in the reglist in LDM instructions (all modes)
        BaseOperation = "LDM"
    ).


// PC-relative LDR
value_reg(EA,Reg,EA,"NONE",0,Val,1):-
    litpool_ref(EA,Reg,LitPoolAddr,Size,"LDR",_),
    track_register(Reg),
    !relocation(LitPoolAddr,_,_,_,_,_,_),
    data_word(LitPoolAddr,Size,Val).

/**
Jump to the PC register: "bx pc"
*/
direct_jump(EA,Dest):-
    arch.jump(EA),
    instruction_get_operation(EA,Operation),
    arch.jump_operation_op_index(Operation,TargetOpIndex),
    instruction_get_op(EA,TargetOpIndex,TargetOp),
    op_regdirect_contains_reg(TargetOp,Reg),
    arch.pc_reg(Reg),
    arch.pc_relative_disp(EA,Disp),
    Dest0 = EA + as(Disp,address),
    Dest = Dest0 - (Dest0 band 1).

/**
adr r1, Label
add r, r1, r2, lsl #4
mov pc, r   or  bx r

In the above pattern, Label is supposed to be code rather than data
(literal pools).
Therefore, it should not be treated as litpool_ref, whose target is data.
This predicate is used for excluding such case from litpool_ref.
Also, the target should not be aligned.
*/
.decl pc_relative_for_jump_table(EA:address)
.output pc_relative_for_jump_table

pc_relative_for_jump_table(EA_adr):-
    op_shifted(EA_add,3,4,"LSL"),
    substr(AddOperation,0,3) = "ADD",
    instruction_get_operation(EA_add,AddOperation),
    straight_line_def_used(EA_add,Reg,EA_jump,_),
    arch.jump(EA_jump),
    instruction_get_operation(EA_jump,Operation),
    !arch.load_word_operation(Operation),
    arch.jump_operation_op_index(Operation,Index),
    instruction_get_op(EA_jump,Index,DestOp),
    op_regdirect_contains_reg(DestOp,Reg),
    straight_line_def_used(EA_adr,Reg1,EA_add,_),
    arch.pc_relative_addr(EA_adr,Reg1,_).

.decl pc_relative_for_code(EA:address)
.output pc_relative_for_code

pc_relative_for_code(EA):-
    pc_relative_for_jump_table(EA).

pc_relative_for_code(EA):-
    arch.pc_relative_addr(EA,_,Dest),
    function_symbol(as(Dest,address),_).

avoid_symbols("$t").
avoid_symbols("$a").

direct_call(EA,Dest):-
    arch.call(EA,Index),
    instruction_get_op(EA,Index,Op),
    op_immediate(Op,Dest0),
    !instruction_has_relocation(EA,_),
    instruction_get_operation(EA,Operation),
    (
        contains("X",Operation),
        (
            (EA band 1) = 0, Dest = as(Dest0+1,address);
            (EA band 1) = 1, Dest = as(Dest0,address)
        )
        ;
        !contains("X",Operation),
        Dest = as(Dest0,address)
    ).

direct_call(EA,Dest):-
    arch.call(EA,_),
    instruction_immediate_offset(EA,_,_,_),
    instruction_has_relocation(EA,Rel),
    relocation(Rel,_,_,_,SymbolIndex,_,_),
    defined_symbol(Dest0,_,_,_,_,_,_,SymbolIndex,_),
    instruction_get_operation(EA,Operation),
    (
        contains("X",Operation),
        (
            (EA band 1) = 0, Dest = as(Dest0+1,address);
            (EA band 1) = 1, Dest = as(Dest0-1,address)
        )
        ;
        !contains("X",Operation),
        Dest = as(Dest0,address)
    ).

basic_target(Val+1):-
    defined_symbol(Val,_,_,_,_,_,_,_,"$t").
basic_target(Val):-
    defined_symbol(Val,_,_,_,_,_,_,_,Name),
    Name != "$t",
    Name != "$d".

labeled_data_candidate(EA):-
    symbol(EA,_,Type,_,_,_,_,_,Name),
    Name != "$t",
    Name != "$a",
    Type != "FUNC".

labeled_ea(EA+1):-
    defined_symbol(EA,_,Type,_,_,_,_,_,"$t"),
    Type != "SECTION",
    EA != 0.

labeled_ea(EA):-
    defined_symbol(EA,_,Type,_,_,_,_,_,Name),
    Type != "SECTION",
    Name != "$t",
    Name != "$d",
    EA != 0.

/**
E.g.,
  add ip, pc, #0, #12
  add ip, ip, #16, #20
  ldr pc, [ip, #2640]
*/
plt_entry(EA,Function):-
    plt_entry_arm_candidate(_,EA,Function,_).

block_points(EA_entry,"code",0,7,"arm: plt-block"):-
    plt_entry_arm_candidate(EA_entry,_,_,_).

/**
E.g.,
  bx pc // thumb
  b.n XXX or nop // thumb
  add ip, pc, #0, #12
  add ip, ip, #16, #20
  ldr pc, [ip, #2640]
*/
block_points(EA-3,"code",0,7,"arm: plt-block: bx pc"),
plt_block(EA-3,Function):-
    plt_entry_arm_candidate(EA,_,Function,_),
    instruction_get_operation(EA-3,Operation2), // thumb
    arch.jump_operation_op_index(Operation2,TargetOpIndex),
    instruction_get_op(EA-3,TargetOpIndex,TargetOp),
    op_regdirect_contains_reg(TargetOp,PC),
    arch.pc_reg(PC).

/**
plt_entry_arm_candidate

EA_entry: The address of the PLT entry
EA_jump:  The address of the last jump instruction in the PLT entry
Function: The external function that the PLT entry forwards
EA_reloc: The destination address of the PLT entry
*/
.decl plt_entry_arm_candidate(EA_entry:address, EA_jump:address, Function:symbol, EA_reloc:address)
.output plt_entry_arm_candidate

/**
E.g.,
  add ip, pc, #0, #12
  add ip, ip, #16, #20   or   add ip, ip, #N
  ldr pc, [ip, #2640]
*/
plt_entry_arm_candidate(EA,EA_jump,Function,as(Dest,address)):-
    plt_section(SecName),
    loaded_section(Beg,End,SecName),
    EA >= Beg,
    EA < End,

    arch.pc_reg(PC),

    // add ip, pc, #0, #12
    arch.reg_arithmetic_operation(EA,Reg,PC,1,N1),
    next(EA, NextEA),

    // add ip, ip, #16, #20
    // or
    // add ip, ip, #XXXX
    arch.reg_arithmetic_operation(NextEA,Reg,Reg,1,N2),
    next(NextEA, EA_jump),

    // ldr pc, [ip, #N]
    instruction_get_operation(EA_jump,Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(EA_jump,_,OffsetOp),
    op_indirect_mapped(OffsetOp,"NONE",Reg,"NONE",_,Offset,_),
    instruction_get_dest_op(EA_jump,_,RegOp),
    op_regdirect_contains_reg(RegOp,PC),

    Dest = as(EA,number) + N1 + N2 + Offset + 8,
    relocation(as(Dest,address),_,Function,_,_,_,_).

/**
E.g.,
  movw ip, #N1
  movt ip, #N2
  add ip, pc
  ldr.w pc, [ip, #Offset]
*/
plt_entry_arm_candidate(EA,EA_jump,Function,as(Dest,address)):-
    plt_section(SecName),
    loaded_section(Beg,End,SecName),
    EA >= Beg,
    EA < End,

    arch.pc_reg(PC),

    movw_movt_pair(EA,EA_movt,Value),

    // add ip, pc
    next(EA_movt, EA_add),
    arch.reg_reg_arithmetic_operation(EA_add,Reg,PC,Reg,1,0),

    // ldr.w pc, [ip, #Offset]
    next(EA_add, EA_jump),
    instruction_get_operation(EA_jump,Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(EA_jump,_,OffsetOp),
    op_indirect_mapped(OffsetOp,"NONE",Reg,"NONE",_,Offset,_),
    instruction_get_dest_op(EA_jump,_,RegOp),
    op_regdirect_contains_reg(RegOp,PC),

    // What about Offset? It seems irrelevant.
    Offset = Offset,
    Dest = as(EA_add,number) - 1 + Value,
    relocation(as(Dest,address),_,Function,_,_,_,_).

block_points(Block,"code",0,10,"arm: THM_CALL relocation"):-
    binary_type("REL"),
    block_is_overlapping(Block,"code"),
    code_in_block_candidate_refined(EA,Block),
    arch.call(EA,_),
    AlignedEA = EA - (EA band 1),
    relocation(AlignedEA,"THM_CALL",_,_,_,_,_).

block_points(Block,"code",0,1,"arm: plt call"):-
    plt_entry_arm_candidate(BlockDest,_,_,_),
    direct_call(EA,BlockDest),
    code_in_block_candidate_refined(EA,Block),
    block_is_overlapping(Block,"code").

/**
E.g., EA_movw: movw reg, N
      EA_movt: movt reg, M
   => reg's Value = N | (M << 16)
*/
.decl movw_movt_pair(EA_movw:address,EA_movt:address,Value:number)
.output movw_movt_pair

movw_movt_pair(EA_movw,EA_movt,Value):-
    instruction_get_operation(EA_movw,"MOVW"),
    // Given a movw, try to find the corresponding movt up to 3 instructions.
    (
        next(EA_movw,EA_movt)
        ;
        next(EA_movw,EA_temp),
        next(EA_temp,EA_movt)
        ;
        next(EA_movw,EA_temp1),
        next(EA_temp1,EA_temp2),
        next(EA_temp2,EA_movt)
    ),
    instruction_get_operation(EA_movt,"MOVT"),
    instruction_get_op(EA_movt,2,RegOp2),
    op_regdirect_contains_reg(RegOp2,Reg),
    instruction_get_op(EA_movw,2,RegOp),
    op_regdirect_contains_reg(RegOp,Reg),
    // Compute the value
    instruction_get_op(EA_movw,1,Op),
    op_immediate(Op,Low),
    instruction_get_op(EA_movt,1,Op2),
    op_immediate(Op2,High),
    Value = (High*2^16) bor Low.

symbolic_operand_attribute(EA_lo,1,"Part0"),
symbolic_operand_candidate(EA_lo,1,Dest,Type),
symbolic_operand_attribute(EA_hi,1,"Part1"),
symbolic_operand_candidate(EA_hi,1,Dest,Type):-
    movw_movt_pair(EA_lo,EA_hi,Value),
    Dest = as(Value,address),
    (
        code(Dest), Type="code"
        ;
        !litpool_ref(_,_,Dest,_,_,_),
        data_segment(Begin,End),
        Dest >= Begin, Dest <= End,
        Type = "data"
    ).

symbolic_operand_point(EA,Imm_index,-1,"unlikely to have symbolic operand"):-
    symbolic_operand_candidate(EA,Imm_index,_,_),
    instruction_get_operation(EA,Operation),
    (
        arch.cmp_operation(Operation)
        ;
        arch.logic_operation(Operation)
    ).

/**
E.g., vim
0:   pop { r2, lr }
4:   adr r1, L
There is an overlapping block at 0x2 that happens to be a valid 2-byte Thumb
instruction 'ldr'.

If there is no block before the address 0x0, the following rule does not hold
for both the block at 0x0 and the one at 0x2:

  // Prefer blocks that have a well-defined boundary with a prior block.
  block_points(Block,"code",0,1,"better fit")

To break such tie, give one point to the outer block.

Block: the outer block
Block2: the enclosed block
*/
block_points(Block,"code",0,1,"arm: enclosing thumb instruction"):-
    block_overlap(Block,"code",Block2,"code"),
    (Block band 1) = 1, // Thumb mode only
    Block2 = Block + 2,
    instruction(Block,4,_,_,_,_,_,_,_,_),
    instruction(Block2,2,_,_,_,_,_,_,_,_),
    block_candidate_boundaries(Block,"code",Beg,_),
    block_candidate_boundaries(Block2,"code",Beg2,_),
    !block_candidate_boundaries(_,"code",_,Beg),
    !block_candidate_boundaries(_,"code",_,Beg2).

/**
Similarly to the above rule, if the enclosed Thumb instruction does not have
any predecessor and the outer instruction has one, give penalty to the dangling
Thumb block.
*/
block_points(Block,"code",0,-1,"arm: dangling thumb instruction"):-
    block_is_overlapping(Block,"code"),
    (Block band 1) = 1, // Thumb mode only
    arch.dangling_thumb_instr(Block).

/**
It was observed that a valid ARM mode block often overlaps with a bad, small
Thumb block consisting of ADDS/SUBS/ASRS and B instrutions.
*/
block_points(Block,"code",0,-1,"arm: possibly invalid thumb block"):-
    block_is_overlapping(Block,"code"),
    (Block band 1) = 1, // Thumb mode only
    instruction(Block,2,_,Operation,_,_,_,_,_,_),
    (Operation = "ADDS"; Operation = "SUBS"; Operation = "ASRS"),
    next(Block,EANext),
    instruction(EANext,_,_,"B",_,_,_,_,_,_),
    code_in_block_candidate_refined(Block-(Block band 3),_).

/**
In case of movw/movt pair, which is basically a bitwise OR of two immediates,
the destination address needs to be properly set.
*/
may_have_symbolic_immediate(Src,Dest):-
     binary_type("EXEC"),
     (
         instruction_get_operation(Src,Operation),
         !arch.logic_operation(Operation),
         Operation != "MOVW",
         Operation != "MOVT",
         instruction_immediate_offset(Src,Index,_,_),
         instruction_get_op(Src,Index,Op),
         op_immediate(Op,Imm),
         Dest = as(Imm,address)
         ;
         movw_movt_pair(Src,_,Value),
         Dest = as(Value,address)
     ).

/**
ldr Reg1, .L0
add Reg2, Reg1, pc

Uses 'straight_line_def_used', which is a weaker version of 'def_used' that can
be used before code inference.
*/
.decl init_ldr_add_pc(EA_ldr:address,Size:unsigned,Reg1:register,LitPoolAddr:address,EA_add_pc:address,Reg2:register)

init_ldr_add_pc(EA_ldr,Size,Reg1,LitPoolAddr,EA_add_pc,Reg2):-
    litpool_ref(EA_ldr,Reg1,LitPoolAddr,Size,_,_),
    straight_line_def_used(EA_ldr,Reg1,EA_add_pc,_),
    arch.reg_reg_arithmetic_operation(EA_add_pc,Reg2,Reg1,PC,1,0),
    arch.pc_reg(PC).

/**
ldr Reg1, .L0
add add Reg2, Reg1, pc

Uses def_used
*/
.decl cinf_ldr_add_pc(EA_ldr:address,Size:unsigned,Reg1:register,LitPoolAddr:address,EA_add_pc:address,Reg2:register)

cinf_ldr_add_pc(EA_ldr,Size,Reg1,LitPoolAddr,EA_add_pc,Reg2):-
    litpool_ref(EA_ldr,Reg1,LitPoolAddr,Size,_,_),
    def_used(EA_ldr,Reg1,EA_add_pc,_),
    arch.reg_reg_arithmetic_operation(EA_add_pc,Reg2,Reg1,PC,1,0),
    arch.pc_reg(PC).

.decl symbol_minus_symbol_candidate_arm(EA:address,Size:unsigned,Symbol1:address,Symbol2:address,Scale:unsigned,Offset:number)
.output symbol_minus_symbol_candidate_arm

/**
case 1:
PIC code uses inlined pc-relative offsets,

    ldr REG, .L0
    .LPIC0:
       add REG, pc
       ...
    .L0:
       .word foo-(.LPIC0+Disp)

    (Disp=4 for Thumb mode, 8 for ARM mode)

where the symbol foo is the target symbol, and .L0 will contain the offset
from PC at .LPIC0 to the symbol foo.

case 2:
    .L0:
       .long foo(GOT)
where foo is a symbol relocated by GOT.
*/
symbol_minus_symbol_candidate_arm(Addr,Size,EA_add_pc,Dest,Scale,Offset):-
    cinf_ldr_add_pc(_,Size,Reg,Addr,EA_add_pc,Reg),
    arch.pc_relative_disp(EA_add_pc,Disp),
    data_word(Addr,Size,Diff),
    Mode = EA_add_pc band 1,
    Offset = -1 * Disp,
    (
        Dest = EA_add_pc + as(Disp + Diff,address) - Mode,
        !relocation(Addr,_,_,_,_,_,_)
        ;
        relocation(Addr,"REL32",Symbol,_,SymbolIndex,_,"REL"),
        symbol(Base,_,_,_,_,_,_,SymbolIndex,Symbol),
        // ((S + A) | T) - P
        S = as(Base,unsigned),
        A = as(Diff,unsigned),
        P = as(Addr,unsigned),
        T = as(Base band 1,unsigned),
        Value = ((S + A) bor T) - P,
        Dest = (EA_add_pc + as(Disp,address) - Mode) + as(Value,address)
    ),
    Scale = 1.

symbol_minus_symbol_candidate(Addr,Size,EA_add_pc,Dest,Scale,Offset):-
    symbol_minus_symbol_candidate_arm(Addr,Size,EA_add_pc,Dest,Scale,Offset).

// TODO: Ideally, we want to rename symbol_minus_symbol_candidate_arm to the
// common rule 'symbol_minus_symbol_candidate', and use it here.
// However, it causes a stratification problem. See
// https://git.grammatech.com/rewriting/ddisasm/-/issues/392 for more details.
labeled_data_candidate(Dest):-
    symbol_minus_symbol_candidate_arm(_,_,_,Dest,_,_),
    data_segment(Begin,End),
    Dest >= Begin, Dest <= End.

symbol_minus_symbol_from_relocation(EA,4,SymbolName2,"_GLOBAL_OFFSET_TABLE_",1,Offset):-
    binary_type("REL"),
    relocation(EA,"BASE_PREL","_GLOBAL_OFFSET_TABLE_",_,_,_,_),
    symbol_minus_symbol_litpool_access_pattern(_,4,_,EA,1,_,Symbol2,_,Type),
    (
        Type = "LDR", Offset = -4
        ;
        Type = "AddPC", Offset = 0
    ),
    best_symexpr_symbol(Symbol2,SymbolName2,"Beg").

/**
Represents the first entry of an ARM jump table.

Attributes:

* EA_jump: address of jump instruction
* TableStart: address of first table entry
* EntryAddr: address of table entry
* EntrySize: size of entries
* TargetAddr: resolved target of the jump
* TableLimit: first address that cannot be part of the jump table
* Type: absolute or relative
*/
.decl arm_jump_table_candidate_start(EA_jump:address,TableStart:address,EntryAddr:address,EntrySize:unsigned,TargetAddr:address,TableLimit:address,Type:symbol,Scale:unsigned,Offset:number)

/**
Represents an entry in an ARM jump table.

Attributes:

* EA_jump: address of jump instruction
* TableStart: address of first table entry
* EntryAddr: address of table entry
* EntrySize: size of entries
* TargetAddr: resolved target of the jump
* TableLimit: first address that cannot be part of the jump table
* Type: absolute or relative
*/
.decl arm_jump_table_candidate(EA_jump:address,TableStart:address,EntryAddr:address,EntrySize:unsigned,TargetAddr:address,TableLimit:address,Type:symbol,Scale:unsigned,Offset:number)

.output arm_jump_table_candidate

/**
Jump-table pattern
  [1] ldr pc, [pc, r2, lsl N]
or
  [2] adr r1, Label
      ldr pc, [r1, r2, lsl N]
or
  [3] adr r1, Label
      ldr r0, [r1, r2, lsl N]
      mov pc, r0
*/
arm_jump_table_candidate(EA_jump,TableStart,TableStart,Size,TargetAddr,TableLimit,"absolute",1,0):-
    arch.load_word_operation(Operation),
    instruction(EA_ldr,InstrSize,_,Operation,IndOp,RegOp,0,0,_,_),
    // TODO: Currently, 'lsl N' is not propagated from the decoder.
    op_regdirect_contains_reg(RegOp,Rd),
    arch.pc_reg(PC),
    op_indirect_mapped(IndOp,"NONE",BaseReg,_,_,0,NBits),
    Size = NBits / 8,
    arch.pointer_size(Size),
    (
        // [1] ldr pc, [pc, r2, lsl N]
        Rd = PC,
        BaseReg = PC,
        (
            arch.conditional_operation(Operation,_),
            // If it's conditional, it is likely that there is a fall-through
            // successor consisting of one instruction (typically a jump
            // instruction)
            // Check the fall-through instruction is a jump to make sure.
            next(EA_ldr,EA_fallthrough),
            arch.jump(EA_fallthrough),
            instruction(EA_fallthrough,InstrSize2,_,_,_,_,_,_,_,_),
            TableStart0 = EA_ldr + as(InstrSize + InstrSize2,address)
            ;
            !arch.conditional_operation(Operation,_),
            TableStart0 = EA_ldr + as(InstrSize,address)
        ),
        EA_jump = EA_ldr
        ;
        Rd = PC,
        // [2] adr r1, Label   or  add r1, pc, offset
        //     ldr pc, [r1, r2, lsl N]
        straight_line_def_used(EA_adr,BaseReg,EA_ldr,_),
        arch.pc_relative_addr(EA_adr,BaseReg,Val),
        TableStart0 = as(Val,address),
        EA_jump = EA_ldr
        ;
        // [3] adr r1, Label   or  add r1, pc, offset
        //     ldr r0, [r1, r2, lsl N]
        //     mov pc, r0
        straight_line_def_used(EA_adr,BaseReg,EA_ldr,_),
        arch.pc_relative_addr(EA_adr,BaseReg,Val),
        TableStart0 = as(Val,address),
        straight_line_def_used(EA_ldr,Rd,EA_mov,_),
        arch.move_reg_reg(EA_mov,PC,Rd),
        EA_jump = EA_mov
    ),

    // Tables are aligned.
    TableStart = TableStart0 - (TableStart0 band 3),

    address_in_data(TableStart,TargetAddr),
    (
        // Jump to after the jumptable - sets a hard limit on the jumptable size.
        TargetAddr > TableStart, TableLimit = TargetAddr;
        // Jump to before the jumptable - does not restrict jumptable size.
        TargetAddr <= TableStart, TableLimit = (2 ^ NBits) - 1
    ),
    code_in_block_candidate(TargetAddr,_).

/**
Compute the target address for the given relative jump-table entry.

EA: An entry of a relative jump-table
TableStart: The starting address of the jump-table
Size: The size of the entry
Scale: The scale amount is multiplied to the entry value
AlignedTargetAddr: The computed tgarget address is aligned
*/
.decl arm_relative_jump_table_target(EA:address,TableStart:address,Size:unsigned,Scale:unsigned,AlignedTargetAddr:address) inline
arm_relative_jump_table_target(EA,TableStart,Size,Scale,AlignedTargetAddr):-
    (
        Size != 1, data_word(EA,Size,DiffUnsigned);
        Size = 1, data_byte(EA,DiffUnsigned)
    ),
    DiffUnsigned != 0, // A table with odd number of entries is padded with 0
    Diff = as(DiffUnsigned,number),
    TargetAddr = as(Diff*as(Scale,number)+as(TableStart,number),address),
    AlignedTargetAddr = TargetAddr - (TargetAddr band 1).

arm_jump_table_candidate_start(EA,TableStart,TableStart,Size,TargetAddr,TableLimit,"relative",2,0):-
    (
        Operation="TBH", Size = 2;
        Operation="TBB", Size = 1
    ),
    instruction(EA,InstrSize,_,Operation,Operand,0,0,0,_,_),
    EA band 1 = 1, // assert: tbb/tbh instruction only exist in Thumb.
    arch.pc_reg(PC),
    op_indirect_mapped(Operand,"NONE",PC,_,_,_,_),
    TableStart = as(EA+InstrSize-1,address),

    // tbb/tbh can't perform a mode switch and just uses aligned addresses of
    // Thumb targets.
    arm_relative_jump_table_target(TableStart,TableStart,Size,2,AlignedTargetAddr),
    TargetAddr = AlignedTargetAddr + 1,
    (
        // Jump to after the jumptable - sets a hard limit on the jumptable size.
        AlignedTargetAddr > TableStart, TableLimit = AlignedTargetAddr;
        // Jump to before the jumptable - does not restrict jumptable size.
        AlignedTargetAddr <= TableStart, arch.pointer_size(PtrSize), TableLimit = (2 ^ ((8*PtrSize)-1)) - 1
    ).

/**
EA:      adr r1, OffsetToTableStart    or   add r1, pc, #10
EA_ldr:  ldr r3, [r1,r2,lsl N]
EA_add   add r4, r3    or   add r4, r4, r3
EA_jump: bx r4
*/
arm_jump_table_candidate_start(EA_jump,TableStart,TableStart,Size,TargetAddr,TableLimit,"relative",1,as(EA_jump band 1,number)):-
    arch.pc_relative_addr(EA,_,Val),
    TableStart0 = as(Val,address),
    next(EA,EA_ldr),
    instruction_get_operation(EA_ldr,"LDR"),
    next(EA_ldr,EA_add),
    arch.reg_reg_arithmetic_operation(EA_add,R4,R4,R3,1,0),
    next(EA_add,EA_jump),
    instruction_get_operation(EA_jump,Operation),
    substr(Operation,0,2) = "BX",

    arch.jump_operation_op_index(Operation,TargetOpIndex),
    instruction_get_op(EA_jump,TargetOpIndex,Reg4Op),
    op_regdirect_contains_reg(Reg4Op,R4),

    instruction_get_dest_op(EA_ldr,_,Reg3Op),
    op_regdirect_contains_reg(Reg3Op,R3),
    instruction_get_src_op(EA_ldr,_,IndOp),
    op_indirect_mapped(IndOp,"NONE",R1,_,Mult,0,NBits),
    instruction_get_dest_op(EA,_,Reg1Op),
    op_regdirect_contains_reg(Reg1Op,R1),

    // TODO: Check on Mult=2?
    Mult = Mult, // to avoid warnings
    Size = NBits / 8,
    arch.pointer_size(Size),

    // Tables are aligned.
    TableStart = TableStart0 - (TableStart0 band 3),

    arm_relative_jump_table_target(TableStart,TableStart,Size,1,AlignedTargetAddr),
    TargetAddr = AlignedTargetAddr + (EA_jump band 1),
    (
        // Jump to after the jumptable - sets a hard limit on the jumptable size.
        AlignedTargetAddr > TableStart, TableLimit = AlignedTargetAddr;
        // Jump to before the jumptable - does not restrict jumptable size.
        AlignedTargetAddr <= TableStart, arch.pointer_size(PtrSize), TableLimit = (2 ^ ((8*PtrSize)-1)) - (EA_jump band 1)
    ).

// base case
arm_jump_table_candidate(EA_jump,TableStart,EA,Size,TargetAddr,NewTableLimit,Type,Scale,Offset):-
    arm_jump_table_candidate_start(EA_jump,TableStart,EA,Size,TargetAddr,NewTableLimit,Type,Scale,Offset),
    // We check this here so `arm_jump_table_candidate_start` is not recursive
    // and `arm_jump_table_candidate_start` is not recomputed for every new `code_in_block_candidate`.
    code_in_block_candidate(TargetAddr,_).

// recursive case
arm_jump_table_candidate(EA_jump,TableStart,EA+Size,Size,TargetAddr,NewTableLimit,Type,Scale,Offset):-
    arm_jump_table_candidate(EA_jump,TableStart,EA,Size,_,TableLimit,Type,Scale,Offset),
    (
        Type = "absolute",
        address_in_data(EA+Size,TargetAddr),
        AlignedTargetAddr = TargetAddr - (TargetAddr band 1)
        ;
        Type = "relative",
        arm_relative_jump_table_target(EA+Size,TableStart,Size,Scale,AlignedTargetAddr),
        TargetAddr = AlignedTargetAddr + (EA_jump band 1)
    ),
    EA+Size < TableLimit,
    (
        // The target address is less than the limit, but at some address beyond
        // the current entry. Limit the table size to that target.
        AlignedTargetAddr < TableLimit, AlignedTargetAddr > EA+Size, NewTableLimit = AlignedTargetAddr
        ;
        // The target address points at or before the current jump table entry.
        // Gives us no info about the table size - keep propagating.
        AlignedTargetAddr < TableLimit, AlignedTargetAddr <= EA+Size, NewTableLimit = TableLimit
        ;
        // The target address points beyond our current limit - keep propagating.
        AlignedTargetAddr >= TableLimit, NewTableLimit = TableLimit
    ),
    !impossible_jump_target(TargetAddr),
    code_in_block_candidate(TargetAddr,_),
    // Target address cannot be within the table itself
    (
        TargetAddr < TableStart
        ;
        TargetAddr >= NewTableLimit
    ),
    // This entry is neither either a jump target or it is a target
    // of a jump that is likely spurious.
    Addr = EA+Size+(EA_jump band 1),
    (
        !direct_jump(_,Addr)
        ;
        // If there's a jump to this entry, check if the jump is spurious.
        direct_jump(EA_jump2,Addr),
        (
            (EA_jump2 band 1) != (EA_jump band 1)
            ;
            // There is no pred.
            !next(_,EA_jump2)
            ;
            // The jump is in a different section.
            loaded_section(Beg,End,_),
            Addr >= Beg,
            Addr < End,
            !(EA_jump2 >= Beg, EA_jump2 < End)
        )
    ).

// Aggregate arm_jump_table_candidate in one data block
data_block_candidate(TableStart,BlockSize):-
    arm_jump_table_candidate(EA_jump,TableStart,EA_last,Size,_,_,_,_,_),
    Addr = EA_last+(EA_jump band 1),
    !code_in_block_candidate(_,Addr),
    BlockSize = EA_last - TableStart + Size.

block_points(TableStart,"data",0,15,"arm: jump table"):-
    arm_jump_table_candidate(_,TableStart,_,_,_,_,_,_,_),
    data_block_candidate(TableStart,_),
    // If it's a defined symbol, the points are already given.
    !defined_symbol(TableStart,_,_,_,_,_,_,_,"$d").

block_points(TargetEA,"code",0,3,"arm: jump table target"):-
    arm_jump_table_candidate(_,_,_,_,TargetEA,_,_,_,_),
    block_is_overlapping(TargetEA,"code").

jump_table_candidate(EA,DataEA,TargetEA):-
    arm_jump_table_candidate(EA,_,DataEA,_,TargetEA,_,_,_,_).

data_object_point(DataEA,Size,"symbol",2,"arm jump-table3"),
data_object_candidate(DataEA,Size,"symbol"):-
    arm_jump_table_candidate(_,_,DataEA,Size,_,_,"absolute",_,_).

data_object_point(DataEA,Size,"symbol-symbol",2,"arm jump-table3"),
data_object_candidate(DataEA,Size,"symbol-symbol"):-
    arm_jump_table_candidate(_,_,DataEA,Size,_,_,"relative",_,_).

data_object_candidate(LitPoolAddr,Size,"symbol-symbol"):-
    symbol_minus_symbol_litpool_access_pattern(LitPoolAddr,Size,_,_,_,_,_,_,_).

data_object_point(EA,Size,"symbol",5,"arm literal pool"),
data_object_candidate(LitPoolAddr,Size,"symbol"):-
    litpool_ref(EA,_,LitPoolAddr,Size,"LDR",_),
    symbolic_operand_candidate(EA,_,LitPoolAddr,_),
    !symbol_minus_symbol_litpool_access_pattern(LitPoolAddr,_,_,_,_,_,_,_,_).

jump_table_start(EA,Size,TableStart,TableStart,1):-
    arm_jump_table_candidate(EA,TableStart,DataEA,Size,_,_,_,_,_),
    jump_table_candidate_refined(EA,DataEA,_).

relative_jump_table_entry_candidate(DataEA,TableStart,Size,TableStart,TargetAddr,as(Scale,number),Offset):-
    arm_jump_table_candidate(EA,TableStart,DataEA,Size,_,_,_,Scale,Offset),
    jump_table_candidate_refined(EA,DataEA,TargetAddr).

/**
Instruction at address `EA` accesses a literal pool located at `LitPoolAddr`

Type="LDR" : Reg gets the value at the LitPoolAddr
Type="AddPC" : Reg gets the address of the literal pool (LitPoolAddr)
*/
.decl litpool_ref(EA:address, Reg:register, LitPoolAddr:address, Size:unsigned, Type:symbol, OpIndex:operand_index)
.output litpool_ref

litpool_ref(EA,Reg,LitPoolAddr,Size,Type,OpIndex):-
    possible_ea(EA),
    (
        // LDR/VLDR <Register> <IndirectOp>
        // e.g., ldr r3, [pc, Offset]
        arch.load_operation(Operation),
        instruction_get_operation(EA,Operation),
        instruction_get_src_op(EA,_,OffsetOp),
        op_indirect_mapped(OffsetOp,"NONE",PC,"NONE",_,Offset,_),
        arch.pc_reg(PC),
        arch.pc_relative_disp(EA,Disp),
        // Align the address
        EA_aligned = EA - (EA band 3),
        Addr = EA_aligned + as(Offset,address) + as(Disp,address),
        LitPoolAddr = as(Addr,address),
        arch.data_access_size(Operation,Reg,Size),
        Type = "LDR",
        OpIndex = 1
        ;
        // ADR <Register> <Offset>  or  ADD/SUB <Register>, PC, <Offset>
        arch.pc_relative_addr(EA,_,Val),
        !pc_relative_for_code(EA),
        !function_symbol(as(Val,address),_),
        LitPoolAddr0 = as(Val,address),
        LitPoolAddr = LitPoolAddr0 - (LitPoolAddr0 band 3),
        Size = 4,
        Type = "AddPC",
        instruction_immediate_offset(EA,OpIndex,_,_)
    ),
    instruction_get_dest_op(EA,_,RegOp),
    op_regdirect_contains_reg(RegOp,Reg),
    !arch.pc_reg(Reg).

// VLDR: label must be aligned on a word boundary within -/+1KB of the
// current instruction.
alignment(LitPoolAddr,4):-
    litpool_ref(EA,_,LitPoolAddr,_,"LDR",_),
    instruction_get_operation(EA,"VLDR"),
    instruction_get_dest_op(EA,_,DestReg),
    op_regdirect_contains_reg(DestReg,Reg),
    // Only align the first literal pool for consecutive pools.
    // If Dest reg is S, one word; two words otherwise.
    arch.float_reg(Reg,Disp),
    (
        !litpool_ref(_,_,LitPoolAddr-Disp,_,"LDR",_)
        ;
        litpool_ref(EA0,_,LitPoolAddr-Disp,_,"LDR",_),
        !instruction_get_operation(EA0,"VLDR")
    ).

/**
EA is the address of the adr or ldr but the double is actually read
later in the next instruction (ldrd).

Type="LDR" : Reg1 and Reg2 get the values at the LitPoolAddr
Type="AddPC" : Reg1 and Reg2 get the values at the address pointed
             by the value at the LitPoolAddr
*/
.decl litpool_ref_double(EA:address, Reg1:register, Reg2:register, LitPoolAddr:address, Type:symbol)
.output litpool_ref_double

// E.g., add r, pc, Offset | adr r, L | ldr r, [pc, N]
//       ldrd r1, r2, [r]
litpool_ref_double(EA,Reg1,Reg2,LitPoolAddr,Type):-
    litpool_ref(EA,Reg,LitPoolAddr,_,Type,_),
    next(EA,EA_ldrd),
    // LDRD Reg1, Reg2, [Reg]
    instruction(EA_ldrd,_,_,"LDRD",Op1,IndOp,Op3,_,_,_),
    op_regdirect_contains_reg(Op3,Reg1),
    op_regdirect_contains_reg(Op1,Reg2),
    op_indirect_mapped(IndOp,"NONE",Reg,"NONE",_,0,_).

.decl litpool_ref_single(EA:address, Reg:register, LitPoolAddr:address, Size:unsigned, Type:symbol)

litpool_ref_single(EA,Reg,LitPoolAddr,Size,Type):-
    litpool_ref(EA,Reg,LitPoolAddr,Size,Type,_),
    !litpool_ref_double(EA,_,_,LitPoolAddr,_).

data_block_candidate(LitPoolAddr,Pt_size*2):-
    arch.pointer_size(Pt_size),
    litpool_ref_double(_,_,_,LitPoolAddr,"AddPC").

data_block_candidate(LitPoolAddr,Pt_size):-
    arch.pointer_size(Pt_size),
    litpool_ref(_,_,LitPoolAddr,_,"LDR",_).

/**
Check if the given block overlaps with a possible literal pool.
*/
.decl overlap_with_litpool(Block:address)

overlap_with_litpool(Block):-
    (
        block_overlap(Block,"code",Block2,"data")
        ;
        block_overlap(Block2,"data",Block,"code")
    ),
    litpool_ref(EA,_,Block2,_,_,_),
    code_in_block_candidate_refined(EA,Block3),
    !block_overlap(Block3,"code",_,"data"),
    !block_overlap(_,"data",Block3,"code").

/**
Confidence level for each literal pool
*/
.decl litpool_confidence(EARef:address, LitPoolAddr:address, Confidence:number, Reason:symbol)

.decl litpool_total_confidence(LitPoolAddr:address, Confidence:number)

litpool_total_confidence(LitPoolAddr,Total):-
    litpool_ref(_,_,LitPoolAddr,_,_,_),
    Total = sum X:{litpool_confidence(_,LitPoolAddr,X,_)}.

/**
There can be false positives of literal pools.
Give more points to the literal pool (data) and the ref block (code)
when it is more likely to be an actual literal pool.
*/
block_points(Block,"code",0,Confidence-2,cat("arm: litpool ref block: ",Reason)):-
    litpool_ref(EA,_,LitPoolAddr,_,_,_),
    code_in_block_candidate_refined(EA,Block),
    litpool_confidence(EA,LitPoolAddr,Confidence,Reason),
    Confidence > 2.

block_points(LitPoolAddr,"data",0,Confidence,cat("arm: litpool: ",Reason)):-
    litpool_confidence(_,LitPoolAddr,Confidence,Reason).

/**
ADR/LDM pair loads multiple data from literal pool.
Create data_block_candidate accordingly.
E.g.,
adr r2, .L_xxx
ldm r2, { r2, r3 }
.L_xxx: 8 byte data
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"adr/ldm"),
data_block_candidate(LitPoolAddr, RegCnt * Pt_size):-
    litpool_ref(EA,Reg,LitPoolAddr,_,"AddPC",_),
    straight_line_def_used(EA,Reg,EA_ldm,_),
    instruction_get_operation(EA_ldm,Operation),
    contains("LDM",Operation),
    instruction_get_dest_op(EA_ldm,_,RegBitFieldOp),
    op_register_bitfield(RegBitFieldOp,MaxIndex,_),
    !op_register_bitfield(RegBitFieldOp,MaxIndex+1,_),
    RegCnt = MaxIndex + 1,
    arch.pointer_size(Pt_size),
    Confidence = 5.

/**
Give more points in case of ldr/ldrd or adr/ldrd sequence, which is
high probablity.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"litpool_ref_double"):-
    litpool_ref_double(EA,_,_,LitPoolAddr,_),
    code_in_block_candidate_refined(EA,_),
    Confidence = 12.

/**
If the ref block is not overlapping, it is likely a true literal pool.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"ref by non-overlapping block"):-
    litpool_ref_single(EA,_,LitPoolAddr,_,_),
    code_in_block_candidate_refined(EA,Block),
    !block_is_overlapping(Block,"code"),
    Confidence = 12.

/**
Even if the ref block is overlapping, if the literal pool block is not
overlapping, give 1 point.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"not overlapping"),
block_points(Block,"code",0,Confidence,"arm: litpool ref block: not overlapping"):-
    litpool_ref_single(EA,_,LitPoolAddr,_,_),
    code_in_block_candidate_refined(EA,Block),
    block_is_overlapping(Block,"code"),
    !overlap_with_litpool(Block),
    !code_in_block_candidate(LitPoolAddr+(EA band 1),_),
    !block_is_overlapping(LitPoolAddr,_),
    Confidence = 1.

/**
Even if the ref block is overlapping, if the loaded register is used somewhere,
it is likely a literal pool.
NOTE: We can't use def_used here.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"loaded register used somewhere"),
block_points(Block,"code",0,Confidence-1,"arm: litpool ref block: loaded register used somewhere"):-
    litpool_ref_single(EA,Reg,LitPoolAddr,_,_),
    code_in_block_candidate_refined(EA,Block),
    block_is_overlapping(Block,"code"),
    !overlap_with_litpool(Block),
    straight_line_def_used(EA,Reg,_,_),
    Confidence = 2.

/**
Even if the ref block is overlapping and there is no known use of the loaded
register, if there's a call near in the same block, it is likely a literal
pool.
Note that the use of r may not be explicit when r is only used as an argument
of a function call.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"possibly register param"):-
    litpool_ref_single(EA,Reg,LitPoolAddr,_,_),
    code_in_block_candidate_refined(EA,Block),
    block_is_overlapping(Block,"code"),
    !overlap_with_litpool(Block),
    !straight_line_def_used(EA,_,_,_),
    code_in_block_candidate(CallEA,Block),
    arch.call(CallEA,_),
    arch.integer_reg_param(Reg,_),
    CallEA <= EA + 12,
    Confidence = 3.

/**
If there are multiple litpool references in a block, it is likely a real code.
*/
litpool_confidence(EA,LitPoolAddr,1,"multiple litpool refs in a block"),
block_points(Block,"code",0,1,"arm: multiple litpool refs in a block"):-
    litpool_ref(EA,_,LitPoolAddr,_,"LDR",_),
    code_in_block_candidate_refined(EA,Block),
    Count = count :{code_in_block_candidate_refined(EA2,Block), litpool_ref(EA2,Reg,_,_,_,_),straight_line_def_used(EA2,Reg,_,_)},
    Count > 3.

/**
Currently, floating-point registers are currently not tracked in
straight_line_def_used.
Even if the ref block is overlapping and there is no known use of the loaded
register, if the instruction appears to be a valid VLDR, it is likely a
literal.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"valid VLDR"):-
    litpool_ref_single(EA,Reg,LitPoolAddr,Size,Type), Type = "LDR",
    code_in_block_candidate_refined(EA,Block),
    block_is_overlapping(Block,"code"),
    !straight_line_def_used(EA,_,_,_),
    instruction_get_operation(EA,"VLDR"),
    arch.float_reg(Reg,Size),
    Confidence = 4.

litpool_confidence(EA,LitPoolAddr,9,"ldr_add_pc"):-
    init_ldr_add_pc(EA,_,_,LitPoolAddr,_,_).

/**
Even if the ref block is overlapping, if it contains a plausible instruction
sequence, it is likely a true literal pool.
*/
block_points(LitPoolAddr,"data",0,Confidence,"arm: litpool: ref by block containing plausible instr seq"):-
    litpool_ref_single(EA,_,LitPoolAddr,_,_),
    code_in_block_candidate_refined(EA,Block),
    block_is_overlapping(Block,"code"),
    !overlap_with_litpool(Block),
    Confidence = sum X:{contains_plausible_instr_seq(Block,X,_,_)},
    Confidence > 0.

/**
Literal pools are often placed together.
Check if there's another literal pool before or after this one.
*/
block_points(Block,"code",0,Points,"arm: litpool ref block: consecutive literal pools"),
block_points(LitPoolAddr,"data",0,Points,"arm: litpool: consecutive literal pools"):-
    litpool_ref_single(EA,_,LitPoolAddr,Size,"LDR"),
    code_in_block_candidate_refined(EA,Block),
    block_is_overlapping(Block,"code"),
    !overlap_with_litpool(Block),
    (Size2 = 4; Size2 = 8),
    (
        // There is a literal pool before this one.
        litpool_ref(_,_,LitPoolAddr-Size2,Size2,"LDR",_),
        litpool_total_confidence(LitPoolAddr-Size2,Confidence),
        Confidence > 1,
        (
            // There is no literal pool after this one.
            !litpool_ref(_,_,LitPoolAddr+Size,_,"LDR",_),
            Points = 1
            ;
            // There is a literal pool after this one.
            litpool_ref(_,_,LitPoolAddr+Size,_,"LDR",_),
            litpool_total_confidence(LitPoolAddr+Size,Confidence2),
            Confidence2 > 2,
            Points = 3
        )
        ;
        // There is no literal pool before this one, but, there is one after.
        !litpool_ref(_,_,LitPoolAddr-Size2,_,"LDR",_),
        litpool_ref(_,_,LitPoolAddr+Size,_,"LDR",_),
        litpool_total_confidence(LitPoolAddr+Size,Confidence1),
        Confidence1 > 1,
        Points = 1
    ).

block_points(Block,"data",0,9,"arm: $d symbol"),
data_block_candidate(Block,Size):-
    defined_symbol(Block,Size,_,_,_,_,_,_,"$d").

/**
Load followed by add pc is likely real code:
E.g.,
ldr Reg1, .L0
add Reg2, Reg1, pc
*/
contains_plausible_instr_seq(Block,6,"ldr/add-pc",0):-
    code_in_block_candidate_refined(EA,Block),
    !arch.dangling_thumb_instr(Block),
    init_ldr_add_pc(EA,_,_,_,_,_).


/**
Block with movw/movt pair is likely real code.
*/
contains_plausible_instr_seq(Block,6,"movw/movt",0):-
    movw_movt_pair(EA_movw,EA_movt,_),
    code_in_block_candidate_refined(EA_movw,Block),
    code_in_block_candidate_refined(EA_movt,Block).

/**
The return register is set up, and return:
E.g,
movs r0, #0
bx lr
*/
contains_plausible_instr_seq(Block,1,"set-r0/return",0):-
    code_in_block_candidate_refined(EA,Block),
    !arch.dangling_thumb_instr(Block),
    arch.return(EA),
    straight_line_last_def(EA,EA_def,R0),
    arch.return_reg(R0),
    EA_def < EA,
    (EA - EA_def) <= 8. // Within reasonable distance

/**
Flag-setting instruction followed by IT is likely real code:
E.g.,
cmp r0, #0
ite ne
*/
contains_plausible_instr_seq(Block,2,"cmp/it",0):-
    code_in_block_candidate_refined(EA,Block),
    instruction_get_operation(EA,Operation),
    substr(Operation,0,2) = "IT",
    straight_line_last_def(EA,EA_def,Reg),
    arch.condition_flags_reg(Reg),
    code_in_block_candidate_refined(EA_def,Block),
    instruction_get_operation(EA_def,CmpOperation),
    arch.cmp_operation(CmpOperation).

/**
Instruction setting lr followed by jump is likely real code:
E.g.,
mov lr, pc
bx target
*/
contains_plausible_instr_seq(Block,7,"mov-lr-pc/jump",0):-
    code_in_block_candidate_refined(EA,Block),
    !arch.dangling_thumb_instr(Block),
    arch.pc_reg(PC),
    arch.move_reg_reg(EA,"LR",PC),
    next(EA,EA_branch),
    code_in_block_candidate_refined(EA_branch,Block),
    arch.jump(EA_branch).

/**
Instruction releasing stack followed by return is likely real code:
E.g.,
sub sp, fp, #8   or   add sp, #8
pop {pc}
*/
contains_plausible_instr_seq(Block,1,"adjust-sp/return",0):-
    arch.return(EA),
    code_in_block_candidate_refined(EA,Block),
    !arch.dangling_thumb_instr(Block),
    code_in_block_candidate_refined(EA2,Block),
    arch.stack_pointer(SP),
    (
        arch.reg_arithmetic_operation(EA2,SP,FP,_,N), N < 0,
        arch.frame_pointer(FP)
        ;
        arch.reg_arithmetic_operation(EA2,SP,SP,_,N), N > 0
    ).

/**
If a block contains multiple stack load instructions, it is likely a real
code.
*/
contains_plausible_instr_seq(Block,2,"multiple loads from stack",0):-
    code_in_block_candidate_refined(_,Block),
    arch.stack_pointer(SP),
    Count = count :{code_in_block_candidate_refined(EA,Block),
                    arch.memory_access("LOAD",EA,_,_,_,SP,_,_,_)},
    Count > 5.

/**
Give 1 point to the blocks that are one-step transitive
from a block contains_plausible_instr_seq.
*/
contains_plausible_instr_seq(Block,1,cat("transitive: ",Note),Block2):-
    block_is_overlapping(Block,"code"),
    !arch.dangling_thumb_instr(Block),
    (
        code_in_block_candidate_refined(EA,Block),
        direct_jump(EA,Block2),
        Note = "jump to"
        ;
        code_in_block_candidate_refined(EA,Block),
        direct_call(EA,Block2),
        Note = "call to"
        ;
        direct_jump(EA,Block),
        code_in_block_candidate_refined(EA,Block2),
        Note = "jump from"
        ;
        direct_call(EA,Block),
        code_in_block_candidate_refined(EA,Block2),
        Note = "call from"
        ;
        may_fallthrough(EA,Block),
        code_in_block_candidate_refined(EA,Block2),
        Note = "may-fallthrough from"
        ;
        must_fallthrough(EA,Block),
        code_in_block_candidate_refined(EA,Block2),
        Note = "must-fallthrough from"
    ),
    contains_plausible_instr_seq(Block2,_,_,0).

block_points(Block,"data",0,8,"possible string: symbol"),
data_block_candidate(Block,End-Block):-
    !arm_jump_table_candidate(_,Block,_,_,_,_,_,_,_),
    ascii_string(Block,End),
    symbol(Block,_,Type,_,_,_,_,_,Name), Name != "$t", Type != "FUNC".

block_points(Block,"data",0,-5,"possible string: symbol is target"):-
    block_points(Block,"data",0,8,"possible string: symbol"),
    data_block_candidate(Block,Size),
    direct_jump(_,Target), Target >= Block, Target < Block+Size.

/**
Strings are often placed together.
Check if there's another string before or after this one.
*/
block_points(Block,"data",0,5,"possible string: string pred exists"),
data_block_candidate(Block,End-Block):-
    !arm_jump_table_candidate(_,Block,_,_,_,_,_,_,_),
    ascii_string(Block,End),
    aligned_address_in_data(_,Block),
    ascii_string(_,End2),
    // There could be 0~3 zeros between strings.
    (
        End2 = Block
        ;
        data_byte(End2,0),
        End2 = Block - 1
        ;
        data_byte(End2,0), data_byte(End2+1,0),
        End2 = Block - 2
        ;
        data_byte(End2,0), data_byte(End2+1,0), data_byte(End2+2,0),
        End2 = Block - 3
    ).

block_points(Block,"data",0,5,"possible string: string succ exists"),
data_block_candidate(Block,End-Block):-
    !arm_jump_table_candidate(_,Block,_,_,_,_,_,_,_),
    ascii_string(Block,End),
    aligned_address_in_data(_,Block),
    ascii_string(Block2,_),
    // There could be 0~3 zeros between strings.
    (
        End = Block2
        ;
        data_byte(End,0),
        End  = Block2 - 1
        ;
        data_byte(End,0), data_byte(End+1,0),
        End  = Block2 - 2
        ;
        data_byte(End,0), data_byte(End+1,0), data_byte(End+2,0),
        End  = Block2 - 3
    ).

/**
EA:     ldr r0, LitPoolAddr
...
CallEA: bl strcmp
...
LitPoolAddr: Block
...
Block: .string "..."
*/
block_points(Block,"data",0,4,"possible string: string param for string library"),
data_block_candidate(Block,End-Block):-
    !arm_jump_table_candidate(_,Block,_,_,_,_,_,_,_),
    ascii_string(Block,End),
    address_in_data(LitPoolAddr,Block),
    litpool_ref(EA,Reg,LitPoolAddr,_,"LDR",_),
    code_in_block_candidate(EA,Block2),
    code_in_block_candidate(CallEA,Block2),
    direct_call(CallEA,TargetEA),
    (
        symbol(TargetEA,_,_,_,_,_,_,_,Func)
        ;
        plt_entry(TargetEA,Func)
    ),
    arch.library_string_arg(Func,Reg).

/**
E.g.,
  0:   strb r3, [r0, #53]
  4:   ldrb r3, [r5, #1]
The strb instruction is 4 bytes, and the higher 2 bytes happens
to be subs instruction, so the blocks are overlapping.
The block with strb at 0 is real and the must-through predecessor
of the block at 4.
Whereas, the subs block do not have any successor.
To give more confidence to the real block with strb,
give points 2 to the enclosing block when the enclosing block has
a must-fallthrough even if the block is overlapping.
*/
block_points(InnerBlock,"code",0,-3,"arm: bogus sub-instruction"):-
    block_is_overlapping(InnerBlock,"code"),
    code_in_block_candidate_refined(EnclosingEA,_),
    must_fallthrough(_,EnclosingEA),
    EnclosingEA = InnerBlock-2,
    instruction(InnerBlock,2,_,_,_,_,_,_,_,_),
    instruction(EnclosingEA,4,_,_,_,_,_,_,_,_),
    !must_fallthrough(_,InnerBlock).

/**
A return block followed by a function symbol is likely real code.
*/
block_points(Block,"code",0,2,"arm: return followed by a function"):-
    block_is_overlapping(Block,"code"),
    code_in_block_candidate_refined(EA,Block),
    arch.return(EA),
    next(EA,EANext),
    function_symbol(EANext,_).

/**
Address_in_data with no explicit reference often happens to be ldmdaeq:
E.g.,
<  .word .L_8171bc9
<  .word .L_81501ba
---
>
>  ldmdaeq r7, { r0, r3, r6, r7, r8, sb, fp, ip }
>  ldmdaeq r5, { r1, r3, r4, r5, r7, r8 }
*/
block_is_overlapping(Block,"code"),
block_points(Block,"code",0,-7,"arm: ldmdaeq"):-
    code_in_block_candidate_refined(EA,Block),
    instruction_get_operation(EA,Operation),
    contains("LDM",Operation),
    (
        next(EA,EA2)
        ;
        next(EA2,EA)
    ),
    instruction_get_operation(EA2,Operation),
    instruction_get_dest_op(EA,_,DestOp1),
    op_regdirect_contains_reg(DestOp1,Reg),
    instruction_get_dest_op(EA2,_,DestOp2),
    op_regdirect_contains_reg(DestOp2,Reg).

/**
0x00000000 is unlikely a real instruction.
*/
block_points(Block,"code",0,-2,"arm: contains unplausible instr"):-
    code_in_block_candidate_refined(EA,Block),
    (EA band 1) = 0,
    data_word(EA,4,0).

data_block_candidate(Block,Pt_size),
block_points(Block,"data",0,2,"arm: pointer to string in data"):-
    aligned_address_in_data(Block,Addr),
    ascii_string(Addr,_),
    arch.pointer_size(Pt_size).

/**
On top of the above, if there's another string nearby, give more points.
*/
block_points(Block,"data",0,3,"arm: pointer to string adjacent to another strings in data"):-
    aligned_address_in_data(Block,Addr),
    ascii_string(Addr,End),
    (
        ascii_string(_,Addr), UNUSED(End)
        ;
        ascii_string(End,_)
    ).

symbolic_operand_candidate(EA,OpIndex,Addr,"data"):-
    code(EA),
    litpool_ref(EA,_,Addr,_,_,OpIndex),
    !function_symbol(as(Addr,address),_).

symbolic_operand_candidate(EA,OpIndex,Dest,Type):-
    code(EA),
    arch.pc_relative_addr(EA,_,Val),
    !pc_relative_for_jump_table(EA),
    Dest0 = as(Val,address),
    (
        code(Dest),
        Dest = Dest0, Type = "code"
        ;
        !code(Dest0),
        Dest = Dest0 - (Dest0 band 1),
        data_segment(Begin,End),
        Dest >= Begin, Dest <= End,
        Type = "data"
    ),
    instruction_immediate_offset(EA,OpIndex,_,_).

symbolic_operand_candidate(EA,OpIndex,Dest,Type):-
    code(EA),
    arch.pc_relative_addr(EA,_,Val),
    pc_relative_for_jump_table(EA),
    Dest = as(Val,address) + (EA band 1),
    code(Dest),
    Type = "code",
    instruction_immediate_offset(EA,OpIndex,_,_).

/**
Matches instruction patterns that access a symbol-symbol from the literal pool.

(Symbol2-Symbol1)*Scale

EA: The address of the literal pool with the symbol_minus_symbol expression
Size: The size of the symbolic expression
EA_litpool_ref: The EA referencing the literal pool (EA)
EA_def: The address associated with Symbol1
Reg: The register containing Symbol2
Type: Either "LDR" or "AddPC"
*/
.decl symbol_minus_symbol_litpool_access_pattern(EA:address,Size:unsigned,Symbol1:address,Symbol2:address,Scale:unsigned,EA_litpool_ref:address,EA_def:address,Reg:register,Type:symbol)
.output symbol_minus_symbol_litpool_access_pattern

/**
    ldr reg, LitPool
...
L1: add reg, pc
...
LitPool: .word TARGET - (L1+Disp)

where Disp = 4 for Thumb mode with word-aligned, and 8 for ARM mode.
*/
block_needs_splitting_at(EA_add_pc),
moved_data_label(LitPoolAddr,Size,Symbol1,EA_add_pc),
symbol_minus_symbol_litpool_access_pattern(LitPoolAddr,Size,Symbol1,Symbol2,1,EA,EA_add_pc,Reg,"LDR"):-
    cinf_ldr_add_pc(EA,Size,Reg,LitPoolAddr,EA_add_pc,Reg),

    data_word(LitPoolAddr,Size,Diff),
    arch.pc_relative_disp(EA_add_pc,Disp),
    Symbol1 = EA_add_pc + as(Disp,address),
    Addr2 = as(Diff,address) + Symbol1,
    Symbol2= Addr2-(Addr2 band 3).

//     ldr reg1, LitPool
// ...
//     adr reg2, Base
//     add reg1, reg2
// ...
// LitPool: .word TARGET - Base
//
// (in observed cases, LitPool == Base)
symbol_minus_symbol_litpool_access_pattern(LitPoolAddr,Size,Symbol1,Symbol2,1,EA_ldr,EA_add,Reg,"AddPC"):-
    // e.g., ldr reg1, LitPool
    litpool_ref(EA_ldr,Reg,LitPoolAddr,Size,"LDR",_),

    // e.g., add reg1, reg2
    def_used(EA_ldr,Reg1,EA_add,_),
    arch.reg_reg_arithmetic_operation(EA_add,Reg1,Reg1,Reg2,1,0),

    // e.g., adr reg1, Base
    def_used(EA_adr,Reg2,EA_add,_),
    litpool_ref(EA_adr,Reg2,BaseAligned,4,"AddPC",_),

    data_word(LitPoolAddr,Size,Diff),

    Symbol1 = as(BaseAligned,address),
    Addr2 = as(Diff,address) + Symbol1,
    Symbol2 = Addr2-(Addr2 band 1).

value_reg(EA,Reg,EA,"NONE",0,as(Symbol2,number),1):-
    symbol_minus_symbol_litpool_access_pattern(_,_,_,Symbol2,_,_,EA,Reg,_).

labeled_data_candidate(Symbol2),
relative_jump_table_entry_candidate(LitPoolAddr,LitPoolAddr,Size,Symbol1,Symbol2,1,0):-
    symbol_minus_symbol_litpool_access_pattern(LitPoolAddr,Size,Symbol1,Symbol2,1,_,_,_,"AddPC").

/**
litpool_symbolic_operand

PC-relative symbolic operand
*/
.decl litpool_symbolic_operand(ea_litpool:address,data_access_size:unsigned,symbol1:address,symbol2:address,ea_def:address,reg_def:register,sym2_size:unsigned)
.output litpool_symbolic_operand

//  (A) ldr  reg1, LitPoolAddr1
//  (B) ldr  reg2, LitPoolAddr2
//  (C) add  reg1, pc, reg1 // reg1 is the address of symbol foo
//  (D) ldr  reg3, [reg1, reg2] // the referenced address is the address of symbol bar.
litpool_symbolic_operand(LitPoolAddr2,DataAccessSize,Symbol1,Symbol2,EA_D,Reg3,SymSize):-
    symbol_minus_symbol_litpool_access_pattern(_,_,_,Symbol1,1,_,EA_C,Reg0,_),
    (
        def_used(EA_C,Reg1,EA_D,_), Reg1 = Reg0
        ;
        value_reg_edge(EA_restore,Reg1,EA_C,Reg0,1,0),
        def_used(EA_restore,Reg1,EA_D,_)
    ),

    // (D) ldr reg3, [reg1, reg2]
    instruction_get_operation(EA_D,Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(EA_D,_,IndOp),
    instruction_get_dest_op(EA_D,_,RegOp),
    op_indirect_mapped(IndOp,"NONE",Reg1,Reg2,_,0,Bits),
    op_regdirect_contains_reg(RegOp,Reg3),
    SymSize = Bits / 8,

    def_used(EA_B,Reg2,EA_D,_),

    // (B) ldr reg2, LitPoolAddr2
    litpool_ref(EA_B,Reg2,LitPoolAddr2,DataAccessSize,"LDR",_),

    data_word(LitPoolAddr2,DataAccessSize,Diff),
    Symbol2 = as(Diff,address) + Symbol1.

value_reg(EA,Reg,EA,"NONE",0,as(Val,number),1):-
    litpool_symbolic_operand(_,_,_,Symbol2,EA,Reg,Size),
    track_register(Reg),
    data_word(Symbol2,Size,Val).

//  => equations: [LitPoolAddr1] = foo - (C)
//                [LitPoolAddr2] = bar - foo
//
symbol_minus_symbol(LitPoolAddr2,Size,Symbol1,Symbol2,1,0):-
    litpool_symbolic_operand(LitPoolAddr2,Size,Symbol1,Symbol2,_,_,_),
    !symbolic_expr_attribute(LitPoolAddr2,"GotRelPC"),
    loaded_section(Beg,End,".got"),
    // Symbol2 is not in got.
    (
        Symbol2 < Beg, UNUSED(End)
        ;
        Symbol2 >= End, UNUSED(Beg)
    ),
    !relocation(LitPoolAddr2,_,_,_,_,_,_),
    (
        code(Symbol2)
        ;
        data_segment(DataBeg,DataEnd),
        Symbol2 >= DataBeg, Symbol2 < DataEnd
    ).

//  => equations: [LitPoolAddr1] = foo - (C)
//                [LitPoolAddr2] = bar(GOT) - foo => bar(GOT)
//
symbolic_expr_attribute(LitPoolAddr,"GotRelPC"),
symbolic_data(LitPoolAddr,SymSize,Got_entry):-
    litpool_symbolic_operand(LitPoolAddr,_,_,Got_entry,_,_,SymSize),
    loaded_section(GotBeg,GotEnd,".got"),
    Got_entry >= GotBeg,
    Got_entry < GotEnd,
    (
        relocation(Got_entry,RelType,Symbol,_,_,_,_),
        RelType != "RELATIVE",
        symbol(_,_,_,_,_,_,_,_,Symbol)
        ;
        symbolic_data(Got_entry,SymSize,_)
    ).

must_access_data(EA,Dest):-
    litpool_ref(EA,_,Dest,_,"LDR",_);
    litpool_ref_double(EA,_,_,Dest,_).

symbolic_expr_from_relocation(EA+1,4,Symbol,Addend,as(Dest,address)):-
    binary_type("REL"),
    (
        relocation(EA,"THM_CALL",Symbol,_,_,_,"REL");
        relocation(EA,"THM_JUMP24",Symbol,_,_,_,"REL")
    ),
    Symbol != "",
    thumb_branch_offset(EA,Offset),
    Addend = Offset + 4,
    Dest = as(EA,number)+Addend.

/**
Decode Thumb-2 encoded branch offset. Used to find REL relocation addends.

Note that this is backwards compatible with Thumb-1.
*/
.decl thumb_branch_offset(EA:address,Offset:number)
.output thumb_branch_offset

thumb_branch_offset(EA,Offset):-
    (
        relocation(EA,"THM_CALL",_,_,_,_,_);
        relocation(EA,"THM_JUMP24",_,_,_,_,_)
    ),
    data_word(EA,2,Half0),
    data_word(EA+2,2,Half1),
    UpperHalf = as(Half0,unsigned),
    LowerHalf = as(Half1,unsigned),
    Sign = (UpperHalf band (1 bshl 10)) bshr 10,
    Upper = UpperHalf band 0x3FF,
    Lower = LowerHalf band 0x7FF,
    J1 = (LowerHalf band (1 bshl 13)) bshr 13,
    J2 = (LowerHalf band (1 bshl 11)) bshr 11,
    (J1 bxor Sign = 0, I1 = 1; J1 bxor Sign != 0, I1 = 0),
    (J2 bxor Sign = 0, I2 = 1; J2 bxor Sign != 0, I2 = 0),
    Bits = (Sign bshl 24) bor (I1 bshl 23) bor (I2 bshl 22) bor (Upper bshl 12) bor (Lower bshl 1),
    // Sign-extend unsigned 25-bit value to 32 bits.
    Masked = Bits band ((bnot 1) bshr (32 - 25)),
    TopBit = as(1 bshl (25 - 1),number),
    Signed = as(Masked,number),
    (
        Signed band TopBit = 0,  Offset = Signed;
        Signed band TopBit != 0, Offset = Signed - (TopBit * 2)
    ).

impossible_jump_target(Val):-
    possible_ea(Val),
    arch.it_conditional(Val,IT),
    // Make sure that the IT instruction is valid to avoid the following case:
    // This assumption is needed to avoid the following case: e.g., zlib.O1:
    // 1: b .L_41b1
    // 5: ldr r3, [r6,#12]
    // The instruction at address 3 happens to be ITTE.
    // Although this assumes that IT instruction is not a branch target, at
    // least this restricts false-positive cases.
    next(_,IT).

/**
Block containing instructions that only belong to Microcontroller arch.
*/
.decl arm_microcontroller(Block:address)
.output arm_microcontroller

arm_microcontroller(Block):-
    refined_block(Block),
    code_in_block_candidate_refined(EA,Block),
    instruction(EA,_,_,Operation,_,_,_,_,_,_),
    (
        // The following instructions are only decoded with CS_MODE_MCLASS.
        substr(Operation,0,3) = "MRS";
        substr(Operation,0,3) = "MSR"
    ).
