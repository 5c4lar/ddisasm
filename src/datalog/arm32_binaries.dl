//===- arm32_binaries.dl ------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019-2022 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to abstract from ARM32 specific instruction set
and characteristics
*/

// doubleword operations require an even,odd pair of registers, e.g., r2,r3
// Rt2 isn't really encoded in the instruction, it's derived from Rt, so we
// just need to ensure Rt is even.
invalid(EA,"arm: doubleword op Rt is odd"):-
    arch.memory_access(_,EA,_,_,Rt,_,_,_,Offset), // memory access for Rt
    arch.memory_access(_,EA,_,_,_,_,_,_,Offset2), // memory access for Rt2
    Offset < Offset2,
    instruction_get_operation(EA,Operation),
    OperationRoot = substr(Operation,0,4),
    (
        OperationRoot = "LDRD";
        OperationRoot = "STRD"
    ),
    (EA band 1) = 0, // ARM mode only
    (
        arch.reg_index(Rt,Index), (Index band 1) = 1;  // If Rt is odd, the instruction is invalid.
        Rt = "LR"                                      // If Rt is LR, the instruction is invalid.
    ).

// For T32 instructions, you must not specify SP or PC for either Rt or Rt2.
// LDRD Rt, Rt2, [Rn]
// LDRD Rt, Rt2, [Rn], #offset
invalid(EA,"thumb: doubleword op registers invalid"):-
    arch.memory_access(_,EA,_,_,Rt,_,_,_,_),
    (EA band 1) = 1, // Thumb mode only
    instruction_get_operation(EA,Operation),
    substr(Operation,0,4) = "LDRD",
    (
        Rt = "SP";
        Rt = "PC"
    ).

// Applies to all of STR,LDR,STRD,LDRD
invalid(EA,"arm: pre/post-index disallows Rt[2] eq Rn"):-
    // For LDRD operations, there will be an arch.memory_access for each of Rt
    // and Rt2, so this rule will check both for conflict with Rn.
    arch.memory_access(_,EA,_,_,Rt,Rn,_,_,_),
    instruction_writeback(EA),
    Rt = Rn.

// Rm must be different from Rt and Rt2 in LDRD instructions.
// LDRD{cond} Rt, Rt2, [Rn], ±Rm
// LDRD{cond} Rt, Rt2, [Rn, ±Rm]
// LDRD{cond} Rt, Rt2, [Rn, ±Rm]!
invalid(EA,"arm: doubleword rm/rt conflict"):-
    (
        arch.memory_access(_,EA,_,_,Rt,_,Rm,_,_), Rm != "NONE";
        // Post-index form: Rm is not part of the memory access, since it is
        // only incremented afterward.
        arch.memory_access(_,EA,_,_,Rt,Rn,"NONE",_,_),
        arch.reg_reg_arithmetic_operation(EA,Rn,Rn,Rm,_,0)
    ),
    (EA band 1) = 0, // ARM mode only
    instruction_get_operation(EA,Operation),
    substr(Operation,0,4) = "LDRD",
    // For LDRD operations, there will be an arch.memory_access for each of Rt
    // and Rt2, so this rule will check both for conflict with Rm.
    Rt = Rm.

invalid(EA,"arm: pc is not allowed"):-
    instruction_get_operation(EA,Operation),
    (
        contains("AND",Operation);
        contains("BIC",Operation);
        contains("LDM",Operation)
    ),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_register(PC).

invalid(EA,"arm: sp is not allowed"):-
    instruction_get_operation(EA,Operation),
    substr(Operation,0,3) = "AND",
    instruction_get_src_op(EA,_,Op),
    op_regdirect_contains_reg(Op,SP),
    arch.stack_pointer(SP).

invalid(EA,"arm: deprecated bx"):-
    instruction_get_operation(EA,"BX"),
    instruction_get_op(EA,1,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.stack_pointer(Reg).

invalid(EA,"arm: pc cannot be used as index register"):-
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_,_,PC,_,_,_),
    arch.pc_register(PC).

invalid(EA,"arm: invalid mul operand (pc)"):-
    instruction_get_operation(EA,Operation),
    contains("MUL",Operation),
    instruction_get_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.pc_register(Reg).

invalid(EA,"arm: deprecated bx"):-
    instruction_get_operation(EA,"BX"),
    instruction_get_op(EA,1,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.stack_pointer(Reg).

// The following instructions do not allow PC as the destination register.
invalid(EA,"arm: invalid pc"):-
    instruction_get_operation(EA,Operation),
    (
        Operation = "MLAHS";
        Operation = "MLASHS";
        Operation = "LDRSHEQ";
        Operation = "LDRSHTEQ";
        Operation = "LDRSHTLO";
        Operation = "LDRSHTVC";
        Operation = "LDRBEQ";
        Operation = "LDRSBEQ";
        Operation = "LDRHHS";
        Operation = "LDRHTHS";
        Operation = "LDRSBHS";
        Operation = "LDRSHHS";
        Operation = "LDRSBTHS";
        Operation = "LDRSHTHS";
        contains("LDRSB",Operation);
        contains("LDRBVC",Operation);
        contains("LDRBLO",Operation)
    ),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_register(PC).

// PC-relative LDR
value_reg_edge(EA,Reg,EA,"NONE",0,Val):-
    litpool_ref(EA,Reg,LitPoolAddr,Size,"LDR"),
    !relocation(LitPoolAddr,_,_,_,_,_,_),
    data_word(LitPoolAddr,Size,Val).

// ADR
value_reg_edge(EA,Reg,EA,"NONE",0,Val):-
    litpool_ref(EA,Reg,LitPoolAddr,_,"ADR"),
    Val = as(LitPoolAddr,number).

/**
PC stores the address of the current instruction plus 8 (two ARM
instructions) in ARM state, and the current instruction plus 4
(two Thumb instructions) in Thumb state.
This is used for computing PC-relative addresses.
*/
.decl pc_relative_disp(EA:address,Disp:number) inline

pc_relative_disp(EA,Disp):-
    (EA band 1) = 0,  Disp = 8  // ARM mode
    ;
    (EA band 1) != 0, Disp = 4. // Thumb mode

/**
Jump to the PC register: "bx pc"
*/
direct_jump(EA,Dest):-
    arch.jump(EA),
    instruction_get_operation(EA,Operation),
    arch.jump_operation_op_index(Operation,TargetOpIndex),
    instruction_get_op(EA,TargetOpIndex,TargetOp),
    op_regdirect(TargetOp,Reg),
    arch.pc_register(Reg),
    pc_relative_disp(EA,Disp),
    Dest0 = EA + as(Disp,address),
    Dest = Dest0 - (Dest0 band 1).

pc_relative_operand(EA,Index,as(as(EANext,number)+Offset,address)):-
    instruction_get_op(EA, Index, Op),
    op_indirect(Op,"NONE",Reg,"NONE",1,Offset,_),
    arch.pc_register(Reg),
    pc_relative_disp(EA,Disp),
    EANext0 = EA + as(Disp,address),
    // Align the address
    EANext = EANext0 - (EANext0 band 3).

avoid_symbols("$t").
avoid_symbols("$a").

basic_target(Val+1):-
    defined_symbol(Val,_,_,_,_,_,_,_,"$t").
basic_target(Val):-
    defined_symbol(Val,_,_,_,_,_,_,_,"$a").

/**
E.g.,
  add ip, pc, #0, #12
  add ip, ip, #16, #20
  ldr pc, [ip, #2640]
*/
plt_entry(EA,Function):-
    plt_entry_arm_candidate(_,EA,Function,_).

block_points(EA_entry,"code",0,7,"arm: plt-block"):-
    plt_entry_arm_candidate(EA_entry,_,_,_).

/**
E.g.,
  bx pc // thumb
  b.n XXX or nop // thumb
  add ip, pc, #0, #12
  add ip, ip, #16, #20
  ldr pc, [ip, #2640]
*/
block_points(EA-3,"code",0,7,"arm: plt-block: bx pc"),
plt_block(EA-3,Function):-
    plt_entry_arm_candidate(EA,_,Function,_),
    instruction_get_operation(EA-3,Operation2), // thumb
    arch.jump_operation_op_index(Operation2,TargetOpIndex),
    instruction_get_op(EA-3,TargetOpIndex,TargetOp),
    op_regdirect_contains_reg(TargetOp,PC),
    arch.pc_register(PC).

/**
plt_entry_arm_candidate

EA_entry: The address of the PLT entry
EA_jump:  The address of the last jump instruction in the PLT entry
Function: The external function that the PLT entry forwards
EA_reloc: The destination address of the PLT entry
*/
.decl plt_entry_arm_candidate(EA_entry:address, EA_jump:address, Function:symbol, EA_reloc:address)
.output plt_entry_arm_candidate

/**
E.g.,
  add ip, pc, #0, #12
  add ip, ip, #16, #20   or   add ip, ip, #N
  ldr pc, [ip, #2640]
*/
plt_entry_arm_candidate(EA,EA_jump,Function,as(Dest,address)):-
    plt_section(SecName),
    loaded_section(Beg,End,SecName),
    EA >= Beg,
    EA < End,

    arch.pc_register(PC),

    // add ip, pc, #0, #12
    arch.reg_arithmetic_operation(EA,Reg,PC,1,N1),
    next(EA, NextEA),

    // add ip, ip, #16, #20
    // or
    // add ip, ip, #XXXX
    arch.reg_arithmetic_operation(NextEA,Reg,Reg,1,N2),
    next(NextEA, EA_jump),

    // ldr pc, [ip, #N]
    instruction_get_operation(EA_jump,Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(EA_jump,_,OffsetOp),
    op_indirect(OffsetOp,"NONE",Reg,"NONE",_,Offset,_),
    instruction_get_dest_op(EA_jump,_,RegOp),
    op_regdirect_contains_reg(RegOp,PC),

    Dest = as(EA,number) + N1 + N2 + Offset + 8,
    relocation(as(Dest,address),_,Function,_,_,_,_).

/**
E.g.,
  movw ip, #N1
  movt ip, #N2
  add ip, pc
  ldr.w pc, [ip, #Offset]
*/
plt_entry_arm_candidate(EA,EA_jump,Function,as(Dest,address)):-
    plt_section(SecName),
    loaded_section(Beg,End,SecName),
    EA >= Beg,
    EA < End,

    arch.pc_register(PC),

    movw_movt_pair(EA,EA_movt,Value),

    // add ip, pc
    next(EA_movt, EA_add),
    arch.reg_reg_arithmetic_operation(EA_add,Reg,PC,Reg,1,0),

    // ldr.w pc, [ip, #Offset]
    next(EA_add, EA_jump),
    instruction_get_operation(EA_jump,Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(EA_jump,_,OffsetOp),
    op_indirect(OffsetOp,"NONE",Reg,"NONE",_,Offset,_),
    instruction_get_dest_op(EA_jump,_,RegOp),
    op_regdirect_contains_reg(RegOp,PC),

    // What about Offset? It seems irrelevant.
    Offset = Offset,
    Dest = as(EA_add,number) - 1 + Value,
    relocation(as(Dest,address),_,Function,_,_,_,_).

block_points(Block,"code",0,10,"call with relocation"):-
    binary_type("REL"),
    block_is_overlapping(Block,"code"),
    code_in_block_candidate_refined(EA,Block),
    arch.call(EA,_),
    AlignedEA = EA - (EA band 1),
    relocation(AlignedEA,"THM_CALL",_,_,_,_,_).

block_points(Block,"code",0,1,"arm: plt call"):-
    plt_entry_arm_candidate(BlockDest,_,_,_),
    direct_call(EA,BlockDest),
    code_in_block_candidate_refined(EA,Block),
    block_is_overlapping(Block,"code").

/**
E.g., EA_movw: movw reg, N
      EA_movt: movt reg, M
   => reg's Value = N | (M << 16)
*/
.decl movw_movt_pair(EA_movw:address,EA_movt:address,Value:number)
.output movw_movt_pair

movw_movt_pair(EA_movw,EA_movt,Value):-
    instruction_get_operation(EA_movt,"MOVT"),
    instruction_get_op(EA_movt,2,RegOp2),
    op_regdirect_contains_reg(RegOp2,Reg),
    // Given a movt, try to find the corresponding movw up to 3 instructions.
    (
        next(EA_movw,EA_movt)
        ;
        next(EA_movw,EA_temp),
        next(EA_temp,EA_movt)
        ;
        next(EA_movw,EA_temp1),
        next(EA_temp1,EA_temp2),
        next(EA_temp2,EA_movt)
    ),
    instruction_get_operation(EA_movw,"MOVW"),
    instruction_get_op(EA_movw,2,RegOp),
    op_regdirect_contains_reg(RegOp,Reg),
    // Compute the value
    instruction_get_op(EA_movw,1,Op),
    op_immediate(Op,Low),
    instruction_get_op(EA_movt,1,Op2),
    op_immediate(Op2,High),
    Value = (High*2^16) bor Low.

symbolic_operand_attribute(EA_lo,1,"Part0"),
symbolic_operand_candidate(EA_lo,1,Dest,Type),
symbolic_operand_attribute(EA_hi,1,"Part1"),
symbolic_operand_candidate(EA_hi,1,Dest,Type):-
    movw_movt_pair(EA_lo,EA_hi,Value),
    Dest = as(Value,address),
    (
        code(Dest), Type="code"
        ;
        data_segment(Begin,End),
        Dest >= Begin, Dest <= End,
        Type = "data"
    ).

symbolic_operand_point(EA,Imm_index,-1,"unlikely to have symbolic operand"):-
    symbolic_operand_candidate(EA,Imm_index,_,_),
    instruction_get_operation(EA,Operation),
    (
        arch.cmp_operation(Operation)
        ;
        arch.logic_operation(Operation)
    ).

symbolic_operand_candidate(EA,1,Dest,Type):-
    !litpool_ref_double(EA,_,_,_,_),
    // ADR <Register> <Immediate>
    // e.g. adr r1, BaseOp
    instruction_get_operation(EA,Operation),
    substr(Operation,0,3) = "ADR",
    instruction_get_op(EA, 1, OffsetOp),
    op_immediate(OffsetOp, Offset),
    pc_relative_disp(EA,Disp),
    Dest0 = EA + as(Offset,address) + as(Disp,address),
    // Align the address
    Dest1 = Dest0 - (Dest0 band 3),
    (
        code(Dest1), Dest = Dest1, Type="code" // ARM
        ;
        code(Dest1+1), Dest = Dest1+1, Type="code" // Thumb
        ;
        Dest = Dest1,
        data_segment(Begin,End),
        Dest >= Begin, Dest <= End,
        Type = "data"
    ).

/**
case 1:
PIC code uses inlined pc-relative offsets,

    ldr REG, .L0
    .LPIC0:
       add REG, pc
       ...
    .L0:
       .word foo-(.LPIC0+Disp)

    (Disp=4 for Thumb mode, 8 for ARM mode)

where the symbol foo is the target symbol, and .L0 will contain the offset
from PC at .LPIC0 to the symbol foo.

case 2:
    .L0:
       .long foo(GOT)
where foo is a symbol relocated by GOT.
*/
labeled_data_candidate(Dest),
symbol_minus_symbol_candidate(Addr,Size,EA_add_pc,Dest,as(Scale,unsigned),Offset):-
    litpool_ref(EABase,Reg,Addr,Size,_),
    def_used(EABase,Reg,EA_add_pc,_),
    arch.reg_reg_arithmetic_operation(EA_add_pc,Reg,Reg,PC,1,0),
    arch.pc_register(PC),

    pc_relative_disp(EA_add_pc,Disp),
    data_word(Addr,Size,Diff),
    Mode = EA_add_pc band 1,
    Offset = -1 * Disp,
    (
        Dest = EA_add_pc + as(Disp + Diff,address) - Mode,
        !relocation(Addr,_,_,_,_,_,_)
        ;
        relocation(Addr,"REL32",Symbol,_,SymbolIndex,_,"REL"),
        symbol(Base,_,_,_,_,_,_,SymbolIndex,Symbol),
        // ((S + A) | T) - P
        S = as(Base,unsigned),
        A = as(Diff,unsigned),
        P = as(Addr,unsigned),
        T = as(Base band 1,unsigned),
        Value = ((S + A) bor T) - P,
        Dest = (EA_add_pc + as(Disp,address) - Mode) + as(Value,address)
    ),

    data_segment(Begin,End),
    Dest >= Begin, Dest <= End,
    Scale = 1.

symbol_minus_symbol_from_relocation(EA,4,SymbolName2,"_GLOBAL_OFFSET_TABLE_",1,Offset):-
    binary_type("REL"),
    relocation(EA,"BASE_PREL","_GLOBAL_OFFSET_TABLE_",_,_,_,_),
    symbol_minus_symbol_litpool_access_pattern(_,4,_,EA,1,_,Symbol2,_,Type),
    (
        Type = "LDR", Offset = -4
        ;
        Type = "ADR", Offset = 0
    ),
    best_symexpr_symbol(Symbol2,SymbolName2,"Beg").

/**
Represents the first entry of an ARM jump table.

Attributes:

* EA_jump: address of jump instruction
* TableStart: address of first table entry
* EntryAddr: address of table entry
* EntrySize: size of entries
* TargetAddr: resolved target of the jump
* TableLimit: first address that cannot be part of the jump table
* Type: absolute or relative
*/
.decl arm_jump_table_candidate_start(EA_jump:address,TableStart:address,EntryAddr:address,EntrySize:unsigned,TargetAddr:address,TableLimit:address,Type:symbol,Scale:unsigned,Offset:number)

/**
Represents an entry in an ARM jump table.

Attributes:

* EA_jump: address of jump instruction
* TableStart: address of first table entry
* EntryAddr: address of table entry
* EntrySize: size of entries
* TargetAddr: resolved target of the jump
* TableLimit: first address that cannot be part of the jump table
* Type: absolute or relative
*/
.decl arm_jump_table_candidate(EA_jump:address,TableStart:address,EntryAddr:address,EntrySize:unsigned,TargetAddr:address,TableLimit:address,Type:symbol,Scale:unsigned,Offset:number)

.output arm_jump_table_candidate

arm_jump_table_candidate_start(EA_jump,TableStart,TableStart,Size,TargetAddr,TableLimit,"absolute",1,0):-
    arch.load_word_operation(Operation),
    instruction(EA_jump,_,_,Operation,IndOp,RegOp,0,0, _,_),
    EA_jump band 1 = 0,
    // ldr pc, [pc,r2, lsl N]
    // TODO: Currently, 'lsl N' is not propagated from the decoder.
    op_regdirect_contains_reg(RegOp,PC),
    arch.pc_register(PC),
    op_indirect(IndOp,"NONE",PC,_,_,0,NBits),
    Size = NBits / 8,
    arch.pointer_size(Size),
    (
        arch.conditional_operation(Operation),
        // 8: Assumes that there is a fall-through successor consisting
        // of one instruction (typically a jump instruction)
        TableStart = EA_jump + 8,
        // Check the fall-through instruction is a jump
        next(EA_jump,EA_fallthrough),
        arch.jump(EA_fallthrough)
        ;
        !arch.conditional_operation(Operation),
        TableStart = EA_jump + 4
    ),
    address_in_data(TableStart,TargetAddr),
    (
        // Jump to after the jumptable - sets a hard limit on the jumptable size.
        TargetAddr > TableStart, TableLimit = TargetAddr;
        // Jump to before the jumptable - does not restrict jumptable size.
        TargetAddr <= TableStart, TableLimit = (2 ^ NBits) - 1
    ).

/**
Compute the target address for the given relative jump-table entry.

EA: An entry of a relative jump-table
TableStart: The starting address of the jump-table
Size: The size of the entry
Scale: The scale amount is multiplied to the entry value
AlignedTargetAddr: The computed tgarget address is aligned
*/
.decl arm_relative_jump_table_target(EA:address,TableStart:address,Size:unsigned,Scale:unsigned,AlignedTargetAddr:address) inline
arm_relative_jump_table_target(EA,TableStart,Size,Scale,AlignedTargetAddr):-
    (
        Size != 1, data_word(EA,Size,DiffUnsigned);
        Size = 1, data_byte(EA,DiffUnsigned)
    ),
    DiffUnsigned != 0, // A table with odd number of entries is padded with 0
    Diff = as(DiffUnsigned,number),
    TargetAddr = as(Diff*as(Scale,number)+as(TableStart,number),address),
    AlignedTargetAddr = TargetAddr - (TargetAddr band 1).

arm_jump_table_candidate_start(EA,TableStart,TableStart,Size,TargetAddr,TableLimit,"relative",2,0):-
    (
        Operation="TBH", Size = 2;
        Operation="TBB", Size = 1
    ),
    instruction(EA,InstrSize,_,Operation,Operand,0,0,0,_,_),
    EA band 1 = 1, // assert: tbb/tbh instruction only exist in Thumb.
    op_indirect(Operand,"NONE","PC", _,_,_,_),
    TableStart = as(EA+InstrSize-1,address),

    // tbb/tbh can't perform a mode switch and just uses aligned addresses of
    // Thumb targets.
    arm_relative_jump_table_target(TableStart,TableStart,Size,2,AlignedTargetAddr),
    TargetAddr = AlignedTargetAddr + 1,
    (
        // Jump to after the jumptable - sets a hard limit on the jumptable size.
        AlignedTargetAddr > TableStart, TableLimit = AlignedTargetAddr;
        // Jump to before the jumptable - does not restrict jumptable size.
        AlignedTargetAddr <= TableStart, arch.pointer_size(PtrSize), TableLimit = (2 ^ ((8*PtrSize)-1)) - 1
    ).

/**
EA:      adr r1, OffsetToTableStart    or   add r1, pc, #10
EA_ldr:  ldr r3, [r1,r2,lsl N]
EA_add   add r4, r3    or   add r4, r4, r3
EA_jump: bx r4
*/
arm_jump_table_candidate_start(EA_jump,TableStart,TableStart,Size,TargetAddr,TableLimit,"relative",1,as(EA_jump band 1,number)):-
    (
        instruction_get_operation(EA,"ADR"),
        instruction_get_op(EA, 1, OffsetOp),
        op_immediate(OffsetOp, Offset)
        ;
        instruction_get_operation(EA,"ADD"),
        arch.reg_arithmetic_operation(EA,_,PC,1,Offset),
        arch.pc_register(PC)
    ),
    pc_relative_disp(EA,Disp),
    TableStart0 = EA + as(Offset,address) + as(Disp,address),
    next(EA,EA_ldr),
    instruction_get_operation(EA_ldr,"LDR"),
    next(EA_ldr,EA_add),
    arch.reg_reg_arithmetic_operation(EA_add,R4,R4,R3,1,0),
    next(EA_add,EA_jump),
    instruction_get_operation(EA_jump,Operation),
    substr(Operation,0,2) = "BX",

    arch.jump_operation_op_index(Operation,TargetOpIndex),
    instruction_get_op(EA_jump,TargetOpIndex,Reg4Op),
    op_regdirect_contains_reg(Reg4Op,R4),

    instruction_get_dest_op(EA_ldr,_,Reg3Op),
    op_regdirect_contains_reg(Reg3Op,R3),
    instruction_get_src_op(EA_ldr,_,IndOp),
    op_indirect(IndOp,"NONE",R1,_,Mult,0,NBits),
    instruction_get_dest_op(EA,_,Reg1Op),
    op_regdirect_contains_reg(Reg1Op,R1),

    // TODO: Check on Mult=2?
    Mult = Mult, // to avoid warnings
    Size = NBits / 8,
    arch.pointer_size(Size),
    TableStart = TableStart0 - (TableStart0 band 1),

    arm_relative_jump_table_target(TableStart,TableStart,Size,1,AlignedTargetAddr),
    TargetAddr = AlignedTargetAddr + (EA_jump band 1),
    (
        // Jump to after the jumptable - sets a hard limit on the jumptable size.
        AlignedTargetAddr > TableStart, TableLimit = AlignedTargetAddr;
        // Jump to before the jumptable - does not restrict jumptable size.
        AlignedTargetAddr <= TableStart, arch.pointer_size(PtrSize), TableLimit = (2 ^ ((8*PtrSize)-1)) - (EA_jump band 1)
    ).

// base case
arm_jump_table_candidate(EA_jump,TableStart,EA,Size,TargetAddr,NewTableLimit,Type,Scale,Offset):-
    arm_jump_table_candidate_start(EA_jump,TableStart,EA,Size,TargetAddr,NewTableLimit,Type,Scale,Offset),
    // We check this here so `arm_jump_table_candidate_start` is not recursive
    // and `arm_jump_table_candidate_start` is not recomputed for every new `code_in_block_candidate`.
    code_in_block_candidate(TargetAddr,_).

// recursive case
arm_jump_table_candidate(EA_jump,TableStart,EA+Size,Size,TargetAddr,NewTableLimit,Type,Scale,Offset):-
    arm_jump_table_candidate(EA_jump,TableStart,EA,Size,_,TableLimit,Type,Scale,Offset),
    (
        Type = "absolute",
        address_in_data(EA+Size,TargetAddr),
        AlignedTargetAddr=TargetAddr
        ;
        Type = "relative",
        arm_relative_jump_table_target(EA+Size,TableStart,Size,Scale,AlignedTargetAddr),
        TargetAddr = AlignedTargetAddr + (EA_jump band 1)
    ),
    EA+Size < TableLimit,
    (
        // The target address is less than the limit, but at some address beyond
        // the current entry. Limit the table size to that target.
        AlignedTargetAddr < TableLimit, AlignedTargetAddr > EA+Size, NewTableLimit = AlignedTargetAddr;
        // The target address points at or before the current jump table entry.
        // Gives us no info about the table size - keep propagating.
        AlignedTargetAddr < TableLimit, AlignedTargetAddr <= EA+Size, NewTableLimit = TableLimit;
        // The target address points beyond our current limit - keep propagating.
        AlignedTargetAddr >= TableLimit, NewTableLimit = TableLimit
    ),
    code_in_block_candidate(TargetAddr,_),
    // Target address cannot be within the table itself
    (
        TargetAddr < TableStart
        ;
        TargetAddr > NewTableLimit
    ).

// Aggregate arm_jump_table_candidate in one data block
block_points(TableStart,"data",0,Points,"arm jump table"),
data_block_candidate(TableStart,BlockSize):-
    arm_jump_table_candidate(EA_jump,TableStart,EA_last,Size,_,_,_,_,_),
    !arm_jump_table_candidate(EA_jump,TableStart,EA_last+Size,Size,_,_,_,_,_),
    BlockSize = EA_last - TableStart + Size,
    Depth = BlockSize / Size,
    Points = 7+as(Depth,number).

jump_table_candidate(EA,DataEA,TargetEA):-
    arm_jump_table_candidate(EA,_,DataEA,_,TargetEA,_,_,_,_).

data_object_point(DataEA,Size,"symbol",2,"arm jump-table3"),
data_object_candidate(DataEA,Size,"symbol"):-
    arm_jump_table_candidate(_,_,DataEA,Size,_,_,"absolute",_,_).

jump_table_start(EA,Size,TableStart,TableStart,1):-
    arm_jump_table_candidate(EA,TableStart,DataEA,Size,_,_,_,_,_),
    jump_table_candidate_refined(EA,DataEA,_).

relative_jump_table_entry_candidate(DataEA,TableStart,Size,TableStart,TargetAddr,as(Scale,number),Offset):-
    arm_jump_table_candidate(EA,TableStart,DataEA,Size,_,_,_,Scale,Offset),
    jump_table_candidate_refined(EA,DataEA,TargetAddr).

/**
Instruction at address `EA` accesses a literal pool located at `LitPoolAddr`

Type="LDR" : Reg gets the value at the LitPoolAddr
Type="ADR" : Reg gets the address of the literal pool (LitPoolAddr)
*/
.decl litpool_ref(EA:address, Reg:register, LitPoolAddr:address, Size:unsigned, Type:symbol)

litpool_ref(EA,Reg,LitPoolAddr,Size,Type):-
    possible_ea(EA),
    instruction_get_operation(EA,Operation),
    instruction_get_src_op(EA,_,OffsetOp),
    (
        // LDR <Register> <IndirectOp>
        // e.g., ldr r3, [pc, Offset]
        arch.load_operation(Operation),
        op_indirect(OffsetOp,"NONE",PC,"NONE",_,Offset,NBits),
        arch.pc_register(PC),
        Size = NBits / 8,
        Type = "LDR"
        ;
        // ADR <Register> <Offset>
        substr(Operation,0,3) = "ADR",
        op_immediate(OffsetOp, Offset),
        Size = 4,
        Type = "ADR"
    ),
    instruction_get_dest_op(EA,_,RegOp),
    (
        op_regdirect_contains_reg(RegOp,Reg)
        ;
        op_regdirect(RegOp,Reg)
    ),
    !arch.pc_register(Reg),
    pc_relative_disp(EA,Disp),
    // Align the address
    EA_aligned = EA - (EA band 3),
    Addr = EA_aligned + as(Offset,address) + as(Disp,address),
    LitPoolAddr = as(Addr,address).

// VLDR: label must be aligned on a word boundary within -/+1KB of the
// current instruction.
alignment(LitPoolAddr,4):-
    litpool_ref(EA,_,LitPoolAddr,_,"LDR"),
    instruction_get_operation(EA,"VLDR"),
    instruction_get_dest_op(EA,_,DestReg),
    op_regdirect(DestReg,Reg),
    // Only align the first literal pool for consecutive pools.
    // If Dest reg is S, one word; two words otherwise.
    (
        substr(Reg,0,1) = "S", Disp = 4
        ;
        substr(Reg,0,1) != "S", Disp = 8
    ),
    (
        !litpool_ref(_,_,LitPoolAddr-Disp,_,"LDR")
        ;
        litpool_ref(EA0,_,LitPoolAddr-Disp,_,"LDR"),
        !instruction_get_operation(EA0,"VLDR")
    ).

/**
EA is the address of the adr or ldr but the double is actually read
later in the next instruction (ldrd).

Type="LDR" : Reg1 and Reg2 get the values at the LitPoolAddr
Type="ADR" : Reg1 and Reg2 get the values at the address pointed
             by the value at the LitPoolAddr
*/
.decl litpool_ref_double(EA:address, Reg1:register, Reg2:register, LitPoolAddr:address, Type:symbol)
.output litpool_ref_double

// E.g., adr r, L  or ldr r, [pc, N]
//       ldrd r1, r2, [r]
litpool_ref_double(EA,Reg1,Reg2,LitPoolAddr,Type):-
    litpool_ref(EA,Reg,LitPoolAddr,_,Type),
    next(EA,EA_ldrd),
    // LDRD Reg1, Reg2, [Reg]
    instruction(EA_ldrd,_,_,"LDRD",Op1,IndOp,Op3,_,_,_),
    op_regdirect_contains_reg(Op3,Reg1),
    op_regdirect_contains_reg(Op1,Reg2),
    op_indirect(IndOp,"NONE",Reg,"NONE",_,0,_).

data_block_candidate(LitPoolAddr,Pt_size*2):-
    arch.pointer_size(Pt_size),
    litpool_ref_double(_,_,_,LitPoolAddr,"ADR").

data_block_candidate(LitPoolAddr,Pt_size):-
    arch.pointer_size(Pt_size),
    litpool_ref(_,_,LitPoolAddr,_,"LDR").

block_points(LitPoolAddr,"data",0,Points,"arm literal pool"):-
    litpool_ref(EA,_,LitPoolAddr,_,Type),
    code_in_block_candidate_refined(EA,Block),
    (
        // Give more points in case of ldr/ldrd or adr/ldrd sequence
        litpool_ref_double(EA,_,_,LitPoolAddr,_), Type = Type,
        Block = Block, Points = 12
        ;
        !litpool_ref_double(EA,_,_,LitPoolAddr,_), Type = "LDR",
        (
            !block_is_overlapping(Block,_), Points = 9
            ;
            block_is_overlapping(Block,_), Points = 5
        )
    ).

block_points(Block,"data",0,7,"possible string"),
data_block_candidate(Block,Size):-
    ascii_string(Block,Size),
    (
        symbol(Block,_,_,_,_,_,_,_,_)
        ;
        aligned_address_in_data(_,Block)
    ).

// E.g.,
//   0:   strb r3, [r0, #53]
//   4:   ldrb r3, [r5, #1]
// The strb instruction is 4 bytes, and the higher 2 bytes happens
// to be subs instruction, so the blocks are overlapping.
// The block with strb at 0 is real and the must-through predecessor
// of the block at 4.
// Whereas, the subs block do not have any successor.
// To give more confidence to the real block with strb,
// give point 1 when one of the block has must-fallthrough
// even if the block is overlapping.
block_points(Block,"code",BlockPred,1,"must-fallthrough"):-
    block_is_overlapping(Block,"code"),
    must_fallthrough(EA,Block),
    code_in_block_candidate_refined(EA,BlockPred),
    !candidate_block_is_padding(BlockPred),
    block_is_overlapping(BlockPred,_).

symbolic_operand_candidate(EA,1,LitPoolAddr,"data"):-
    litpool_ref(EA,_,LitPoolAddr,_,"LDR").

symbolic_operand_candidate(EA,1,LitPoolAddr,"data"):-
    litpool_ref_double(EA,_,_,LitPoolAddr,_).

/**
Matches instruction patterns that access a symbol-symbol from the literal pool.

(Symbol2-Symbol1)*Scale

EA: The address of the literal pool with the symbol_minus_symbol expression
Size: The size of the symbolic expression
EA_litpool_ref: The EA referencing the literal pool (EA)
EA_def: The address associated with Symbol1
Reg: The register containing Symbol2
Type: Either "LDR" or "ADR"
*/
.decl symbol_minus_symbol_litpool_access_pattern(EA:address,Size:unsigned,Symbol1:address,Symbol2:address,Scale:unsigned,EA_litpool_ref:address,EA_def:address,Reg:register,Type:symbol)
.output symbol_minus_symbol_litpool_access_pattern

/**
    ldr reg, LitPool
...
L1: add reg, pc
...
LitPool: .word TARGET - (L1+Disp)

where Disp = 4 for Thumb mode, and 8 for ARM mode.
*/
block_needs_splitting_at(EA_add_pc),
moved_data_label(LitPoolAddr,Size,Symbol1,EA_add_pc),
symbol_minus_symbol_litpool_access_pattern(LitPoolAddr,Size,Symbol1,Symbol2,1,EA,EA_add_pc,Reg,"LDR"):-
    litpool_ref(EA,Reg,LitPoolAddr,Size,"LDR"),

    def_used(EA,Reg,EA_add_pc,_),

    // ADD <Register> PC
    // e.g., add r3, pc
    instruction_get_operation(EA_add_pc,"ADD"),
    instruction_get_op(EA_add_pc,1,PcOp),
    op_regdirect_contains_reg(PcOp,PC),
    arch.pc_register(PC),
    instruction_get_dest_op(EA_add_pc,_,DestOp),
    op_regdirect_contains_reg(DestOp,Reg),

    data_word(LitPoolAddr,Size,Diff),
    pc_relative_disp(EA_add_pc,Disp),
    Symbol1 = EA_add_pc + as(Disp,address),
    Addr2 = as(Diff,address) + Symbol1,
    Symbol2= Addr2-(Addr2 band 1).

//     ldr reg1, LitPool
// ...
//     adr reg2, Base
//     add reg1, reg2
// ...
// LitPool: .word TARGET - Base
//
// (in observed cases, LitPool == Base)
symbol_minus_symbol_litpool_access_pattern(LitPoolAddr,Size,Symbol1,Symbol2,1,EA_ldr,EA_add,Reg,"ADR"):-
    // e.g., ldr reg1, LitPool
    litpool_ref(EA_ldr,Reg,LitPoolAddr,Size,"LDR"),

    // e.g., add reg1, reg2
    def_used(EA_ldr,Reg1,EA_add,_),
    arch.reg_reg_arithmetic_operation(EA_add,Reg1,Reg1,Reg2,1,0),

    // e.g., adr reg1, Base
    def_used(EA_adr,Reg2,EA_add,_),
    litpool_ref(EA_adr,Reg2,BaseAligned,4,"ADR"),

    data_word(LitPoolAddr,Size,Diff),

    Symbol1 = as(BaseAligned,address),
    Addr2 = as(Diff,address) + Symbol1,
    Symbol2 = Addr2-(Addr2 band 1).

value_reg_edge(EA,Reg,EA,"NONE",0,as(Symbol2,number)):-
    symbol_minus_symbol_litpool_access_pattern(_,_,_,Symbol2,_,_,EA,Reg,_).

labeled_data_candidate(Symbol2),
relative_jump_table_entry_candidate(LitPoolAddr,LitPoolAddr,Size,Symbol1,Symbol2,1,0):-
    symbol_minus_symbol_litpool_access_pattern(LitPoolAddr,Size,Symbol1,Symbol2,1,_,_,_,"ADR").

/**
litpool_symbolic_operand

PC-relative symbolic operand
*/
.decl litpool_symbolic_operand(ea_litpool:address,data_access_size:unsigned,symbol1:address,symbol2:address,ea_def:address,reg_def:register,sym2_size:unsigned)
.output litpool_symbolic_operand

//  (A) ldr  reg1, LitPoolAddr1
//  (B) ldr  reg2, LitPoolAddr2
//  (C) add  reg1, pc, reg1 // reg1 is the address of symbol foo
//  (D) ldr  reg3, [reg1, reg2] // the referenced address is the address of symbol bar.
litpool_symbolic_operand(LitPoolAddr2,DataAccessSize,Symbol1,Symbol2,EA_D,Reg3,SymSize):-
    symbol_minus_symbol_litpool_access_pattern(_,_,_,Symbol1,1,_,EA_C,Reg1,_),

    def_used(EA_C,Reg1,EA_D,_),

    // (D) ldr reg3, [reg1, reg2]
    instruction_get_operation(EA_D,Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(EA_D,_,IndOp),
    instruction_get_dest_op(EA_D,_,RegOp),
    op_indirect(IndOp,"NONE",Reg1,Reg2,_,0,Bits),
    op_regdirect_contains_reg(RegOp,Reg3),
    SymSize = Bits / 8,

    def_used(EA_B,Reg2,EA_D,_),

    // (B) ldr reg2, LitPoolAddr2
    litpool_ref(EA_B,Reg2,LitPoolAddr2,_,"LDR"),

    data_word(LitPoolAddr2,DataAccessSize,Diff),
    Symbol2 = as(Diff,address) + Symbol1.

value_reg_edge(EA,Reg,EA,"NONE",0,as(Val,number)):-
    litpool_symbolic_operand(_,_,_,Symbol2,EA,Reg,Size),
    data_word(Symbol2,Size,Val).

//  => equations: [LitPoolAddr1] = foo - (C)
//                [LitPoolAddr2] = bar - foo
//
symbol_minus_symbol(LitPoolAddr2,Size,Symbol1,Symbol2,1,0):-
    litpool_symbolic_operand(LitPoolAddr2,Size,Symbol1,Symbol2,_,_,_),
    loaded_section(Beg,End,".got"),
    // Symbol2 is not in got.
    (
        Symbol2 < Beg, End = End
        ;
        Symbol2 >= End
    ),
    !relocation(LitPoolAddr2,_,_,_,_,_,_),
    (
        code(Symbol2)
        ;
        data_segment(DataBeg,DataEnd),
        Symbol2 >= DataBeg, Symbol2 < DataEnd
    ).

//  => equations: [LitPoolAddr1] = foo - (C)
//                [LitPoolAddr2] = bar(GOT) - foo => bar(GOT)
//
symbolic_expr_attribute(LitPoolAddr,"GotRelPC"),
symbolic_data(LitPoolAddr,SymSize,Got_entry):-
    litpool_symbolic_operand(LitPoolAddr,_,_,Got_entry,_,_,SymSize),
    loaded_section(GotBeg,GotEnd,".got"),
    Got_entry >= GotBeg,
    Got_entry < GotEnd,
    (
        relocation(Got_entry,RelType,Symbol,_,_,_,_),
        RelType != "RELATIVE",
        symbol(_,_,_,_,_,_,_,_,Symbol)
        ;
        symbolic_data(Got_entry,SymSize,Dest)
    ).

data_object_candidate(LitPoolAddr,Size,"symbol-symbol"):-
    symbol_minus_symbol_litpool_access_pattern(LitPoolAddr,Size,_,_,_,_,_,_,_).

must_access_data(EA,Dest):-
    litpool_ref(EA,_,Dest,_,"LDR");
    litpool_ref_double(EA,_,_,Dest,_).

instruction_get_dest_op(EA,1,Op):-
    instruction(EA,_,_,Operation,Op,_,_,_,_,_),
    contains("POP", Operation).


symbolic_expr_from_relocation(EA+1,4,Symbol,Addend,as(Dest,address)):-
    binary_type("REL"),
    (
        relocation(EA,"THM_CALL",Symbol,_,_,_,"REL");
        relocation(EA,"THM_JUMP24",Symbol,_,_,_,"REL")
    ),
    Symbol != "",
    thumb_branch_offset(EA,Offset),
    Addend = Offset + 4,
    Dest = as(EA,number)+Addend.

/**
Decode Thumb-2 encoded branch offset. Used to find REL relocation addends.

Note that this is backwards compatible with Thumb-1.
*/
.decl thumb_branch_offset(EA:address,Offset:number)
.output thumb_branch_offset

thumb_branch_offset(EA,Offset):-
    (
        relocation(EA,"THM_CALL",_,_,_,_,_);
        relocation(EA,"THM_JUMP24",_,_,_,_,_)
    ),
    data_word(EA,2,Half0),
    data_word(EA+2,2,Half1),
    UpperHalf = as(Half0,unsigned),
    LowerHalf = as(Half1,unsigned),
    Sign = (UpperHalf band (1 bshl 10)) bshr 10,
    Upper = UpperHalf band 0x3FF,
    Lower = LowerHalf band 0x7FF,
    J1 = (LowerHalf band (1 bshl 13)) bshr 13,
    J2 = (LowerHalf band (1 bshl 11)) bshr 11,
    (J1 bxor Sign = 0, I1 = 1; J1 bxor Sign != 0, I1 = 0),
    (J2 bxor Sign = 0, I2 = 1; J2 bxor Sign != 0, I2 = 0),
    Bits = (Sign bshl 24) bor (I1 bshl 23) bor (I2 bshl 22) bor (Upper bshl 12) bor (Lower bshl 1),
    // Sign-extend unsigned 25-bit value to 32 bits.
    Masked = Bits band ((bnot 1) bshr (32 - 25)),
    TopBit = as(1 bshl (25 - 1),number),
    Signed = as(Masked,number),
    (
        Signed band TopBit = 0,  Offset = Signed;
        Signed band TopBit != 0, Offset = Signed - (TopBit * 2)
    ).

impossible_jump_target(Val):-
    possible_ea(Val),
    arch.it_conditional(Val).

block_points(Block,"code",0,-5,"in the middle of IT block"):-
    code_in_block_candidate(_,Block),
    arch.it_conditional(Block).
