//===- arm32_jump_tables.dl ------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019-2022 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to detect jump-tables for ARM32
*/

/**
Represents the first entry of an ARM jump table.

Attributes:

* EA_access: address of instruction that accesses the jump table entries
* EA_jump: address of jump instruction
* RegIndex: register used for indexing into the jumptable
* Reference: relative base for offsets (if the Type is rel_*, 0 otherwise)
* TableStart: address of first table entry
* EntrySize: size of entries
* TargetAddr: resolved target of the jump
* TableLimit: first address that cannot be part of the jump table
* Type: "absolute", "rel_signed", or "rel_unsigned"
*/
.decl arm_jump_table_candidate_start(EA_access:address,EA_jump:address,RegIndex:register,Reference:address,TableStart:address,EntrySize:unsigned,TargetAddr:address,TableLimit:address,Type:symbol,Scale:unsigned,Offset:number)
.output arm_jump_table_candidate_start

/**
Represents an entry in an ARM jump table.

Attributes:

* EA_jump: address of jump instruction
* Reference: relative base for offsets (if the Type is rel_*, 0 otherwise)
* TableStart: address of first table entry
* EntryAddr: address of table entry
* EntrySize: size of entries
* TargetAddr: resolved target of the jump
* TableLimit: first address that cannot be part of the jump table
* Type: "absolute", "rel_signed", or "rel_unsigned"
*/
.decl arm_jump_table_candidate(EA_jump:address,Reference:address,TableStart:address,EntryAddr:address,EntrySize:unsigned,TargetAddr:address,TableLimit:address,Type:symbol,Scale:unsigned,Offset:number)
.output arm_jump_table_candidate

/**
Instructions in the same block as the jumptable's jump instruction.
*/
.decl arm_jump_table_block_instruction(EA:address,EA_jump:address)

arm_jump_table_block_instruction(EA_jump,EA_jump):-
    arm_jump_table_candidate_start(_,EA_jump,_,_,_,_,_,_,_,_,_).

arm_jump_table_block_instruction(Prev,EA_jump):-
    arm_jump_table_block_instruction(EA,EA_jump),
    must_fallthrough(Prev,EA).

/**
The start of the block containing the jumptable's jump instruction.

Can be used before code_in_block_candidate.
*/
.decl arm_jump_table_block_start(Block:address,EA_jump:address)

arm_jump_table_block_start(Block,EA_jump):-
    arm_jump_table_block_instruction(Block,EA_jump),
    next(Prev,Block),
    !arm_jump_table_block_instruction(Prev,EA_jump).

/**
* TableStart0: table start address (before alignment)
* TableStart: table start address (after alignment)
* TargetAddr: the absolute address at the first entry of the table
* TableLimit: table limit given the target address
*/
.decl table_start_absolute_target_addr(TableStart0:address,TableStart:address,TargetAddr:address,TableLimit:address) inline

table_start_absolute_target_addr(TableStart0,TableStart,TargetAddr,TableLimit):-
    // Tables are aligned.
    align_addr(TableStart,TableStart0),
    address_in_data(TableStart,TargetAddr),
    (
        // Jump to after the jumptable - sets a hard limit on the jumptable size.
        TargetAddr > TableStart, TableLimit = TargetAddr;
        // Jump to before the jumptable - does not restrict jumptable size.
        TargetAddr <= TableStart, TableLimit = (2 ^ 32) - 1
    ),
    !invalid(TargetAddr,_).

/**
Jump-table pattern
  [1] ldr pc, [pc, r2, lsl N]
*/
arm_jump_table_candidate_start(EA_jump,EA_jump,IndexReg,TableStart,TableStart,Size,TargetAddr,TableLimit,"absolute",1,0):-
    op_indirect_mapped(IndOp,"NONE",PC,IndexReg0,4,0,NBits),
    reg_nonnull(IndexReg0,IndexReg),
    arch.load_word_operation(Operation),
    instruction(EA_jump,InstrSize,_,Operation,IndOp,RegOp,0,0,_,_),
    arch.pc_reg(PC),
    op_regdirect_contains_reg(RegOp,PC),
    Size = NBits / 8,
    arch.pointer_size(Size),
    (
        arch.conditional(EA_jump,_),
        // If it's conditional, it is likely that there is a fall-through
        // successor consisting of one instruction (typically a jump
        // instruction)
        // Check the fall-through instruction is a jump to make sure.
        next(EA_jump,EA_fallthrough),
        arch.jump(EA_fallthrough),
        instruction(EA_fallthrough,InstrSize2,_,_,_,_,_,_,_,_),
        TableStart0 = EA_jump + as(InstrSize + InstrSize2,address)
        ;
        !arch.conditional(EA_jump,_),
        TableStart0 = EA_jump + as(InstrSize,address)
    ),
    table_start_absolute_target_addr(TableStart0,TableStart,TargetAddr,TableLimit).

/**
Jump-table pattern
  [2] adr r1, Label   or  add r1, pc, offset
      ldr pc, [r1, r2, lsl N]
*/
arm_jump_table_candidate_start(EA_jump,EA_jump,IndexReg,TableStart,TableStart,Size,TargetAddr,TableLimit,"absolute",1,0):-
    // ldr pc, [r1, r2, lsl N]
    op_indirect_mapped(IndOp,"NONE",BaseReg,IndexReg0,4,0,NBits),
    reg_nonnull(IndexReg0,IndexReg),
    arch.load_word_operation(Operation),
    instruction(EA_jump,_,_,Operation,IndOp,RegOp,0,0,_,_),
    arch.pc_reg(PC),
    op_regdirect_contains_reg(RegOp,PC),
    BaseReg != PC,
    Size = NBits / 8,
    arch.pointer_size(Size),
    // adr r1, Label
    straight_line_def_used(EA_adr,BaseReg,EA_jump,_),
    arch.pc_relative_addr(EA_adr,BaseReg,TableStart0),

    table_start_absolute_target_addr(TableStart0,TableStart,TargetAddr,TableLimit).

/**
Jump-table pattern
  [3] adr r1, Label   or  add r1, pc, offset
      ldr r0, [r1, r2, lsl N]
      mov pc, r0
*/
arm_jump_table_candidate_start(EA_ldr,EA_jump,IndexReg,0,TableStart,Size,TargetAddr,TableLimit,"absolute",1,0):-
    // mov pc, r0
    arch.pc_reg(PC),
    arch.move_reg_reg(EA_jump,PC,Rd),
    // ldr r0, [r1, r2, lsl N]
    straight_line_def_used(EA_ldr,Rd,EA_jump,_),
    instruction(EA_ldr,_,_,Operation,IndOp,RegOp,0,0,_,_),
    op_indirect_mapped(IndOp,"NONE",BaseReg,IndexReg0,4,0,NBits),
    reg_nonnull(IndexReg0,IndexReg),
    arch.load_word_operation(Operation),
    op_regdirect_contains_reg(RegOp,Rd),
    Size = NBits / 8,
    arch.pointer_size(Size),
    // adr r1, Label
    straight_line_def_used(EA_adr,BaseReg,EA_ldr,_),
    arch.pc_relative_addr(EA_adr,BaseReg,TableStart0),

    table_start_absolute_target_addr(TableStart0,TableStart,TargetAddr,TableLimit).

/**
Compute the target address for the given unsigned relative jump-table entry.

EA: An entry of a relative jump-table
Reference: The Base from which offsets are relative
Size: The size of the entry
Scale: The scale amount is multiplied to the entry value
AlignedTargetAddr: The computed target address is aligned
*/
.decl arm_rel_unsigned_jump_table_target(EA:address,Reference:address,Size:unsigned,Scale:unsigned,AlignedTargetAddr:address) inline

arm_rel_unsigned_jump_table_target(EA,Reference,Size,Scale,AlignedTargetAddr):-
    data_uword(EA,Size,Diff),
    TargetAddr = Reference + Diff * Scale,
    AlignedTargetAddr = TargetAddr - (TargetAddr band 1).

/**
Compute the target address for the given signed relative jump-table entry.

EA: An entry of a relative jump-table
Reference: The Base from which offsets are relative
Size: The size of the entry
Scale: The scale amount is multiplied to the entry value
AlignedTargetAddr: The computed target address is aligned
*/
.decl arm_rel_signed_jump_table_target(EA:address,Reference:address,Size:unsigned,Scale:unsigned,AlignedTargetAddr:address) inline

arm_rel_signed_jump_table_target(EA,Reference,Size,Scale,AlignedTargetAddr):-
    data_word(EA,Size,Diff),
    TargetAddr = as(Diff*as(Scale,number)+as(Reference,number),address),
    AlignedTargetAddr = TargetAddr - (TargetAddr band 1).

arm_jump_table_candidate_start(EA,EA,IndexReg,TableStart,TableStart,Size,TargetAddr,TableLimit,"rel_unsigned",2,0):-
    (
        Operation="TBH", Size = 2;
        Operation="TBB", Size = 1
    ),
    instruction(EA,InstrSize,_,Operation,Operand,0,0,0,_,_),
    arch.pc_reg(PC),
    op_indirect_mapped(Operand,"NONE",PC,IndexReg0,_,_,_),
    reg_nonnull(IndexReg0,IndexReg),
    TableStart = as(EA+InstrSize-1,address),
    // tbb/tbh can't perform a mode switch and just uses aligned addresses of
    // Thumb targets.
    arm_rel_unsigned_jump_table_target(TableStart,TableStart,Size,2,AlignedTargetAddr),
    TargetAddr = AlignedTargetAddr + 1,
    TableLimit = AlignedTargetAddr.

arm_jump_table_candidate_start(EA,EA,IndexReg,Reference,TableStart,Size,TargetAddr,TableLimit,"rel_unsigned",2,0):-
    (
        Operation="TBH", Size = 2;
        Operation="TBB", Size = 1
    ),
    instruction(EA,InstrSize,_,Operation,Operand,0,0,0,_,_),
    op_indirect_mapped(Operand,"NONE",BaseReg,IndexReg0,_,_,_),
    reg_nonnull(IndexReg0,IndexReg),
    Reference = as(EA+InstrSize-1,address),
    !arch.pc_reg(BaseReg),
    straight_line_def_used(EA_ldr,BaseReg,EA,_),
    arch.pointer_size(PtrSize),
    litpool_ref(EA_ldr,EA_ldr,LitPoolBase,LitPoolOffset,PtrSize,_),
    LitPoolAddr = LitPoolBase + LitPoolOffset,
    data_uword(LitPoolAddr,PtrSize,Value),
    TableStart = as(Value,address),
    // tbb/tbh can't perform a mode switch and just uses aligned addresses of
    // Thumb targets.
    arm_rel_unsigned_jump_table_target(TableStart,Reference,Size,2,AlignedTargetAddr),
    TargetAddr = AlignedTargetAddr + 1,
    // Even though jumps can only jump forward from the Reference, this jump
    // table isn't necessarily located where the limit makes sense.
    (
        // Jump to after the jumptable - sets a hard limit on the jumptable size.
        AlignedTargetAddr > TableStart, TableLimit = AlignedTargetAddr;
        // Jump to before the jumptable - does not restrict jumptable size.
        AlignedTargetAddr <= TableStart, arch.pointer_size(PtrSize), TableLimit = (2 ^ ((8*PtrSize)-1)) - 1
    ).

/**
EA:      adr r1, OffsetToTableStart    or   add r1, pc, #10
EA_ldr:  ldr r3, [r1,r2,lsl N]
EA_add   add r4, r3    or   add r4, r4, r3
EA_jump: bx r4
*/
arm_jump_table_candidate_start(EA_ldr,EA_jump,IndexReg,TableStart,TableStart,Size,TargetAddr,TableLimit,"rel_signed",1,as(EA_jump band 1,number)):-
    arch.pc_relative_addr(EA,_,TableStart0),
    next(EA,EA_ldr),
    instruction_get_operation(EA_ldr,"LDR"),
    next(EA_ldr,EA_add),
    arch.reg_reg_arithmetic_operation(EA_add,R4,R4,R3,1,0),
    next(EA_add,EA_jump),
    instruction_get_operation(EA_jump,Operation),
    substr(Operation,0,2) = "BX",

    arch.jump_operation_op_index(Operation,TargetOpIndex),
    instruction_get_op(EA_jump,TargetOpIndex,Reg4Op),
    op_regdirect_contains_reg(Reg4Op,R4),

    instruction_get_dest_op(EA_ldr,_,Reg3Op),
    op_regdirect_contains_reg(Reg3Op,R3),
    instruction_get_src_op(EA_ldr,_,IndOp),
    op_indirect_mapped(IndOp,"NONE",R1,IndexReg0,4,0,NBits),
    reg_nonnull(IndexReg0,IndexReg),
    instruction_get_dest_op(EA,_,Reg1Op),
    op_regdirect_contains_reg(Reg1Op,R1),

    Size = NBits / 8,
    arch.pointer_size(Size),

    // Tables are aligned.
    align_addr(TableStart,TableStart0),

    arm_rel_signed_jump_table_target(TableStart,TableStart,Size,1,AlignedTargetAddr),
    TargetAddr = AlignedTargetAddr + (EA_jump band 1),
    (
        // Jump to after the jumptable - sets a hard limit on the jumptable size.
        AlignedTargetAddr > TableStart, TableLimit = AlignedTargetAddr;
        // Jump to before the jumptable - does not restrict jumptable size.
        AlignedTargetAddr <= TableStart, arch.pointer_size(PtrSize), TableLimit = (2 ^ ((8*PtrSize)-1)) - (EA_jump band 1)
    ).

/**
EA:         adr r2, Label
...
EA_ldr:     ldr r1, [r1, r2]
EA_jump:    add pc, r1, r2
*/
arm_jump_table_candidate_start(EA_ldr,EA_jump,RegIndexNN,TableStart,TableStart,Size,TargetAddr,TableLimit,"rel_signed",1,0):-
    arch.pc_relative_addr(EA,_,TableStart0),
    straight_line_def_used(EA,RegBase,EA_ldr,_),
    arch.load(EA_ldr,_,_,RegLoaded,RegIndex,RegBase,1,0),
    reg_nonnull(RegIndex,RegIndexNN),
    instruction_get_src_op(EA_ldr,_,IndOp),
    op_indirect_mapped(IndOp,_,_,_,_,_,NBits),
    straight_line_def_used(EA,RegBase,EA_jump,_),
    straight_line_def_used(EA_ldr,RegLoaded,EA_jump,_),
    arch.pc_reg(PC),
    arch.reg_reg_arithmetic_operation(EA_jump,PC,RegLoaded,RegBase,1,0),

    Size = NBits / 8,
    arch.pointer_size(Size),

    // Tables are aligned.
    align_addr(TableStart,TableStart0),

    arm_rel_signed_jump_table_target(TableStart,TableStart,Size,1,AlignedTargetAddr),
    TargetAddr = AlignedTargetAddr + (EA_jump band 1),
    (
        // Jump to after the jumptable - sets a hard limit on the jumptable size.
        AlignedTargetAddr > TableStart, TableLimit = AlignedTargetAddr;
        // Jump to before the jumptable - does not restrict jumptable size.
        AlignedTargetAddr <= TableStart, arch.pointer_size(PtrSize), TableLimit = (2 ^ ((8*PtrSize)-1)) - (EA_jump band 1)
    ).

// base case
arm_jump_table_candidate(EA_jump,Reference,TableStart,TableStart,Size,TargetAddr,NewTableLimit,Type,Scale,Offset):-
    arm_jump_table_candidate_start(_,EA_jump,_,Reference,TableStart,Size,TargetAddr,NewTableLimit,Type,Scale,Offset),
    // We check this here so `arm_jump_table_candidate_start` is not recursive
    // and `arm_jump_table_candidate_start` is not recomputed for every new `code_in_block_candidate`.
    instruction(TargetAddr,_,_,_,_,_,_,_,_,_),
    !invalid(TargetAddr,_).

// recursive case
arm_jump_table_candidate(EA_jump,Reference,TableStart,EA+Size,Size,TargetAddr,NewTableLimit,Type,Scale,Offset):-
    arm_jump_table_candidate(EA_jump,Reference,TableStart,EA,Size,_,TableLimit,Type,Scale,Offset),
    !defined_symbol(EA+Size,_,_,_,_,_,_,_,"$t"),
    !defined_symbol(EA+Size,_,_,_,_,_,_,_,"$a"),
    EA+Size < TableLimit,
    (
        Type = "absolute",
        address_in_data(EA+Size,TargetAddr),
        AlignedTargetAddr = TargetAddr - (TargetAddr band 1),
        UNUSED(Reference)
        ;
        Type = "rel_unsigned",
        arm_rel_unsigned_jump_table_target(EA+Size,Reference,Size,Scale,AlignedTargetAddr),
        TargetAddr = AlignedTargetAddr + (EA_jump band 1)
        ;
        Type = "rel_signed",
        arm_rel_signed_jump_table_target(EA+Size,Reference,Size,Scale,AlignedTargetAddr),
        TargetAddr = AlignedTargetAddr + (EA_jump band 1)
    ),
    instruction(TargetAddr,_,_,_,_,_,_,_,_,_),
    !invalid(TargetAddr,_),
    (
        // The target address is less than the limit, but at some address beyond
        // the current entry. Limit the table size to that target.
        AlignedTargetAddr < TableLimit, AlignedTargetAddr > EA+Size, NewTableLimit = AlignedTargetAddr
        ;
        // The target address points at or before the current jump table entry.
        // Gives us no info about the table size - keep propagating.
        AlignedTargetAddr < TableLimit, AlignedTargetAddr <= EA+Size, NewTableLimit = TableLimit
        ;
        // The target address points beyond our current limit - keep propagating.
        AlignedTargetAddr >= TableLimit, NewTableLimit = TableLimit
    ),
    // Target address cannot be within the table itself
    (
        TargetAddr < TableStart
        ;
        TargetAddr >= NewTableLimit
    ).

/**
The value compared against just before entering the jumptable's block.

This is typically the number of jumptable entries, so we use it to create one
big data block instead of smaller ones. We prefer this if we can identify the
comparison, because it's a definitive limit on the jumptable size.
*/
.decl arm_jump_table_cmp_limit(Jmp:address,TableStart:address,Count:number)
.output arm_jump_table_cmp_limit

arm_jump_table_cmp_limit(Jmp,TableStart,Immediate+Offset+1):-
    arm_jump_table_candidate_start(_,Jmp,IndexReg,_,TableStart,_,_,_,_,_,_),
    arm_jump_table_block_start(Block,Jmp),
    may_fallthrough(CondJmp,Block),
    arch.jump(CondJmp),
    arch.conditional(CondJmp,CC),
    must_fallthrough(Cmp,CondJmp),
    cmp_immediate_to_reg(Cmp,IndexReg,_,Immediate),
    limit_type_map(CC,_,"MAX",_,Offset).

// In some cases, the value is saved to the stack before the branch, and loaded
// into a different register for use as the index
// (from arm.ubuntu20.vim.clang.O0.nopie.nostrip.elf):
//            str r0, [sp, #316]
//            cmp r0, #181
//            bhi .L_1fdfbc
//            ldr r1, [sp, #316]
//            adr r0, .L_1fb360
//            ldr r0, [r0, r1, LSL 2]
//            mov pc, r0
arm_jump_table_cmp_limit(Jmp,TableStart,Immediate+Offset+1):-
    arm_jump_table_candidate_start(TableLdr,Jmp,JmpIndexReg,_,TableStart,_,_,_,_,_,_),
    arm_jump_table_block_start(Block,Jmp),
    may_fallthrough(CondJmp,Block),
    arch.jump(CondJmp),
    arch.conditional(CondJmp,CC),
    limit_type_map(CC,_,"MAX",_,Offset),
    must_fallthrough(Cmp,CondJmp),
    cmp_immediate_to_reg(Cmp,CmpIndexReg,_,Immediate),
    // JmpIndexReg is loaded from stack
    straight_line_def_used(IndexLdr,JmpIndexReg,TableLdr,_),
    arch.load(IndexLdr,_,_,JmpIndexReg,BaseReg,"NONE",_,StackPos),
    arch.stack_pointer(BaseReg),
    // CmpIndexReg is stored to the same stack location
    straight_line_def_used(Def,CmpIndexReg,Cmp,_),
    straight_line_def_used(Def,CmpIndexReg,Str,_),
    arch.store(Str,_,_,CmpIndexReg,BaseReg,"NONE",_,StackPos).

/**
Addresses at which jump table data blocks should be split
*/
.decl arm_jump_table_data_block_limit(EA_jmp:address,TableStart:address,Limit:address)

// Generate a single block with the cmp-derived limit, if we have one.
arm_jump_table_data_block_limit(EA_jmp,TableStart,TableStart+as(Count,unsigned)*Size):-
    arm_jump_table_candidate(EA_jmp,_,TableStart,_,Size,_,_,_,_,_),
    arm_jump_table_cmp_limit(EA_jmp,TableStart,Count).

// If we're not using a cmp-derived limit, the last propagated entry is the last limit.
arm_jump_table_data_block_limit(EA_jmp,TableStart,Limit):-
    arm_jump_table_candidate(EA_jmp,_,TableStart,EA_last,Size,_,_,_,_,_),
    !arm_jump_table_cmp_limit(EA_jmp,TableStart,_),
    !arm_jump_table_candidate(EA_jmp,_,TableStart,EA_last+Size,Size,_,_,_,_,_),
    Limit = EA_last+Size.

// If we're not using a cmp-derived limit, add intermediate limits where
// overlapping blocks might start: direct jump targets and other jump tables.
arm_jump_table_data_block_limit(EA_jmp,TableStart,EA):-
    arm_jump_table_candidate(EA_jmp,_,TableStart,EA,_,_,_,_,_,_),
    !arm_jump_table_cmp_limit(EA_jmp,TableStart,_),
    // Don't generate a limit at TableStart - the jumptable must have at least
    // one entry.
    TableStart != EA,
    arch.instruction_at(EA,Inst),
    (
        direct_jump(_,Inst);
        arm_jump_table_candidate(_,_,_,_,_,Inst,_,_,_,_)
    ).

// Another potential jumptable starts at EA
arm_jump_table_data_block_limit(EA_jmp,TableStart,NextTableStart):-
    arm_jump_table_candidate(EA_jmp,_,TableStart,NextTableStart,_,_,_,_,_,_),
    TableStart != NextTableStart,
    arm_jump_table_candidate_start(_,_,_,_,NextTableStart,_,_,_,_,_,_).

/**
Generate data block candidates for the jump table entries.
We try to generate one big block, but split it at any possible jump target.
This allows the block_points rules to decide whether the conflicts are data
or code.
*/
.decl arm_jump_table_data_block(EA_jmp:address,TableStart:address,Block:address,Size:address)

// First data block - should exist if the jumping block does.
arm_jump_table_data_block(EA_jmp,TableStart,TableStart,Limit-TableStart):-
    arm_jump_table_candidate_start(_,EA_jmp,_,_,TableStart,_,_,_,_,_,_),
    Limit = min Limit : {
        arm_jump_table_data_block_limit(EA_jmp,TableStart,Limit)
    }.

// Subsequent possible data blocks
arm_jump_table_data_block(EA_jmp,TableStart,Limit1,Size):-
    arm_jump_table_data_block_limit(EA_jmp,TableStart,Limit1),
    Limit2 = min Limit2 : {
        arm_jump_table_data_block_limit(EA_jmp,TableStart,Limit2),
        Limit2 > Limit1
    },
    Size = Limit2-Limit1.

data_block_candidate(Block,Size):-
    arm_jump_table_data_block(_,_,Block,Size).

jump_table_candidate(EA,DataEA,TargetEA):-
    arm_jump_table_candidate(EA,_,_,DataEA,_,TargetEA,_,_,_,_).

data_object_point(DataEA,Size,"symbol",2,"arm jump-table3"),
data_object_candidate(DataEA,Size,"symbol"):-
    arm_jump_table_data_block(EA_jmp,TableStart,Block,BlockSize),
    arm_jump_table_candidate(EA_jmp,_,TableStart,DataEA,Size,_,_,"absolute",_,_),
    Block <= DataEA, DataEA+Size <= Block+BlockSize.

data_object_point(DataEA,Size,"symbol-symbol",2,"arm jump-table3"),
data_object_candidate(DataEA,Size,"symbol-symbol"):-
    arm_jump_table_data_block(EA_jmp,TableStart,Block,BlockSize),
    arm_jump_table_candidate(EA_jmp,_,TableStart,DataEA,Size,_,_,Type,_,_),
    Block <= DataEA, DataEA+Size <= Block+BlockSize,
    (
        Type = "rel_unsigned";
        Type = "rel_signed"
    ).

jump_table_start(EA,Size,TableStart,Reference,1):-
    arm_jump_table_candidate(EA,Reference,TableStart,DataEA,Size,_,_,_,_,_),
    jump_table_candidate_refined(EA,DataEA,_).

relative_jump_table_entry_candidate(TableStart,TableStart,Size,Reference,TargetAddr,as(Scale,number),Offset):-
    arm_jump_table_candidate_start(_,EA,_,Reference,TableStart,Size,_,_,_,Scale,Offset),
    arm_jump_table_candidate(EA,Reference,TableStart,TableStart,Size,_,_,_,Scale,Offset),
    jump_table_candidate_refined(EA,TableStart,TargetAddr).

relative_jump_table_entry_candidate(DataEA,TableStart,Size,Reference,TargetAddr,Scale,Offset):-
    // ensure the previous entry is a candidate.
    relative_jump_table_entry_candidate(PrevDataEA,TableStart,Size,Reference,_,Scale,Offset),
    DataEA = PrevDataEA + Size,
    arm_jump_table_candidate(EA,Reference,TableStart,DataEA,Size,_,_,_,as(Scale,unsigned),Offset),
    jump_table_candidate_refined(EA,DataEA,TargetAddr).
