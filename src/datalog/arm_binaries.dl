//===- arm_binaries.dl --------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2020 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to abstract from ARM specific instruction set
and characteristics
*/

split_load(EA, NextEA, as(Base + Offset,address), "ADD") :-
    // ADRP <Register> <Immediate>
    // e.g. adrp x0, BaseOp
    instruction_get_operation(EA, "ADRP"),
    instruction_get_op(EA, 1, BaseOp),
    op_immediate(BaseOp, Base),

    next(EA, NextEA),

    // ADD <Register> <Register> <Immediate>
    // e.g. add x0, x0, <OffsetOp>
    instruction_get_operation(NextEA, "ADD"),
    instruction_get_op(NextEA, 2, OffsetOp),
    op_immediate(OffsetOp, Offset).

split_load(EA, NextEA, as(Base + Offset,address), "LDR") :-
    // ADRP <Register> <Immediate>
    // e.g. adrp x0, BaseOp
    instruction_get_operation(EA, "ADRP"),
    instruction_get_op(EA, 1, BaseOp),
    op_immediate(BaseOp, Base),

    next(EA, NextEA),

    // LDR <Register> <IndirectOp>
    // e.g. ldr x0, [x0, <OffsetOp>]
    instruction_get_operation(NextEA, "LDR"),
    instruction_get_op(NextEA, 1, OffsetOp),
    op_indirect(OffsetOp, "NONE", _, "NONE", 1, Offset, _).

pc_relative_operand(EA, 1, as(Dest,address)) :-
    split_load(EA, _, Dest, _).

pc_relative_operand(EA, 2, as(Dest,address)) :-
    split_load(_, EA, Dest, _).

pc_relative_jump(EA, as(Dest,address)):-
    split_load(EA, _, Dest, "LDR").


symbol_prefix(ea, 1, ":got:") :-
    split_load(ea, _, Dest, "LDR"),
    relocation(Dest, "GLOB_DAT", _, _).

symbol_prefix(ea, 1, ":got_lo12:") :-
    split_load(_, ea, Dest, "LDR"),
    relocation(Dest, "GLOB_DAT", _, _).

symbol_prefix(ea, 2, ":lo12:") :-
    split_load(_, ea, Dest, "ADD"),
    !relocation(as(Dest,address), "GLOB_DAT", _, _).


basic_target(Val+1):-
    binary_isa("ARM"),
    defined_symbol(Val,_,_,_,_,"$t").
basic_target(Val):-
    binary_isa("ARM"),
    defined_symbol(Val,_,_,_,_,"$a").


block_points(Block,0,-9,"overlap with literal pool"),
block_is_overlapping(Block):-
    binary_isa("ARM"),
    block_candidate_boundaries(Block,BlockBegAddr,BlockEndAddr),
    defined_symbol(Val,_,_,_,_,"$d"),
    BlockBegAddr <= Val, Val< BlockEndAddr.

plt_entry(EA,Function):-
    binary_isa("ARM"),
    plt_section(SecName),
    section(SecName,Size,Beg),
    EA < Beg+Size,
    EA >= Beg,
    arch.jump(EA),
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_, _, _,_, Offset, _),
    Got_entry = as(as(65536+ EA,number) + Offset, address),
    relocation(Got_entry,_,Function,_).

symbolic_operand_candidate(EA,Op_index,Dest,Type),
symbolic_operand_candidate(EA2,Op_index2,Dest,Type):-
    binary_isa("ARM"),
    code(EA),
    next(EA,EA2),
    code(EA2),
    instruction_get_operation(EA,"MOVW"),
    instruction_get_operation(EA2,"MOVT"),
    instruction_get_op(EA,Op_index,Op),
    op_immediate(Op,DestLow),
    instruction_get_op(EA2,Op_index2,Op2),
    op_immediate(Op2,DestHigh),
    Dest = as((DestHigh*2^16) bor DestLow, address),
  (
        code(Dest), Type="code"
        ;
        data_segment(Begin,End),
        Dest >= Begin, Dest <= End,
        Type = "data"
    ).

symbol_minus_symbol_candidate(Addr,Size,EARef,Dest,"no_table",Scale):-
    binary_isa("ARM"),
    data_access_pattern(Addr,Size,0,EABase),
    def_used(EABase,Reg,EAAddPC,_),
    arch.reg_reg_arithmetic_operation(EAAddPC,Reg,Reg,PC,1,0),
    arch.pc_register(PC),

    EARef = EAAddPC + 4,
    data_word(Addr,Size,Diff),
    Dest = as(as(EARef,number) + Diff, address) - (EAAddPC band 1),

    data_segment(Begin,End),
    Dest >= Begin, Dest <= End,
    Scale = 1.
