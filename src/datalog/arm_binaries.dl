//===- arm_binaries.dl --------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2020 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to abstract from ARM specific instruction set
and characteristics
*/

// Compute an immediate load performed across two consecutive instructions
.decl split_load(ea:address, nextea:address, dest:address, type:symbol)
.output split_load

split_load(EA, NextEA, as(Base + Offset,address), "ADD") :-
    // ADRP <Register> <Immediate>
    // e.g. adrp x0, BaseOp
    instruction_get_operation(EA, "ADRP"),
    instruction_get_op(EA, 1, BaseOp),
    op_immediate(BaseOp, Base),

    next(EA, NextEA),

    // ADD <Register> <Register> <Immediate>
    // e.g. add x0, x0, <OffsetOp>
    instruction_get_operation(NextEA, "ADD"),
    instruction_get_op(NextEA, 2, OffsetOp),
    op_immediate(OffsetOp, Offset).

split_load(EA, NextEA, as(Base + Offset,address), "LDR") :-
    // ADRP <Register> <Immediate>
    // e.g. adrp x0, BaseOp
    instruction_get_operation(EA, "ADRP"),
    instruction_get_op(EA, 1, BaseOp),
    op_immediate(BaseOp, Base),

    next(EA, NextEA),

    // LDR <Register> <IndirectOp>
    // e.g. ldr x0, [x0, <OffsetOp>]
    instruction_get_operation(NextEA, Operation),
    arch.ldr_operation(Operation),
    instruction_get_op(NextEA, 1, OffsetOp),
    op_indirect(OffsetOp, "NONE", _, "NONE", 1, Offset, _).

pc_relative_operand(EA, 1, as(Dest,address)) :-
    split_load(EA, _, Dest, _).

pc_relative_operand(EA, 2, as(Dest,address)) :-
    split_load(_, EA, Dest, _).

pc_relative_jump(EA, as(Dest,address)):-
    split_load(EA, _, Dest, "LDR").

symbolic_operand_attribute(ea, 1, "GotRef") :-
    split_load(ea, _, Dest, "LDR"),
    relocation(Dest, "GLOB_DAT", _, _).

symbolic_operand_attribute(ea, 1, ":got_lo12:") :-
    split_load(_, ea, Dest, "LDR"),
    relocation(Dest, "GLOB_DAT", _, _).

symbolic_operand_attribute(ea, 2, ":lo12:") :-
    split_load(_, ea, Dest, "ADD"),
    !relocation(as(Dest,address), "GLOB_DAT", _, _).


basic_target(Val+1):-
    binary_isa("ARM"),
    defined_symbol(Val,_,_,_,_,_,_,"$t").
basic_target(Val):-
    binary_isa("ARM"),
    defined_symbol(Val,_,_,_,_,_,_,"$a").


block_points(Block,0,-9,"overlap with literal pool"),
block_is_overlapping(Block):-
    binary_isa("ARM"),
    block_candidate_boundaries(Block,BlockBegAddr,BlockEndAddr),
    defined_symbol(Val,_,_,_,_,_,_,"$d"),
    BlockBegAddr <= Val, Val< BlockEndAddr.

plt_entry(EA,Function):-
    binary_isa("ARM"),
    plt_section(SecName),
    section(SecName,Size,Beg),
    EA < Beg+Size,
    EA >= Beg,
    arch.jump(EA),
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_, _, _,_, Offset, _),
    Got_entry = as(as(65536+ EA,number) + Offset, address),
    relocation(Got_entry,_,Function,_).

// E.g.,
//   add ip, pc, #0, #12
//   add ip, ip, #16, #20
//   ldr pc, [ip, #2640]
plt_entry(EA,Function):-
    plt_entry_arm_candidate(EA,Function,_).

// E.g.,
//   bx pc // thumb
//   b.n XXX // thumb
//   add ip, pc, #0, #12
//   add ip, ip, #16, #20
//   ldr pc, [ip, #2640]
plt_entry(EA0,Function):-
    plt_entry_arm_candidate(EA,Function,_),
    instruction_get_operation(EA-3,Operation2), // thumb
    arch.jump_operation_op_index(Operation2,TargetOpIndex),
    instruction_get_op(EA-3,TargetOpIndex,TargetOp),
    op_regdirect_contains_reg(TargetOp,PC),
    arch.pc_register(PC),
    EA0 = EA-3.

.decl plt_entry_arm_candidate(ea:address, function:symbol, reloc_ea:address)
.output plt_entry_arm_candidate

// E.g.,
//   add ip, pc, #0, #12
//   add ip, ip, #16, #20
//   ldr pc, [ip, #2640]
plt_entry_arm_candidate(EA,Function,as(Dest,address)):-
    plt_section(SecName),
    section(SecName,Size,Beg),
    EA < Beg+Size,
    EA >= Beg,

    arch.pc_register(PC),

    // add ip, pc, #0, #12
    arch.reg_reg_arithmetic_operation(EA,Reg,PC,"NONE",1,N1),
    next(EA, NextEA),

    // add ip, ip, #16, #20
    // or
    // add ip, ip, #XXXX
    arch.reg_reg_arithmetic_operation(NextEA,Reg,Reg,"NONE",1,N2),
    next(NextEA, NextEA2),

    instruction_get_operation(NextEA2,Operation),
    arch.ldr_operation(Operation),
    instruction_get_src_op(NextEA2,_,OffsetOp),
    op_indirect(OffsetOp,"NONE",Reg,"NONE",_,Offset,_),
    instruction_get_dest_op(NextEA2,_,RegOp),
    op_regdirect_contains_reg(RegOp,PC),

    Dest = as(EA,number) + N1 + N2 + Offset + 8,
    relocation(as(Dest,address),_,Function,_).

symbolic_operand_candidate(EA,Op_index,Dest,Type),
symbolic_operand_candidate(EA2,Op_index2,Dest,Type):-
    binary_isa("ARM"),
    code(EA),
    next(EA,EA2),
    code(EA2),
    instruction_get_operation(EA,"MOVW"),
    instruction_get_operation(EA2,"MOVT"),
    instruction_get_op(EA,Op_index,Op),
    op_immediate(Op,DestLow),
    instruction_get_op(EA2,Op_index2,Op2),
    op_immediate(Op2,DestHigh),
    Dest = as((DestHigh*2^16) bor DestLow, address),
    (
        code(Dest), Type="code"
        ;
        data_segment(Begin,End),
        Dest >= Begin, Dest <= End,
        Type = "data"
    ).

symbolic_operand_candidate(EA,1,Dest,Type):-
    // ADRP <Register> <Immediate>
    // e.g. adr r1, BaseOp
    instruction_get_operation(EA, "ADR"),
    instruction_get_op(EA, 1, OffsetOp),
    op_immediate(OffsetOp, Offset),
    (
        // ARM
        (EA band 3) = 0, Disp = 8
        ;
        // Thumb
        (EA band 3) != 0, Disp = 4
    ),
    Dest = as(as(EA-(EA band 3),number)+Offset+Disp,address),
    (
        code(Dest), Type="code"
        ;
        data_segment(Begin,End),
        Dest >= Begin, Dest <= End,
        Type = "data"
    ).

symbol_minus_symbol_jump_table(Addr,Addr,Size,EARef,Dest,"no_table",Scale):-
    binary_isa("ARM"),
    data_access_pattern(Addr,Size,0,EABase),
    def_used(EABase,Reg,EAAddPC,_),
    arch.reg_reg_arithmetic_operation(EAAddPC,Reg,Reg,PC,1,0),
    arch.pc_register(PC),

    EARef = EAAddPC + 4,
    data_word(Addr,Size,Diff),
    Dest = as(as(EARef,number) + Diff, address) - (EAAddPC band 1),

    data_segment(Begin,End),
    Dest >= Begin, Dest <= End,
    Scale = 1.

block_needs_splitting_at(Symbol2_adjusted),
symbol_minus_symbol_jump_table(TableStart,TableStart,Size,Symbol1,Symbol2_adjusted,Reference,Scale):-
    instruction(EA,InstrSize,_,Operation,_,0,0,0,0,0,0,0,0,_,_),
    TableStart = as((EA-(EA band 3))+InstrSize,address),
    Symbol1 = TableStart,
    (
        Size = 2,
        data_word(TableStart,Size,DiffUnsigned),
        Operation="TBH",
        Reference="tbh"
        ;
        Size = 1,
        data_byte(TableStart,DiffUnsigned),
        Operation="TBB",
        Reference="tbb"
    ),
    !code(TableStart),
    Diff = as(DiffUnsigned,number),
    Symbol2 = as(Diff*2+as(Symbol1,number),address),
    Scale = 2,
    (
        code(Symbol2), Symbol2_adjusted = Symbol2 // ARM
        ;
        code(Symbol2+1), Symbol2_adjusted = Symbol2+1 // Thumb
    ).

block_needs_splitting_at(Symbol2_adjusted),
symbol_minus_symbol_jump_table(EA+Size,TableStart,Size,Symbol1,Symbol2_adjusted,Reference,Scale):-
    symbol_minus_symbol_jump_table(EA,TableStart,Size,Symbol1,_,Reference,Scale),
    !possible_data_limit(EA+Size),
    last_data_limit(EA+Size,LastDataLimit),LastDataLimit <= EA,
    (
        Size = 2,
        data_word(EA+Size,Size,DiffUnsigned),
        Reference="tbh"
        ;
        Size = 1,
        data_byte(EA+Size,DiffUnsigned),
        Reference="tbb"
    ),
    !code(EA+Size),
    Diff = as(DiffUnsigned,number),
    Symbol2 = as(Diff*2+as(Symbol1,number),address),
    Scale = 2,
    (
        code(Symbol2), Symbol2_adjusted = Symbol2 // ARM
        ;
        code(Symbol2+1), Symbol2_adjusted = Symbol2+1 // Thumb
    ).

.decl arm_jump_table(EA_jump:address,Size:unsigned,TableStart:address)
.output arm_jump_table

discarded_block(TableStart),
data_in_code(TableStart,TableStart+Size),
block_needs_splitting_at(as(TargetAddr,address)),
data_object_point(TableStart,Size,"symbol",2,"arm jump-table"),
data_object_candidate(TableStart,Size,"symbol"),
arm_jump_table(EA_jump,Size,TableStart):-
    instruction_get_operation(EA_jump,Operation),
    arch.ldr_operation(Operation),
    arch.pc_register(PC),
    instruction_get_dest_op(EA_jump,_,RegOp),
    op_regdirect(RegOp,PC),
    instruction_get_src_op(EA_jump,_,IndOp),
    op_indirect(IndOp,"NONE",PC,Reg,Mult,Offset,NBits),
    // TODO: Do we need contraints? Mult=4, Offset=0
    Reg = Reg, Mult = Mult, Offset = Offset, // to avoid warnings
    Size = NBits / 8,
    (
        Operation != substr(Operation,0,3), // Conditional
        TableStart = EA_jump + 8
        ;
        Operation = substr(Operation,0,3),
        TableStart = EA_jump + 4
    ),
    //!code(TableStart),
    data_word(TableStart,Size,TargetAddr).

block_needs_splitting_at(as(TargetAddr,address)),
data_object_point(EA+Size,Size,"symbol",2,"arm jump-table2"),
data_object_candidate(EA+Size,Size,"symbol"),
arm_jump_table(EA_jump,Size,EA+Size):-
    arm_jump_table(EA_jump,Size,EA),
    !possible_data_limit(EA+Size),
    last_data_limit(EA+Size,LastDataLimit),LastDataLimit <= EA,
    //!code(EA+Size),
    data_word(EA+Size,Size,TargetAddr).

.decl litpool_ref(ea:address, register_name:register, ea_litpool:address, nbits:unsigned)

block_points(LitPoolAddr,0,-9,"arm literal pool"), // ARM
block_is_overlapping(LitPoolAddr),
block_points(LitPoolAddr+1,0,-9,"arm literal pool"), // Thumb
block_is_overlapping(LitPoolAddr+1),
litpool_ref(EA,Reg,LitPoolAddr,NBits):-
    // LDR <Register> <IndirectOp>
    // e.g., ldr r3, [pc, Offset]
    instruction_get_operation(EA,Operation),
    arch.ldr_operation(Operation),
    instruction_get_src_op(EA,_,OffsetOp),
    op_indirect(OffsetOp,"NONE",PC,"NONE",_,Offset,NBits),
    arch.pc_register(PC),
    instruction_get_dest_op(EA,_,RegOp),
    op_regdirect(RegOp,Reg),
    (
        // ARM
        (EA band 3) = 0, Disp = 8
        ;
        // Thumb
        (EA band 3) != 0, Disp = 4
    ),
    LitPoolAddr = as(as(EA-(EA band 3),number)+Offset+Disp,address).

symbolic_operand_candidate(EA,1,LitPoolAddr,"data"):-
    litpool_ref(EA,_,LitPoolAddr,_).

.decl symbol_minus_symbol_candidate(ea:address,size:unsigned,symbol1:address,symbol2:address,scale:unsigned,ea_litpool_ref:address,ea_add_pc:address,reg:register)
.output symbol_minus_symbol_candidate

//     ldr reg, LitPool
// ...
// L1: add reg, pc
// ...
// LitPool: .word TARGET - (L1+4)
//
block_needs_splitting_at(EA_add_pc),
moved_data_label(LitPoolAddr,Size,Symbol1,EA_add_pc),
symbol_minus_symbol_candidate(LitPoolAddr,Size,Symbol1,Symbol2,1,EA,EA_add_pc,Reg):-
    litpool_ref(EA,Reg,LitPoolAddr,NBits),
    Size = NBits/8,

    def_used(EA,Reg,EA_add_pc,_),

    // ADD <Register> PC
    // e.g., add r3, pc
    instruction_get_operation(EA_add_pc,"ADD"),
    instruction_get_op(EA_add_pc,1,PcOp),
    op_regdirect(PcOp,PC),
    arch.pc_register(PC),
    instruction_get_dest_op(EA_add_pc,_,DestOp),
    op_regdirect(DestOp,Reg),

    data_word(LitPoolAddr,Size,Diff),
    Symbol1 = EA_add_pc+4,
    Addr2 = as(Diff,address) + Symbol1,
    Symbol2= Addr2-(Addr2 band 1).

symbol_minus_symbol(LitPoolAddr,Size,Symbol1,Symbol2,1):-
    symbol_minus_symbol_candidate(LitPoolAddr,Size,Symbol1,Symbol2,1,_,_,_).

.decl litpool_symbolic_operand(ea_litpool:address,size:unsigned,symbol1:address,symbol2:address)

//  (A) ldr  reg1, LitPoolAddr1
//  (B) ldr  reg2, LitPoolAddr2
//  (C) add  reg1, pc, reg1 // reg1 is the address of symbol foo
//  (D) ldr  reg3, [reg1, reg2] // the referenced address is the address of symbol bar.
block_needs_splitting_at(EA_C),
litpool_symbolic_operand(LitPoolAddr2,Size,Symbol1,Symbol2):-
    symbol_minus_symbol_candidate(_,_,_,Symbol1,1,_,EA_C,Reg1),

    def_used(EA_C,Reg1,EA_D,_),

    // (D) ldr reg3, [reg1, reg2]
    instruction_get_operation(EA_D,Operation),
    arch.ldr_operation(Operation),
    instruction_get_src_op(EA_D,_,IndOp),
    op_indirect(IndOp,"NONE",Reg1,Reg2,_,0,_),

    def_used(EA_B,Reg2,EA_D,_),

    // (B) ldr reg2, LitPoolAddr2
    litpool_ref(EA_B,Reg2,LitPoolAddr2,_),

    data_word(LitPoolAddr2,Size,Diff),
    Symbol2 = as(Diff,address) + Symbol1.

//  => equations: [LitPoolAddr1] = foo - (C)
//                [LitPoolAddr2] = bar - foo
//
symbol_minus_symbol(LitPoolAddr2,Size,Symbol1,Symbol2,1):-
    litpool_symbolic_operand(LitPoolAddr2,Size,Symbol1,Symbol2),
    !got_reference(Symbol2,_).

//  => equations: [LitPoolAddr1] = foo - (C)
//                [LitPoolAddr2] = bar(GOT) - foo => bar(GOT)
//
symbolic_data_attribute(LitPoolAddr,"GotRelPC"),
got_reference(Got_entry,Symbol),
symbolic_data(LitPoolAddr,Size,Got_entry):-
    litpool_symbolic_operand(LitPoolAddr,Size,_,Got_entry),
    section(".got",GotSize,GotBeg),
    Got_entry >= GotBeg,
    Got_entry < GotBeg+GotSize,
    (
        relocation(Got_entry,RelType,Symbol,_),
        RelType != "RELATIVE",
        symbol(_,_,_,_,_,_,_,Symbol)
        ;
        symbolic_data(Got_entry,Size,Dest),
        symbol(Dest,_,_,_,_,_,_,Symbol)
    ).
