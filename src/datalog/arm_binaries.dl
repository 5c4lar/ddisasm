//===- arm_binaries.dl --------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019-2022 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to abstract from ARM specific instruction set
and characteristics
*/

// Compute an immediate load performed across two consecutive instructions
.decl split_load(ea:address, nextea:address, dest:address, type:symbol)
.output split_load

// E.g., adrp x0, L1
//       add x0, x0, :lo12:L1
split_load(EA, NextEA, as(Base + Offset,address), "ADD") :-
    // ADRP <Register> <Immediate>
    // e.g. adrp x0, BaseOp
    instruction_get_operation(EA, "ADRP"),
    instruction_get_op(EA, 1, BaseOp),
    op_immediate(BaseOp, Base),
    instruction_get_op(EA, 2, RegOp),
    op_regdirect_contains_reg(RegOp,Reg),

    // NOTE: Can't use def_used due to cyclic negation issue.
    //       This is a heuristic to look at next one or two instruction(s)
    //       to find ADD instruction.
    (
        next(EA, NextEA)
        ;
        next(EA, NextEA0), next(NextEA0, NextEA),
        instruction_get_dest_op(NextEA0,_,TmpOp),
        !op_regdirect_contains_reg(TmpOp,Reg)
    ),

    // ADD <Register> <Register> <Immediate>
    // e.g. add x0, x0, <OffsetOp>
    instruction_get_operation(NextEA, "ADD"),
    instruction_get_op(NextEA, 2, OffsetOp),
    op_immediate(OffsetOp, Offset),
    instruction_get_op(NextEA, 1, RegOp2),
    op_regdirect_contains_reg(RegOp2,Reg2),
    // Make sure the registers match
    Reg = Reg2.

// E.g., adrp x0, L1
//       ldr x0, [x0,:lo12:L1]
split_load(EA, NextEA, as(Base + Offset,address), "LDR/STR") :-
    // ADRP <Register> <Immediate>
    // e.g. adrp x0, BaseOp
    instruction_get_operation(EA, "ADRP"),
    instruction_get_op(EA, 1, BaseOp),
    op_immediate(BaseOp, Base),
    instruction_get_op(EA, 2, RegOp),
    op_regdirect_contains_reg(RegOp,Reg),

    // NOTE: Can't use def_used due to cyclic negation issue.
    //       This is a heuristic to look at next one or two instruction(s)
    //       to find LDR or STR instruction.
    (
        next(EA,NextEA)
        ;
        next(EA,NextEA0), next(NextEA0,NextEA),
        NextEA0 != NextEA,
        instruction_get_dest_op(NextEA0,_,TmpOp),
        !op_regdirect_contains_reg(TmpOp,Reg)
    ),

    // LDR/STR <Register> <IndirectOp>
    // e.g. ldr x0, [x0, <OffsetOp>]
    instruction_get_operation(NextEA, Operation),
    (
        arch.load_operation(Operation)
        ;
        arch.store_operation(Operation)
    ),
    instruction_get_op(NextEA, 1, OffsetOp),
    op_indirect(OffsetOp,"NONE",Reg2,"NONE",_,Offset,_),
    // Make sure the registers match
    Reg = Reg2.

pc_relative_operand(EA,Index,as(as(EANext,number)+Offset,address)):-
    instruction_get_op(EA, Index, Op),
    op_indirect(Op,"NONE",Reg,"NONE",1,Offset,_),
    arch.pc_register(Reg),
    (
        (EA band 1) = 0,  Disp = 8 // ARM mode
        ;
        (EA band 1) != 0, Disp = 4 // Thumb mode
    ),
    EANext0 = as(EA,number)+as(Disp,number),
    // Align the address
    EANext = EANext0-(EANext0 band 3).

pc_relative_jump(EA, as(Dest,address)):-
    split_load(EA, _, Dest, "LDR/STR").

// This version of split_load uses def_used, so this should not be used for
// the code inference step due to cyclic negation issue.
// Instead, this is for the symbolization step.
.decl split_load_for_symbolization(ea:address, nextea:address, dest:address, type:symbol)
.output split_load_for_symbolization

split_load_for_symbolization(EA, NextEA, as(Base + Offset,address), "ADD") :-
    // ADRP <Register> <Immediate>
    // e.g. adrp x0, BaseOp
    instruction_get_operation(EA, "ADRP"),
    instruction_get_op(EA, 1, BaseOp),
    op_immediate(BaseOp, Base),

    def_used(EA,_,NextEA,_),

    // ADD <Register> <Register> <Immediate>
    // e.g. add x0, x0, <OffsetOp>
    instruction_get_operation(NextEA, "ADD"),
    instruction_get_op(NextEA, 2, OffsetOp),
    op_immediate(OffsetOp, Offset).

split_load_for_symbolization(EA, NextEA, as(Base + Offset,address), "LDR/STR") :-
    // ADRP <Register> <Immediate>
    // e.g. adrp x0, BaseOp
    instruction_get_operation(EA, "ADRP"),
    instruction_get_op(EA, 1, BaseOp),
    op_immediate(BaseOp, Base),

    def_used(EA,_,NextEA,_),

    // LDR/STR <Register> <IndirectOp>
    // e.g. ldr x0, [x0, <OffsetOp>]
    instruction_get_operation(NextEA, Operation),
    (
        arch.load_operation(Operation)
        ;
        arch.store_operation(Operation)
    ),
    instruction_get_op(NextEA, 1, OffsetOp),
    op_indirect(OffsetOp,"NONE",_,"NONE",_,Offset,_).

split_load_operand(EA, 1, as(Dest,address)) :-
    split_load_for_symbolization(EA, _, Dest, _).

split_load_operand(EA, 1, as(Dest,address)) :-
    split_load_for_symbolization(_, EA, Dest, "LDR/STR").

split_load_operand(EA, 2, as(Dest,address)) :-
    split_load_for_symbolization(_, EA, Dest, "ADD").


// ARM64: ex_false_pointer_array: optimized (e.g., -O2):
//
// 6e4:   adrp x0, .L_11018
// 6e8:   mov fp,sp
// 6ec:   stp x19,x20,[sp,#16]
// 6f0:   add x20,x0, :lo12:.L_11018
// 6f4:   mov x19,#0
// 6f8:   ldr x0,[x0,:lo12:.L_11018]
//
// In optimized binary as above, there may be cases where one adrp instruction
// is shared among multiple split_loads, such as the add and ldr:
// (0x6e4,0x6f0), (0x6e4,06f8), respectively.
// The relocation type of the object at .L_11018 is RELATIVE (global data
// object).
// In such case, using :got: for adrp and :got_lo12: for ldr causes runtime
// failure. To avoid the problem, the relocation directives are not used for adrp and ldr.
//
symbolic_operand_attribute(ea, 1, "GotRef") :-
    split_load_for_symbolization(ea, _, Dest, "LDR/STR"),
    !split_load_for_symbolization(ea, _, Dest, "ADD"),
    relocation(Dest,_,_,_,_,_,_).

symbolic_operand_attribute(ea, 1, "GotRef"),
symbolic_operand_attribute(ea, 1, "Lo12") :-
    split_load_for_symbolization(ea0, ea, Dest, "LDR/STR"),
    !split_load_for_symbolization(ea0, _, Dest, "ADD"),
    relocation(Dest,_,_,_,_,_,_).

symbolic_operand_attribute(ea, 1, "Lo12") :-
    split_load_for_symbolization(ea0, ea, Dest, "LDR/STR"),
    (
        !relocation(Dest,_,_,_,_,_,_), ea0 = ea0
        ;
        split_load_for_symbolization(ea0, _, Dest, "ADD")
    ).

symbolic_operand_attribute(ea, 2, "Lo12") :-
    split_load_for_symbolization(_, ea, Dest, "ADD"),
    !relocation(as(Dest,address),"GLOB_DAT",_,_,_,_,_).


basic_target(Val+1):-
    defined_symbol(Val,_,_,_,_,_,_,"$t").
basic_target(Val):-
    defined_symbol(Val,_,_,_,_,_,_,"$a").


block_points(Block,"data",0,9,"literal pool"),
data_block_candidate(Block,Size):-
    defined_symbol(Block,Size,_,_,_,_,_,"$d").

plt_block(EA,Function):-
    plt_section(SecName),
    section(SecName,Size,Beg),
    EA < Beg+Size,
    EA >= Beg,
    arch.jump(EA),
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_, _, _,_, Offset, _),
    Got_entry = as(as(65536+ EA,number) + Offset, address),
    relocation(Got_entry,_,Function,_,_,_,_).

// E.g.,
//   add ip, pc, #0, #12
//   add ip, ip, #16, #20
//   ldr pc, [ip, #2640]
plt_block(EA,Function):-
    plt_entry_arm_candidate(EA,Function,_).

// E.g.,
//   bx pc // thumb
//   b.n XXX or nop // thumb
//   add ip, pc, #0, #12
//   add ip, ip, #16, #20
//   ldr pc, [ip, #2640]
block_points(EA-3,"code",0,7,"arm plt-block"),
plt_block(EA-3,Function):-
    plt_entry_arm_candidate(EA,Function,_),
    instruction_get_operation(EA-3,Operation2), // thumb
    arch.jump_operation_op_index(Operation2,TargetOpIndex),
    instruction_get_op(EA-3,TargetOpIndex,TargetOp),
    op_regdirect_contains_reg(TargetOp,PC),
    arch.pc_register(PC).

.decl plt_entry_arm_candidate(ea:address, function:symbol, reloc_ea:address)
.output plt_entry_arm_candidate

// E.g.,
//   add ip, pc, #0, #12
//   add ip, ip, #16, #20
//   ldr pc, [ip, #2640]
plt_entry_arm_candidate(EA,Function,as(Dest,address)):-
    plt_section(SecName),
    section(SecName,Size,Beg),
    EA < Beg+Size,
    EA >= Beg,

    arch.pc_register(PC),

    // add ip, pc, #0, #12
    arch.reg_reg_arithmetic_operation(EA,Reg,PC,"NONE",1,N1),
    next(EA, NextEA),

    // add ip, ip, #16, #20
    // or
    // add ip, ip, #XXXX
    arch.reg_reg_arithmetic_operation(NextEA,Reg,Reg,"NONE",1,N2),
    next(NextEA, NextEA2),

    instruction_get_operation(NextEA2,Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(NextEA2,_,OffsetOp),
    op_indirect(OffsetOp,"NONE",Reg,"NONE",_,Offset,_),
    instruction_get_dest_op(NextEA2,_,RegOp),
    op_regdirect_contains_reg(RegOp,PC),

    Dest = as(EA,number) + N1 + N2 + Offset + 8,
    relocation(as(Dest,address),_,Function,_,_,_,_).

.decl movw_movt_pair_candidate(EA_movw:address,EA_prev:address,EA_movt:address,Distance:unsigned)
.output movw_movt_pair_candidate

movw_movt_pair_candidate(EA_movw,EA_prev,EA_movt,Distance):-
    instruction_get_operation(EA_movt,"MOVT"),
    instruction_get_op(EA_movt,2,RegOp2),
    op_regdirect_contains_reg(RegOp2,Reg),
    instruction_get_operation(EA_movw,"MOVW"),
    instruction_get_op(EA_movw,2,RegOp),
    op_regdirect_contains_reg(RegOp,Reg),
    EA_movw = EA_prev,
    Distance = as(EA_movt-EA_movw,unsigned).

movw_movt_pair_candidate(EA_movw,EA_prev,EA_movt,Distance):-
    instruction_get_operation(EA_movt,"MOVT"),
    next(EA_prev,EA_movt),
    !instruction_get_operation(EA_prev,"MOVW"),
    EA_prev != EA_movw,
    next(EA_prev0,EA_prev),
    movw_movt_pair_candidate(EA_movw,EA_prev0,EA_movt,Distance).

.decl discarded_movw_movt_pair_candidate(EA_movw:address,EA_prev:address,EA_movt:address,Distance:unsigned)
.output discarded_movw_movt_pair_candidate

discarded_movw_movt_pair_candidate(EA_movw,EA_prev,EA_movt,Distance):-
    movw_movt_pair_candidate(EA_movw,EA_prev,EA_movt,Distance),
    movw_movt_pair_candidate(_,_,EA_movt,Distance2),
    Distance > Distance2.

.decl movw_movt_pair(EA_movw:address,EA_prev:address,EA_movt:address)
.output movw_movt_pair

movw_movt_pair(EA_movw,EA_prev,EA_movt):-
    movw_movt_pair_candidate(EA_movw,EA_prev,EA_movt,_),
    !discarded_movw_movt_pair_candidate(EA_movw,_,EA_movt,_).

symbolic_operand_attribute(EA_lo,1,"Part0"),
symbolic_operand_candidate(EA_lo,1,Dest,Type),
symbolic_operand_attribute(EA_hi,1,"Part1"),
symbolic_operand_candidate(EA_hi,1,Dest,Type):-
    instruction_get_operation(EA_lo,"MOVW"),
    instruction_get_op(EA_lo,1,Op),
    op_immediate(Op,DestLow),
    movw_movt_pair(EA_lo,EA_lo,EA_hi),
    instruction_get_operation(EA_hi,"MOVT"),
    instruction_get_op(EA_hi,1,Op2),
    op_immediate(Op2,DestHigh),
    Dest = as((DestHigh*2^16) bor DestLow, address),
    (
        code(Dest), Type="code"
        ;
        data_segment(Begin,End),
        Dest >= Begin, Dest <= End,
        Type = "data"
    ).

symbolic_operand_candidate(EA,1,Dest,Type):-
    binary_isa("ARM64"),
    // ADR <Register> <Immediate>
    // e.g. adr r1, BaseOp
    instruction_get_operation(EA, "ADR"),
    instruction_get_op(EA, 1, OffsetOp),
    op_immediate(OffsetOp, Offset),
    Dest = as(Offset,address),
    (
        code(Dest), Type="code"
        ;
        data_segment(Begin,End),
        Dest >= Begin, Dest <= End,
        Type = "data"
    ).

symbolic_operand_candidate(EA,1,Dest,Type):-
    binary_isa("ARM"),
    !litpool_ref_double(EA,_,_,_),
    // ADR <Register> <Immediate>
    // e.g. adr r1, BaseOp
    instruction_get_operation(EA, "ADR"),
    instruction_get_op(EA, 1, OffsetOp),
    op_immediate(OffsetOp, Offset),
    (
        (EA band 1) = 0,  Disp = 8 // ARM mode
        ;
        (EA band 1) != 0, Disp = 4 // Thumb mode
    ),
    Dest0 = as(EA,number)+Offset+as(Disp,number),
    // Align the address
    Dest1 = as(Dest0-(Dest0 band 3),address),
    (
        code(Dest1), Dest = Dest1, Type="code" // ARM
        ;
        code(Dest1+1), Dest = Dest1+1, Type="code" // Thumb
        ;
        Dest = Dest1,
        data_segment(Begin,End),
        Dest >= Begin, Dest <= End,
        Type = "data"
    ).

value_reg_edge(EA,Reg,EA,"NONE",0,as(Val,number)):-
    split_load_for_symbolization(_,EA,Val,_),
    instruction_get_dest_op(EA,_,DestRegOp),
    op_regdirect_contains_reg(DestRegOp,Reg).

// ARM64 jump-table reference idiom:
// EA: ldr/ldrb/ldrd w0,[x2,w0,uxtw N] --> x2=TableStart
//     adr x1,L
//     add x0,x1,w0, sxtb #M
//     br x0
// TableStart:
//     (L1 - L) / 4
//     (L2 - L) / 4
//     ...
block_needs_splitting_at(Symbol2),
symbol_minus_symbol_jump_table(TableStart,TableStart,Size,Symbol1,Symbol2,"first",Scale):-
    binary_isa("ARM64"),
    instruction(EA,_,_,Operation,Op1,_,_,_,_,_),
    arch.load_operation(Operation),
    (
        Operation = "LDRD", Size = 8;
        Operation = "LDR", Size = 4;
        Operation = "LDRB", Size = 1
    ),
    instruction_get_operation(EA+4, "ADR"),
    instruction_get_op(EA+4, 1, ImmOp),
    op_immediate(ImmOp, Base),
    instruction_get_operation(EA+8, "ADD"),
    instruction_get_dest_op(EA+8,_,TargetOp),
    arch.jump(EA+12),
    instruction_get_operation(EA+12,JumpOperation),
    arch.jump_operation_op_index(JumpOperation,TargetOpIndex),
    instruction_get_op(EA+12,TargetOpIndex,TargetOp),
    Scale = 4, // TODO: Currently, we don't take extenders from the decoder.
               // Use the extender for the add: check if M is 2.
    op_indirect(Op1,"NONE",Reg,_,_,_,_),
    def_used(EA_def,Reg,EA,_),
    best_value_reg(EA_def,Reg,_,_,Val,"complete"),
    TableStart = as(Val,address),
    (
        Size != 1,
        data_word(TableStart,Size,DiffUnsigned)
        ;
        Size = 1,
        data_byte(TableStart,DiffUnsigned)
    ),
    Diff = as(DiffUnsigned,number),
    Symbol1 = as(Base,address),
    Symbol2 = as(Diff*as(Scale,number)+as(Symbol1,number),address).

// PIC code uses inlined pc-relative offsets,
//
//     ldr REG, .L0
//     .LPIC0:
//        add REG, pc
//        ...
//     .L0:
//        .word foo-(.LPIC0+4)
//
// where the symbol foo is the target symbol, and .L0 will contain the offset
// from PC at .LPIC0 to the symbol foo.
labeled_data_candidate(Dest),
symbol_minus_symbol_jump_table(Addr,Addr,Size,EARef,Dest,"no_table",Scale):-
    data_access_pattern(Addr,Size,0,EABase),
    def_used(EABase,Reg,EAAddPC,_),
    arch.reg_reg_arithmetic_operation(EAAddPC,Reg,Reg,PC,1,0),
    arch.pc_register(PC),

    EARef = EAAddPC + 4,
    data_word(Addr,Size,Diff),
    Mode = EAAddPC band 1,
    (
        Dest = as(as(EARef,number) + Diff,address) - Mode,
        !relocation(Addr,_,_,_,_,_,_)
        ;
        relocation(Addr,"REL32",Symbol,_,SymbolIndex,_,"REL"),
        symbol(Base,_,_,_,_,_,SymbolIndex,_),
        // ((S + A) | T) - P
        S = as(Base,unsigned),
        A = as(Diff,unsigned),
        P = as(Addr,unsigned),
        T = as(Base band 1,unsigned),
        Value = ((S + A) bor T) - P,
        Dest = (EARef - Mode) + as(Value,address)
    ),

    data_segment(Begin,End),
    Dest >= Begin, Dest <= End,
    Scale = 1.

block_needs_splitting_at(Symbol2_adjusted),
symbol_minus_symbol_jump_table(TableStart,TableStart,Size,Symbol1,Symbol2_adjusted,"first",Scale):-
    instruction(EA,InstrSize,_,Operation,_,0,0,0,_,_),
    // Align the address
    TableStart = as((EA-(EA band 1))+InstrSize,address),
    Symbol1 = TableStart,
    (
        Size = 2,
        data_word(TableStart,Size,DiffUnsigned),
        Operation="TBH"
        ;
        Size = 1,
        data_byte(TableStart,DiffUnsigned),
        Operation="TBB"
    ),
    !code(TableStart),
    Diff = as(DiffUnsigned,number),
    Symbol2 = as(Diff*as(Scale,number)+as(Symbol1,number),address),
    Scale = 2,
    (
        code(Symbol2), Symbol2_adjusted = Symbol2 // ARM
        ;
        code(Symbol2+1), Symbol2_adjusted = Symbol2+1 // Thumb
    ).

block_needs_splitting_at(Symbol2_adjusted),
symbol_minus_symbol_jump_table(EA+Size,TableStart,Size,Symbol1,Symbol2_adjusted,"first",Scale):-
    symbol_minus_symbol_jump_table(EA,TableStart,Size,Symbol1,_,"first",Scale),
    !possible_data_limit(EA+Size),
    last_data_limit(EA+Size,LastDataLimit),LastDataLimit <= EA,
    (
        Size != 1,
        data_word(EA+Size,Size,DiffUnsigned)
        ;
        Size = 1,
        data_byte(EA+Size,DiffUnsigned)
    ),
    !code(EA+Size),
    Diff = as(DiffUnsigned,number),
    Symbol2 = as(Diff*as(Scale,number)+as(Symbol1,number),address),
    (
        code(Symbol2), Symbol2_adjusted = Symbol2 // ARM
        ;
        code(Symbol2+1), Symbol2_adjusted = Symbol2+1 // Thumb
    ).

.decl arm_jump_table(EA_jump:address,Size:unsigned,TableStart:address)
.output arm_jump_table

block_points(TableStart,"data",0,9,"arm jump table"),
data_block_candidate(TableStart,Size),
data_object_point(TableStart,Size,"symbol",2,"arm jump-table"),
data_object_candidate(TableStart,Size,"symbol"),
arm_jump_table(EA_jump,Size,TableStart):-
    instruction_get_operation(EA_jump,Operation),
    arch.load_word_operation(Operation),
    arch.pc_register(PC),
    // ldr pc, [pc,r2, lsl N]
    // TODO: Currently, 'lsl N' is not propagated from the decoder.
    instruction_get_dest_op(EA_jump,_,RegOp),
    op_regdirect_contains_reg(RegOp,PC),
    instruction_get_src_op(EA_jump,_,IndOp),
    op_indirect(IndOp,"NONE",PC,Reg,Mult,Offset,NBits),
    // TODO: Do we need contraints? Mult=4, Offset=0
    Reg = Reg, Mult = Mult, // to avoid warnings
    Offset = 0,
    Size = NBits / 8,
    arch.pointer_size(Size),
    (
        arch.is_conditional_operation(Operation),
        // 8: Assumes that there is a fall-through successor consisting
        // of one instruction (typically a jump instruction)
        TableStart = EA_jump + 8
        // TODO: check if the fall-through instruction is a jump
        ;
        !arch.is_conditional_operation(Operation),
        TableStart = EA_jump + 4
    ).

data_object_point(EA+Size,Size,"symbol",2,"arm jump-table3"),
data_object_candidate(EA+Size,Size,"symbol"),
arm_jump_table(EA_jump,Size,EA+Size):-
    // recursive
    arm_jump_table(EA_jump,Size,EA),
    address_in_data(EA+Size,TargetAddr),
    code(TargetAddr).

// For table entry targets: to split the target blocks
block_needs_splitting_at(as(TargetAddr,address)):-
    arm_jump_table(_,Size,TableEntry),
    data_word(TableEntry,Size,TargetAddr),
    code(as(TargetAddr,address)).

block_needs_splitting_at(as(TargetAddr+1,address)):- // Thumb
    arm_jump_table(_,Size,TableEntry),
    data_word(TableEntry,Size,TargetAddr),
    code(as(TargetAddr+1,address)).

.decl litpool_ref(ea:address, register_name:register, ea_litpool:address, nbits:unsigned)
.output litpool_ref

litpool_ref(EA,Reg,LitPoolAddr,NBits):-
    possible_ea(EA),
    // LDR <Register> <IndirectOp>
    // e.g., ldr r3, [pc, Offset]
    instruction_get_operation(EA,Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(EA,_,OffsetOp),
    op_indirect(OffsetOp,"NONE",PC,"NONE",_,Offset,NBits),
    arch.pc_register(PC),
    instruction_get_dest_op(EA,_,RegOp),
    op_regdirect_contains_reg(RegOp,Reg),
    !arch.pc_register(Reg),
    (
        (EA band 1) = 0,  Disp = 8 // ARM mode
        ;
        (EA band 1) != 0, Disp = 4 // Thumb mode
    ),
    // Align the address
    EA_aligned = as(EA-(EA band 3),address),
    Addr = as(EA_aligned,number)+Offset+as(Disp,number),
    LitPoolAddr = as(Addr,address).

.decl litpool_ref_double(ea:address, reg1:register, reg2:register, ea_litpool:address)
.output litpool_ref_double

// E.g., adr r, L
//       ldrd r1, r2, [r]
litpool_ref_double(EA,Reg1,Reg2,LitPoolAddr):-
    possible_ea(EA),
    // ADR Reg, Label
    instruction(EA,_,_,"ADR",OffsetOp,RegOp,_,_,_,_),
    op_regdirect_contains_reg(RegOp,Reg),
    op_immediate(OffsetOp, Offset),

    next(EA,EA_next),

    // LDRD Reg1, Reg2, [Reg]
    instruction(EA_next,_,_,"LDRD",Op1,IndOp,Op3,_,_,_),
    op_regdirect_contains_reg(Op3,Reg1),
    op_regdirect_contains_reg(Op1,Reg2),
    op_indirect(IndOp,"NONE",Reg,"NONE",_,0,_),
    (
        (EA band 1) = 0,  Disp = 8 // ARM mode
        ;
        (EA band 1) != 0, Disp = 4 // Thumb mode
    ),
    // Align the address
    EA_aligned = as(EA-(EA band 3), address),
    Addr = as(EA_aligned,number)+Offset+as(Disp,number),
    LitPoolAddr = as(Addr,address).

.decl litpool_ref_for_ldrd(ea:address)

litpool_ref_for_ldrd(EA):-
    litpool_ref(EA,Reg,_,_),
    next(EA,EA_next),
    // LDRD Reg1, Reg2, [Reg]
    instruction(EA_next,_,_,"LDRD",_,IndOp,_,_,_,_),
    op_indirect(IndOp,"NONE",Reg,"NONE",_,0,_).

block_points(LitPoolAddr,"data",0,Points,"arm literal pool"),
data_block_candidate(LitPoolAddr,Pt_size):-
    litpool_ref(EA,_,LitPoolAddr,_),
    arch.pointer_size(Pt_size),
    code_in_block_candidate_refined(EA,_),
    (
        // Give less points in case of ldr/ldrd sequence
        litpool_ref_for_ldrd(EA), Points = 12;
        !litpool_ref_for_ldrd(EA), Points = 9
    ).

// Assign lower point than regular ldr literal-pool load
// since adr/ldr instrunction-sequence has higher
// probability of ldrd literal-pool load.
block_points(LitPoolAddr,"data",0,11,"arm literal pool"),
data_block_candidate(LitPoolAddr,Pt_size):-
    litpool_ref_double(EA,_,_,LitPoolAddr),
    code_in_block_candidate_refined(EA,_),
    arch.pointer_size(Pt_size).


symbolic_operand_candidate(EA,1,LitPoolAddr,"data"):-
    litpool_ref(EA,_,LitPoolAddr,_).

symbolic_operand_candidate(EA,1,LitPoolAddr,"data"):-
    litpool_ref_double(EA,_,_,LitPoolAddr).

.decl symbol_minus_symbol_candidate(ea:address,size:unsigned,symbol1:address,symbol2:address,scale:unsigned,ea_litpool_ref:address,ea_add_pc:address,reg:register)
.output symbol_minus_symbol_candidate

//     ldr reg, LitPool
// ...
// L1: add reg, pc
// ...
// LitPool: .word TARGET - (L1+4)
//
block_needs_splitting_at(EA_add_pc),
moved_data_label(LitPoolAddr,Size,Symbol1,EA_add_pc),
symbol_minus_symbol_candidate(LitPoolAddr,Size,Symbol1,Symbol2,1,EA,EA_add_pc,Reg):-
    litpool_ref(EA,Reg,LitPoolAddr,NBits),
    Size = NBits/8,

    def_used(EA,Reg,EA_add_pc,_),

    // ADD <Register> PC
    // e.g., add r3, pc
    instruction_get_operation(EA_add_pc,"ADD"),
    instruction_get_op(EA_add_pc,1,PcOp),
    op_regdirect_contains_reg(PcOp,PC),
    arch.pc_register(PC),
    instruction_get_dest_op(EA_add_pc,_,DestOp),
    op_regdirect_contains_reg(DestOp,Reg),

    data_word(LitPoolAddr,Size,Diff),
    Symbol1 = EA_add_pc+4,
    Addr2 = as(Diff,address) + Symbol1,
    Symbol2= Addr2-(Addr2 band 1).

.decl litpool_symbolic_operand(ea_litpool:address,size:unsigned,symbol1:address,symbol2:address)
.output litpool_symbolic_operand

//  (A) ldr  reg1, LitPoolAddr1
//  (B) ldr  reg2, LitPoolAddr2
//  (C) add  reg1, pc, reg1 // reg1 is the address of symbol foo
//  (D) ldr  reg3, [reg1, reg2] // the referenced address is the address of symbol bar.
block_needs_splitting_at(EA_C),
litpool_symbolic_operand(LitPoolAddr2,Size,Symbol1,Symbol2):-
    symbol_minus_symbol_candidate(_,_,_,Symbol1,1,_,EA_C,Reg1),

    def_used(EA_C,Reg1,EA_D,_),

    // (D) ldr reg3, [reg1, reg2]
    instruction_get_operation(EA_D,Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(EA_D,_,IndOp),
    op_indirect(IndOp,"NONE",Reg1,Reg2,_,0,_),

    def_used(EA_B,Reg2,EA_D,_),

    // (B) ldr reg2, LitPoolAddr2
    litpool_ref(EA_B,Reg2,LitPoolAddr2,_),

    data_word(LitPoolAddr2,Size,Diff),
    Symbol2 = as(Diff,address) + Symbol1.

//  => equations: [LitPoolAddr1] = foo - (C)
//                [LitPoolAddr2] = bar - foo
//
symbol_minus_symbol(LitPoolAddr2,Size,Symbol1,Symbol2,1):-
    litpool_symbolic_operand(LitPoolAddr2,Size,Symbol1,Symbol2),
    !got_reference(Symbol2,_),
    !relocation(LitPoolAddr2,_,_,_,_,_,_).

//  => equations: [LitPoolAddr1] = foo - (C)
//                [LitPoolAddr2] = bar(GOT) - foo => bar(GOT)
//
symbolic_data_attribute(LitPoolAddr,"GotRelPC"),
got_reference(Got_entry,Symbol),
symbolic_data(LitPoolAddr,Size,Got_entry):-
    litpool_symbolic_operand(LitPoolAddr,Size,_,Got_entry),
    section(".got",GotSize,GotBeg),
    Got_entry >= GotBeg,
    Got_entry < GotBeg+GotSize,
    (
        relocation(Got_entry,RelType,Symbol,_,_,_,_),
        RelType != "RELATIVE",
        symbol(_,_,_,_,_,_,_,Symbol)
        ;
        symbolic_data(Got_entry,Size,Dest),
        symbol(Dest,_,_,_,_,_,_,Symbol)
    ).

cant_have_symbolic_immediate(Operation):-
    instruction_get_operation(_, Operation),
    (
        contains("SUB", Operation);
        contains("MOV", Operation)
    ).

must_access_data(EA,Dest):-
    litpool_ref(EA,_,Dest,_);
    litpool_ref_double(EA,_,_,Dest).

instruction_get_dest_op(EA,1,Op):-
    instruction(EA,_,_,Operation,Op,_,_,_,_,_),
    contains("POP", Operation).

instruction_get_dest_op(EA,Index,Op):-
    instruction(EA,_,_,"LDP",Op1,Op2,_,_,_,_),
    (
        Index = 1, Op = Op1, Op2 = Op2;
        Index = 2, Op = Op2, Op1 = Op1
    ).

instruction_get_src_op(EA,Index,Op):-
    instruction(EA,_,_,"STP",Op1,Op2,_,_,_,_),
    (
        Index = 1, Op = Op1, Op2 = Op2;
        Index = 2, Op = Op2, Op1 = Op1
    ).

invalid(EA,"arm: pc is not allowed"):-
    instruction_get_operation(EA,Operation),
    (
        contains("AND",Operation);
        contains("BIC",Operation);
        contains("LDM",Operation)
    ),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_register(PC).

invalid(EA,"arm: pc cannot be used as index register"):-
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_,_,PC,_,_,_),
    arch.pc_register(PC).

invalid(EA,"arm: invalid mul operand (pc)"):-
    instruction_get_operation(EA,Operation),
    contains("MUL",Operation),
    instruction_get_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.pc_register(Reg).

invalid(EA,"arm: deprecated bx"):-
    instruction_get_operation(EA,"BX"),
    instruction_get_op(EA,1,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.stack_pointer(Reg).

// The following instructions do not allow PC as the destination register.
invalid(EA,"arm: invalid pc"):-
    instruction_get_operation(EA,Operation),
    (
        Operation = "MLAHS";
        Operation = "MLASHS";
        Operation = "LDRSHEQ";
        Operation = "LDRSHTEQ";
        Operation = "LDRSHTLO";
        Operation = "LDRSHTVC";
        Operation = "LDRBEQ";
        Operation = "LDRSBEQ";
        Operation = "LDRHHS";
        Operation = "LDRHTHS";
        Operation = "LDRSBHS";
        Operation = "LDRSHHS";
        Operation = "LDRSBTHS";
        Operation = "LDRSHTHS";
        contains("LDRSB",Operation);
        contains("LDRBVC",Operation);
        contains("LDRBLO",Operation)
    ),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_register(PC).

instruction_has_relocation(EA,EA-Mode):-
    binary_type("REL"),
    instruction(EA,_,_,_,_,_,_,_,_,_),
    Mode = EA band 1,
    relocation(EA-Mode,_,_,_,_,_,_).

symbolic_expr_from_relocation(EA+1,4,Symbol,Addend):-
    binary_type("REL"),
    (
        relocation(EA,"THM_CALL",Symbol,_,_,_,"REL");
        relocation(EA,"THM_JUMP24",Symbol,_,_,_,"REL")
    ),
    Symbol != "",
    thumb_branch_offset(EA,Offset),
    Addend = Offset + 4.

symbolic_expr_from_relocation(EA,4,Symbol,Addend):-
    binary_type("REL"),
    relocation(EA,"ABS32",Symbol,_,SymbolIndex,_,"REL"),
    symbol(Base,_,_,_,_,_,SymbolIndex,Symbol),
    data_word(EA,4,Value),
    // (S + A) | T
    S = as(Base,unsigned),
    A = as(Value,unsigned),
    T = as(Base band 1,unsigned),
    Dest = ((S + A) bor T),
    Addend = as(Base - Dest,number).

symbolic_data_attribute(EA,"GotRelPC"),
symbolic_expr_from_relocation(EA,4,Symbol,Addend):-
    binary_type("REL"),
    relocation(EA,"GOT_BREL",Symbol,_,_,_,_),
    data_word(EA,4,Addend).

// TODO:
// Remove pseudo data attribute.
// Implement symbol-minus-symbol expression from relocation for:
//      .word _GLOBAL_OFFSET_TABLE_-(.LPIC0+4)
// NOTE:
// See special case in `buildDataBlocks'.
symbolic_data_attribute(EA,"_GLOBAL_OFFSET_TABLE_"),
symbol_minus_symbol(EA,4,0,Symbol2,0):-
    binary_type("REL"),
    relocation(EA,"BASE_PREL","_GLOBAL_OFFSET_TABLE_",_,_,_,_),
    symbol_minus_symbol_candidate(_,4,_,EA,1,_,Symbol2,_).

/**
Decode Thumb-2 encoded branch offset. Used to find REL relocation addends.

Note that this is backwards compatible with Thumb-1.
*/
.decl thumb_branch_offset(EA:address,Offset:number)
.output thumb_branch_offset

thumb_branch_offset(EA,Offset):-
    (
        relocation(EA,"THM_CALL",_,_,_,_,_);
        relocation(EA,"THM_JUMP24",_,_,_,_,_)
    ),
    data_word(EA,2,Half0),
    data_word(EA+2,2,Half1),
    UpperHalf = as(Half0,unsigned),
    LowerHalf = as(Half1,unsigned),
    Sign = (UpperHalf band (1 bshl 10)) bshr 10,
    Upper = UpperHalf band 0x3FF,
    Lower = LowerHalf band 0x7FF,
    J1 = (LowerHalf band (1 bshl 13)) bshr 13,
    J2 = (LowerHalf band (1 bshl 11)) bshr 11,
    (J1 bxor Sign = 0, I1 = 1; J1 bxor Sign != 0, I1 = 0),
    (J2 bxor Sign = 0, I2 = 1; J2 bxor Sign != 0, I2 = 0),
    Bits = (Sign bshl 24) bor (I1 bshl 23) bor (I2 bshl 22) bor (Upper bshl 12) bor (Lower bshl 1),
    // Sign-extend unsigned 25-bit value to 32 bits.
    Masked = Bits band ((bnot 1) bshr (32 - 25)),
    TopBit = as(1 bshl (25 - 1),number),
    Signed = as(Masked,number),
    (
        Signed band TopBit = 0,  Offset = Signed;
        Signed band TopBit != 0, Offset = Signed - (TopBit * 2)
    ).
