//===- arm_binaries.dl --------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019-2022 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to abstract from ARM specific instruction set
and characteristics
*/

block_points(Block,"data",0,9,"literal pool"),
data_block_candidate(Block,Size):-
    defined_symbol(Block,Size,_,_,_,_,_,"$d").

block_points(Block,"code",0,1,"plausible instruction sequence: cmp/branch"):-
    conditional_jump(Jump),
    code_in_block_candidate(Jump,Block),
    next(PrevEA,Jump),
    code_in_block_candidate(PrevEA,Block),
    instruction_get_operation(PrevEA,Operation),
    arch.cmp_operation(Operation).

plt_block(EA,Function):-
    plt_section(SecName),
    section(SecName,Size,Beg),
    EA < Beg+Size,
    EA >= Beg,
    arch.jump(EA),
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_, _, _,_, Offset, _),
    Got_entry = as(as(65536+ EA,number) + Offset, address),
    relocation(Got_entry,_,Function,_,_,_,_).


symbolic_operand_point(EA,Imm_index,-2,"invalid symbolic operand for mov"):-
    symbolic_operand_candidate(EA,Imm_index,_,_),
    // If no attribute is found, the immediate is not likely symbolic.
    // Note that lower16 or upper16 is not allowed for mov.
    // However, upper8_15 seems valid: e.g., MOVS r0, #:upper8_15:#foo
    !symbolic_operand_attribute(EA,_,_),
    instruction_get_operation(EA,Operation),
    Operation != "MOVT", Operation != "MOVW", contains("MOV",Operation).

symbolic_operand_point(EA,Imm_index,-1,"unlikely to have symbolic operand"):-
    symbolic_operand_candidate(EA,Imm_index,_,_),
    instruction_get_operation(EA,Operation),
    (
        arch.cmp_operation(Operation)
        ;
        arch.logic_operation(Operation)
    ).

unlikely_have_symbolic_immediate(EA):-
    instruction_get_operation(EA, Operation),
    (
        // NOTE: This is not exhaustive.
        arch.logic_operation(Operation);
        Operation != "MOVT", Operation != "MOVW", contains("MOV",Operation);
        contains("CMP", Operation);
        contains("CMN", Operation);
        contains("SUB", Operation);
        contains("RSB", Operation)
    ).

instruction_has_relocation(EA,EA-Mode):-
    binary_type("REL"),
    instruction(EA,_,_,_,_,_,_,_,_,_),
    Mode = EA band 1,
    relocation(EA-Mode,_,_,_,_,_,_).

symbolic_expr_from_relocation(EA,4,Symbol,Addend):-
    binary_type("REL"),
    relocation(EA,"ABS32",Symbol,_,SymbolIndex,_,"REL"),
    symbol(Base,_,_,_,_,_,SymbolIndex,Symbol),
    data_word(EA,4,Value),
    // (S + A) | T
    S = as(Base,unsigned),
    A = as(Value,unsigned),
    T = as(Base band 1,unsigned),
    Dest = ((S + A) bor T),
    Addend = as(Base - Dest,number).

symbolic_data_attribute(EA,"GotRelPC"),
symbolic_expr_from_relocation(EA,4,Symbol,Addend):-
    binary_type("REL"),
    relocation(EA,"GOT_BREL",Symbol,_,_,_,_),
    data_word(EA,4,Addend).
