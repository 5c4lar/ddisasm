//===- cfg.dl ----------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module generates the control flow graph of the disassembled code
*/

/**
This predicate specifies a CFG edge between two locations in the binary.
*/
.decl cfg_edge(src:address,dest:address,conditional:symbol,indirect:symbol,type:symbol)
.output cfg_edge

/**
This predicate specifies CFG edges from `src` to a Top proxy block
to model calls or jumps whose destination is unknown.
*/
.decl cfg_edge_to_top(src:address,conditional:symbol,type:symbol)
.output cfg_edge_to_top

/**
 This predicate specifies CFG edges whose destination is an external symbol.
 */
.decl cfg_edge_to_symbol(src:address,Symbol:symbol,conditional:symbol,indirect:symbol,type:symbol)
.output cfg_edge_to_symbol

/////////////////////////////////////////////////////////////////////////////////
// jump table identification
.decl jump_table(Src:address,Data:address)

//use the data access pattern
jump_table(EA,Initial_memory):-
    code(EA),
    indirect_jump(EA),
    arch.pointer_size(Pt_size),
    data_access_pattern(Initial_memory,Pt_size,as(Pt_size,number),EA),
    symbolic_data(Initial_memory,Pt_size,Dest_block),
    refined_block(Dest_block).

//use just the constant in the jump
jump_table(EA,Initial_memory):-
    code(EA),
    indirect_jump(EA),
    arch.pointer_size(Pt_size),
    symbolic_operand(EA,1,Initial_memory,"data"),
    symbolic_data(Initial_memory,Pt_size,Dest_block),
    refined_block(Dest_block).

jump_table(EA,Memory+Pt_size):-
    jump_table(EA,Memory),
    arch.pointer_size(Pt_size),
    symbolic_data(Memory+Pt_size,Pt_size,Dest_block),
    refined_block(Dest_block),
    !data_access_pattern(Memory+Pt_size,_,_,_).

// we have another access to the same table (the access can be before or after)
jump_table(EA,Memory+Pt_size):-
    jump_table(EA,Memory),
    arch.pointer_size(Pt_size),
    symbolic_data(Memory,Pt_size,Content_prev),
    symbolic_data(Memory+Pt_size,Pt_size,Content_next),
    refined_block(Content_next),
    data_access_pattern(Memory+Pt_size,Pt_size,as(Pt_size,number),EA),
    (
        EA < Content_prev,
        EA < Content_next
        ;
        EA > Content_prev,
        EA > Content_next
    ).

/**
 This predicate represents known targets of indirect jumps
 or calls. `EA` is the address of the jump or call instruction and `Dest`
is the destination address. Type can be "branch" or "call".
 */
.decl resolved_transfer(EA:address,Dest:address,Type:symbol)

resolved_transfer(EA,Dest,"branch"):-
    jump_table(EA,Memory),
    code(EA),
    symbolic_data(Memory,_,Dest),
    refined_block(Dest).

// Symbol-Symbol jump tables
resolved_transfer(EA,Dest,EdgeType):-
    jump_table_start(EA,Size,TableStart,_,_),
    // jump_table_start can refer to call instructions too
    (
        arch.jump(EA),
        EdgeType="branch"
        ;
        arch.call(EA,_),
        EdgeType="call"
    ),
    relative_jump_table_entry(_,TableStart,Size,_,Dest,_,_).

resolved_transfer(EA,Dest,"branch"):-
    jump_table_candidate_refined(EA,_,Dest).

// easy-to-resolve jumps

resolved_transfer(EA,Dest,Type):-
    (
        pc_relative_jump(EA,Pointer), Type = "branch"
        ;
        pc_relative_call(EA,Pointer), Type = "call"
        ;
        indirect_jump(EA), Type = "branch",
        data_access(EA,_,"NONE","NONE","NONE",_,Offset,_),
        Pointer = as(Offset,address)
        ;
        indirect_call(EA), Type = "call",
        data_access(EA,_,"NONE","NONE","NONE",_,Offset,_),
        Pointer = as(Offset,address)
    ),
    symbolic_data(Pointer,_,Dest).


resolved_transfer(EA,DestAddr,Type):-
    (
        reg_jump(EA,Reg), Type = "branch"
        ;
        reg_call(EA,Reg), Type = "call"
    ),
    reg_def_use.def_used(EA_def,Reg,EA,_),
    value_reg(EA_def,Reg,_,"NONE",_,Dest,_),
    DestAddr = as(Dest,address),
    code(DestAddr).


.decl resolved_transfer_to_symbol(EA:address,Symbol:symbol,Type:symbol)


resolved_transfer_to_symbol(EA,Symbol,Type):-
    (
        pc_relative_jump(EA,Pointer), Type = "branch"
        ;
        pc_relative_call(EA,Pointer), Type = "call"
        ;
        indirect_jump(EA), Type = "branch",
        data_access(EA,_,"NONE","NONE","NONE",_,Offset,_),
        Pointer = as(Offset,address)
        ;
        indirect_call(EA), Type = "call",
        data_access(EA,_,"NONE","NONE","NONE",_,Offset,_),
        Pointer = as(Offset,address)
    ),
    (
        symbolic_expr(Pointer,_,Symbol,0),
        !defined_symbol(_,_,_,_,_,_,_,_,Symbol),
        !inferred_symbol(_,Symbol,_,_,_)
        ;
        // We don't generate symbolic_expr for entries in the IAT
        // so we have to consider these separately
        pe_import_entry(Pointer,_,Symbol,_)
    ).

resolved_transfer_to_symbol(EA,Symbol,Type):-
    (
        reg_jump(EA,Reg), Type = "branch"
        ;
        reg_call(EA,Reg), Type = "call"
    ),
    reg_def_use.def_used(EA_def,Reg,EA,_),
    arch.load(EA_def,SrcOp,_,Reg,_,_,_,_),
    (
        pc_relative_operand(EA_def,SrcOp,Pointer)
        ;
        instruction_displacement_offset(EA_def,_,_,_),
        instruction_has_relocation(EA_def,Pointer)
    ),
    (
        symbolic_expr(Pointer,_,Symbol,0),
        !defined_symbol(_,_,_,_,_,_,_,_,Symbol),
        !inferred_symbol(_,Symbol,_,_,_)
        ;
        // We don't generate symbolic_expr for entries in the IAT
        // so we have to consider these separately
        pe_import_entry(Pointer,_,Symbol,_)
    ).

//////////////////////////////////////////////////////////////////////////////
// edge creation

cfg_edge(Src,Dest,"false","false","fallthrough"):-
    refined_block_control_instruction(Src,EA),
    may_fallthrough(EA,Dest),
    !no_return_call_propagated(EA),
    !nop_block(Src),
    code_in_refined_block(Dest,Dest),
    next_refined_block_in_section(Src,Dest),
    // Assume no fallthrough edge from one plt block to another.
    !plt_block(Src,_).

cfg_edge(Src,Dest,"false","false","fallthrough"):-
    cfg_edge(_,Src,_,_,_),
    nop_block(Src),
    next_refined_block_in_section(Src,Dest).

cfg_edge(Src,Dest,"false","false","fallthrough"):-
     nop_block(Src),
     cfg_edge(_,Src,_,_,_),
     next_refined_block_in_section(Src,Dest).


cfg_edge(Src,Dest,Conditional,Indirect,Type):-
    refined_block_control_instruction(Src,EA),
    (
        direct_jump(EA,Dest),
        Type="branch",
        Indirect = "false"
        ;
        direct_call(EA,Dest),
        !pc_load_call(EA,_),
        Type = "call",
        Indirect = "false"
        ;
        resolved_transfer(EA,Dest,Type), Indirect = "true"
    ),
    refined_block(Dest),
    (
        !arch.conditional(EA,_),Conditional = "false";
        arch.conditional(EA,_),Conditional = "true"
    ).

cfg_edge(ReturnBlock,NextBlock,Conditional,"false","return"):-
    cfg_edge(Caller,Block,_,_,"call"),
    cfg_edge(Caller,NextBlock,_,_,"fallthrough"),
    function_inference.in_function(Block,FunctionEntry),
    function_inference.in_function(ReturnBlock,FunctionEntry),
    refined_block_control_instruction(ReturnBlock,Insn),
    (
        unconditional_return(Insn), Conditional = "false";
        conditional_return(Insn), Conditional = "true"
    ).

// direct calls or jumps to external functions
cfg_edge_to_symbol(Src,Symbol,Conditional,"false",EdgeType):-
    refined_block_control_instruction(Src,EA),
    (
        arch.jump(EA),
        EdgeType="branch"
        ;
        arch.call(EA,_),
        EdgeType="call"
    ),
    (
        !arch.conditional(EA,_),Conditional = "false";
        arch.conditional(EA,_),Conditional = "true"
    ),
    instruction_immediate_offset(EA,_,_,_),
    instruction_has_relocation(EA,Rel),
    symbolic_expr(Rel,_,Symbol,0),
    !defined_symbol(_,_,_,_,_,_,_,_,Symbol),
    !inferred_symbol(_,Symbol,_,_,_).

// calls or jumps to external functions
// through indirect pointer (e.g. GOT)
cfg_edge_to_symbol(Src,Symbol,Conditional,"false",EdgeType):-
    refined_block_control_instruction(Src,EA),
    resolved_transfer_to_symbol(EA,Symbol,EdgeType),
    (
        !arch.conditional(EA,_),Conditional = "false";
        arch.conditional(EA,_),Conditional = "true"
    ).


// Undefined edges
cfg_edge_to_top(Src,Conditional,"branch"):-
    refined_block_control_instruction(Src,EA),
    (
        reg_jump(EA,_);
        indirect_jump(EA)
    ),
    !resolved_transfer(EA,_,"branch"),
    !resolved_transfer_to_symbol(EA,_,"branch"),
    (
        unconditional_jump(EA), Conditional = "false";
        conditional_jump(EA), Conditional = "true"
    ).

cfg_edge_to_top(Src,"false","call"):-
    refined_block_control_instruction(Src,EA),
    (
        reg_call(EA,_)
        ;
        indirect_call(EA)
    ),
    !resolved_transfer(EA,_,"call"),
    !resolved_transfer_to_symbol(EA,_,"call").

// a return to top if no other return exists
cfg_edge_to_top(Src,Conditional,"return"):-
    refined_block_control_instruction(Src,Insn),
    (
        unconditional_return(Insn), Conditional = "false";
        conditional_return(Insn), Conditional = "true"
    ),
    !cfg_edge(Src,_,_,_,"return").
