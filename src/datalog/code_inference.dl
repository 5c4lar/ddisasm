


// These are final addresses where the code is located
// They are organized in blocks of sequential code
// The first address is the block identifier
.decl code_in_block(ea:address,block:address)
.output code_in_block

.decl block(block:address)
.output block

.decl code(ea:address)


// we detect if there are still overlaping blocks, in that case the analysis failed
.decl block_still_overlap(ea:address,ea2:address)
.output block_still_overlap


// define component traverse_code
#include "traverse_code.dl"

/////////////////////////////////////////////////////////////
// We go through several phases of increasing confidence
/////////////////////////////////////////////////////////////

/////////////////////////////
// Phase 1
// Get an initial approximation of things that look like code
/////////////////////////////
.init phase1=traverse_code

phase1.possible_ea(EA):-
	instruction(EA,_,_,_,_,_,_,_).


//fixme pie here
phase1.block_limit(EA):-
	op_immediate(_,EA).

phase1.block_limit(EA):-
	pc_relative_jump(_,EA).
	
phase1.block_limit(EA):-
	pc_relative_call(_,EA).

phase1.block_limit(EA):-
	basic_target(EA).	


phase1.possible_target(EA):-
	phase1.block_limit(EA).

////////////////////////////////////////////////////////



/////////////////////////////
// Phase 2
// In this propagation the possible targets
// are discovered incrementally
/////////////////////////////

.init phase2=traverse_code

phase2.possible_ea(EA):-
	phase1.remaining_ea(EA).	

// we can start traversing the code in two places and end up in the same
// sequence, we want to split those common sequences apart so we 
// get blocks that don't have common tails
.decl common_tail(ea:address)

common_tail(EA):-
	phase1.likely_ea(EA,Block),
	may_fallthrough(From,EA),
	//get the head of the tail only
	!phase1.likely_ea(From,Block),
	phase1.likely_ea(From,Block2),
	Block2!=Block.

phase2.block_limit(EA):-
	phase1.block_limit(EA).
	
phase2.block_limit(EA):-
	common_tail(EA).



//////////////////////////////////////////	
// The targets are computed incrementally now as we traverse the code
// likely_ea and possible_target_from are mutually recursive

.decl operation_not_for_address(Operation:symbol)

operation_not_for_address("AND").
operation_not_for_address("XOR").

.decl can_have_symbolic(EA:address)

can_have_symbolic(Src):-
	binary_type("DYN"),
	phase2.likely_ea(Src,_),
	instruction(Src,Size,_,_,_,_,_,_),
	relocation(Location,_,_,_),
	Src<=Location,
	Location<Src+Size.

can_have_symbolic(Src):-
	binary_type("EXEC"),
	phase2.likely_ea(Src,_).


can_have_symbolic(EA):-
	direct_jump(EA,_).
can_have_symbolic(EA):-
	direct_call(EA,_).


.decl possible_target_from(dest:address,src:address)

possible_target_from(Dest,Src):-
	phase2.likely_ea(Src,_),
	can_have_symbolic(Src),
	instruction_get_op(Src,_,Op),
	instruction_get_operation(Src,Operation),
	!operation_not_for_address(Operation),
	op_immediate(Op,Dest),
	phase1.remaining_ea(Dest).


possible_target_from(Dest,Src):-
	phase2.likely_ea(Src,_),
	pc_relative_jump(Src,Dest).
	
possible_target_from(Dest,Src):-
	phase2.likely_ea(Src,_),
	pc_relative_call(Src,Dest).


phase2.possible_target(EA):-
	basic_target(EA).

phase2.possible_target(EA):-
	possible_target_from(EA,_).

.output phase2.remaining_ea

////////////////////////////////////////////////////////////////////////
// We are done with the recursive exploration
// Now we detect and resolve conflics within the different blocks

.decl block_overlap(ea:address,ea2:address)
.output block_overlap

block_overlap(EA_block,EA_block2):-
	phase2.likely_ea(EA,EA_block),
	phase2.overlap(EA,EA2),
	phase2.likely_ea(EA2,EA_block2).



.decl block_is_overlaping(block:address)

block_is_overlaping(Block):-
	(
	block_overlap(Block,_)
	;
	block_overlap(_,Block)
	).
	
//////////////////////////////////////////////////////////////////////
// We need to solve the block overlaps
// we do it with heuristics
///

.decl discarded_block(ea_block:address)
.output discarded_block


discarded_block(Block):-
	(
	block_overlap(Block,Block2)
	;
	block_overlap(Block2,Block)
	),
	//heuristic: keep the one that has more predecessors
	// but we value different kinds of predecessors differently
	(
	sum X:{block_pred(Block,_,X,_)}< sum Y:{block_pred(Block2,_,Y,_)}
	 ;
	 //The sum seems to fail if the set is empty so we consider
	 // this case independently
	 block_pred(Block2,_,_,_),
	 !block_pred(Block,_,_,_)
	 ).

// propagate discarding blocks through direct jumps or calls
discarded_block(Block):-
	discarded_block(Block2),
	(
	direct_jump(EA,Block2)
	;
	direct_call(EA,Block2)
	),
	phase2.likely_ea(EA,Block).
	
// The heuristics count the number of predecessors that are not overlaping blocks
// we give more points for predecessors from fallthroughs and direct jumps
// The points are trasmitted transitively though overlaping blocks

.decl block_pred(block:address,predecessor:address,importance:number,why:symbol)
.output block_pred

block_pred(Block,0,20,"start point"):-
	entry_point(Block).

block_pred(Block,0,20,"function symbol"):-
	function_symbol(Block,_).
	
block_pred(Block,0,1,"address in data"):-
	address_in_data(Address,Block),
	Address % 8 != 0.

block_pred(Block,0,2,"aligned address in data"):-
	address_in_data(Address,Block),
	Address % 8 = 0.

block_pred(Block,0,1,"address in data array"):-
	address_in_data(Address,Block),
	Address % 8 = 0,
	(
	address_in_data(Address+8,_),
	address_in_data(Address+16,_)
	;
	address_in_data(Address-8,_),
	address_in_data(Address-16,_)
	;
	address_in_data(Address+8,_),
	address_in_data(Address-8,_)
	).

block_pred(Block,Block_pred,4,"direct jump"):-
	direct_jump(EA,Block),
	phase2.likely_ea(EA,Block_pred),
	Block_pred!=Block,
	!block_is_overlaping(Block_pred).
	
block_pred(Block,Block_pred,5,"may_fallthrough"):-
	may_fallthrough(EA,Block),
	phase2.likely_ea(EA,Block_pred),
	!block_is_overlaping(Block_pred).

// it fits but the previous block does not fall through
block_pred(Block,Block_pred,1,"fits"):-
	next(EA,Block),
	!may_fallthrough(EA,Block),
	phase2.likely_ea(EA,Block_pred),
	!block_is_overlaping(Block_pred).

// its address appears somewhere
block_pred(Block,Block_pred,2,"appears"):-
	possible_target_from(Block,EA),
	!direct_jump(EA,Block),
	phase2.likely_ea(EA,Block_pred),
	Block_pred!=Block,
	!block_is_overlaping(Block_pred).

block_pred(Block,0,2,"in relative jump table"):-
	relative_address(_,_,Block).

// give a point if it may fallthrough to another block
block_pred(Block,Block_succ,1,"fallthough_to"):-
	phase2.likely_ea(EA,Block),
	may_fallthrough(EA,Block_succ),
	phase2.likely_ea(_,Block_succ),
	!block_is_overlaping(Block_succ).
	

// transitivity for fallthrough and direct jumps
block_pred(Block,Block_pred2,Points,"transitive fallthough"):-
	may_fallthrough(EA,Block),
	phase2.likely_ea(EA,Block_pred),
	block_is_overlaping(Block_pred),
	block_pred(Block_pred,Block_pred2,Points,_).

block_pred(Block,Block_pred2,Points,"transitive jump"):-
	direct_jump(EA,Block),
	phase2.likely_ea(EA,Block_pred),
	block_is_overlaping(Block_pred),
	block_pred(Block_pred,Block_pred2,Points,_).

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


code_in_block(EA,Block):-
	phase2.likely_ea(EA,Block),
	!discarded_block(Block).

block(Block):-
	code_in_block(_,Block).
	
code(EA):-
	code_in_block(EA,_).
	
block_still_overlap(Block,Block2):-
	block_overlap(Block,Block2),
	!discarded_block(Block),
	!discarded_block(Block2).
