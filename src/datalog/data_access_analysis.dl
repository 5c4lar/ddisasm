//===- data_access_analysis.dl ----------------------------------*- C++ -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
 The data access analysis computes:

-'data_access_patterns' which represent that the address 'Address' is
 accessed with size 'Size' and multiplier 'Multiplier' from an
 instruction in 'FromWhere'.

-'preferred_data_access' the address is most likely accessed from the data access
  pattern located at ea_data_access.

data_access_patterns are computed by checking memory accesses and with
the help of the value analysis. Some special cases are checked
explicitly.

data_access_patterns give us very sparse information, but if an
address 'ea' is accessed with a multiplier, it is likely that
'ea'+multiplier, 'ea'+2*multiplier, etc are also accessed the same
way.  Unfortunately, we do not know until when. Therefore, we
propagate these accesses using the multiplier until we reach some
other access.

There are two refinements:

- Once the accesses have been propagated, we can have several data access patterns that
 have been propagated to the same location. We choose the one that is closest (thus the
 prefix 'preferred_'). The other propagated data accesses are discarded.

- Often we have data accesses that are related. For example accesses
to different fields of an array of structs. We say that those accesses
are 'paired'. In such cases, we can get better precision if we
propagate those accesses together. I.e. we stop the propagation as
soon as any of the paired accesses reaches another access.

Let us have two accesses to locations EA1 and EA2 with multipliers
Mult1 and Mult2.  We say these two accesses are paired if Mult1=Mult2
and EA1<= EA2<= EA1+Mult1.


*/

// auxiliary predicate to  compute the amount of read memory
.decl instruction_memory_access_size(EA:address,Op_index:operand_index,Size:number)

instruction_memory_access_size(EA,Index,SizeAccess):-
    code(EA),
    instruction_get_op(EA,Index,Op),
    instruction_get_operation(EA,Operation),
    (
        Operation="LEA",
        SizeAccess=0
     ;
        Operation!="LEA",
        op_indirect(Op,_,_,_,_,_,Size),
        SizeAccess=Size/8
    ).

//there is a data access at EA in the operand Op_index
.decl data_access(EA:address,Op_index:operand_index,Reg1:register,Reg2:register,Reg3:register,Mult:number,Offset:number,Size:number)

data_access(EA,Op_index,Reg1,Reg2,Reg3,Mult,Offset,Size):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	op_indirect(Op,Reg1,Reg2,Reg3,Mult,Offset,_),
    instruction_memory_access_size(EA,Op_index,Size).

// the register Reg has the given value at instruction EA and operand Op_index
.decl value_reg_at_operand(EA:address,Op_index:operand_index,Reg:register,Mult:number,Offset:number,Type:symbol)

value_reg_at_operand(EA,Op_index,Reg,Mult,Offset_final,Type):-
	data_access(EA,Op_index,Reg1,Reg2,Reg3,_,_,Size),
	(Reg=Ref2; Reg= Reg3),
	Reg!="NONE",
	def_used(EA_def,Reg,EA,Op_index),
	best_value_reg(EA_def,Reg,Mult,Offset,Type),
	(
	Type!="incomplete",
	Offset_final=Offset
	;
	Type="incomplete",
	Offset_final=0
	).

// NONE registers have 0 value
value_reg_at_operand(EA,Op_index,Reg,0,0,"complete"):-
	data_access(EA,Op_index,Reg1,Reg2,Reg3,Mult,Offset,Size),
	(Reg=Ref2; Reg= Reg3),
	Reg="NONE".

.decl data_access_pattern(Address:address,Size:number,Multiplier:number,FromWhere:address)
.output data_access_pattern

.decl data_access_pattern_candidate(Address:address,Size:number,Multiplier:number,FromWhere:address)

.decl preferred_data_access(ea:address,ea_data_access:address)
.output preferred_data_access

//////////////////////////////////////////////////

    
//single access
data_access_pattern_candidate(Address,Size,0,EA):-
	data_access(EA,_,"NONE","NONE","NONE",_,Address,Size),
	data_section(Section),
	section(Section,SizeSect,Base),
	Address>=Base,
	Address<=Base+SizeSect.

// pc relative
data_access_pattern_candidate(Address,Size,0,EA):-
	code(EA),
	pc_relative_operand(EA,Op_index,Address),
    instruction_memory_access_size(EA,Op_index,Size),
	data_section(Section),
	section(Section,SizeSect,Base),
	Address>=Base,
	Address<=Base+SizeSect.

// directly computed
data_access_pattern_candidate(Address,Size,Mult*Mult2,EA):-
	data_access(EA,Op_index,"NONE",RegBase,RegMult,Mult,Offset1,Size),
	RegMult!="NONE",
	value_reg_at_operand(EA,Op_index,RegMult,Mult2,Offset2,_),
	value_reg_at_operand(EA,Op_index,RegBase,0,Offset3,"complete"),
	
	(Size<=Mult*Mult2; Mult*Mult2=0),
	Address=Offset1+(Offset2*Mult)+Offset3,
	data_section(Section),
	section(Section,SizeSect,Base),
	Address>=Base,
	Address<=Base+SizeSect.

// indirectly computed
data_access_pattern_candidate(Address,Size,Mult,EA):-
	data_access(EA,Op_index,"NONE",RegBase,RegMult,1,Offset1,Size),
	value_reg_at_operand(EA,Op_index,RegMult,0,Offset2,"complete"),
	value_reg_at_operand(EA,Op_index,RegBase,Mult,Offset3,_),

	(Size<=Mult; Mult=0),
	Address=Offset1+Offset2+Offset3,
	data_section(Section),
	section(Section,SizeSect,Base),
	Address>=Base,
	Address<=Base+SizeSect.
	
//repeated register
data_access_pattern_candidate(Address,Size,Mult+1,EA):-
	data_access(EA,Op_index,"NONE",Reg,Reg,Mult,Address,Size),
	value_reg_at_operand(EA,Op_index,Reg,1,0,_),
	Size<=Mult+1,

	data_section(Section),
	section(Section,SizeSect,Base),
	Address>=Base,
	Address<=Base+SizeSect.

// select the access pattern with highest multiplier
data_access_pattern(Address,Size,Multiplier,From):-
	data_access_pattern_candidate(Address,Size,Multiplier,From),
	data_byte(Address,_),
	MaxMult =max MaxMult : data_access_pattern_candidate(Address,Size,MaxMult,_),
	Multiplier>=MaxMult.


///////////////////////////////////////////////////////////////////////////////
// This code takes care of obtaining an ordering in the data_access_patterns
.decl step(Size:number)

step(8).

.decl possible_data_limit(EA:address)

possible_data_limit(EA):-
	labeled_data_candidate(EA);
	data_access_pattern(EA,_,_,_).

.decl last_unaligned_data_access(EA:address,Where:address)
.output last_unaligned_data_access

last_unaligned_data_access(EA+1,EA):-
	possible_data_limit(EA),
	step(N),
	EA % N !=0.
last_unaligned_data_access(EA+1,Where):-
	last_unaligned_data_access(EA,Where),
	!possible_data_limit(EA),
	step(N),
	EA % N !=0.

.decl last_data_access(EA:address,EA_access:address)
.output last_data_access

last_data_access(EA,Where):-
	last_unaligned_data_access(EA,Where),
	step(N),
	EA % N =0,
	data_byte(EA,_).

last_data_access(EA+N,EA):-
	possible_data_limit(EA),
	step(N),
	EA % N =0,
	!last_unaligned_data_access(EA+N,_).

last_data_access(EA+N,Where):-
	last_data_access(EA,Where),
	step(N),
	EA % N =0,
	data_byte(EA+N,_),
	!possible_data_limit(EA),
	!last_unaligned_data_access(EA+N,_).

.decl last_data_access_from(EA:address,Where:address) inline

last_data_access_from(EA,Where):-
	last_unaligned_data_access(EA,Where).

last_data_access_from(EA,Where):-
	data_byte(EA,_),
	!last_unaligned_data_access(EA,_),
	step(N),
	Ref=EA- (EA % N),
	last_data_access(Ref,Where).

////////////////////////////////////////////////////////////////////////////////////////////////
// This code performs the propagation

.decl propagated_data_access(EA:address,Mult:number,EA_ref:address)

propagated_data_access(EA,Mult,EA):-
	data_access_pattern(EA,_,Mult,_).

propagated_data_access(EA+Mult,Mult,EA_ref):-
	propagated_data_access(EA,Mult,EA_ref),
	data_byte(EA+Mult,_),
	// no collision with next data access pattern
	!possible_data_limit(EA+Mult),
	pointer_size(Pt_size),
	// no overlap with address array
	address_array_range.no_overlap(EA+Mult,Pt_size),
	//no collision with other data access pattern in between
	last_data_access_from(EA+Mult,Last),
	(Last<=EA
	;
	Last>EA,
	data_access_pattern(Last,Size,Mult,_),
	Last+Size<= EA+Mult
	).

preferred_data_access(EA,EA_label):-
	propagated_data_access(EA,_,EA_label).
