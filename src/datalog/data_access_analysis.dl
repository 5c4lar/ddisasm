//===- data_access_analysis.dl ------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
 The data access analysis computes:

-'data_access_patterns' which represent that the address 'Address' is
 accessed with size 'Size' and multiplier 'Multiplier' from an
 instruction in 'FromWhere'.

-'preferred_data_access' the address is most likely accessed from the data access
  pattern located at ea_data_access.

data_access_patterns are computed by checking memory accesses and with
the help of the value analysis.

data_access_patterns give us very sparse information, but if an
address 'ea' is accessed with a multiplier, it is likely that
'ea'+multiplier, 'ea'+2*multiplier, etc are also accessed the same
way.  Unfortunately, we do not know until when. Therefore, we
propagate these accesses using the multiplier until we reach some
other access.
*/

// auxiliary predicate to  compute the amount of read memory
.decl instruction_memory_access_size(EA:address,Op_index:operand_index,Size:unsigned)

instruction_memory_access_size(EA,Index,SizeAccess):-
    code(EA),
    instruction_get_op(EA,Index,Op),
    (
        arch.operation_size_exception(EA,Index,SizeAccess),
        Op = Op // avoid warning
        ;
        !arch.operation_size_exception(EA,Index,_),
        op_indirect(Op,_,_,_,_,_,Size),
        SizeAccess = Size/8
    ).

//there is a data access at EA in the operand Op_index
.decl data_access(EA:address,Op_index:operand_index,RegSegment:reg_nullable,RegBase:reg_nullable,RegIndex:reg_nullable,Mult:number,Offset:number,Size:unsigned)
.output data_access

data_access(EA,Op_index,RegSegment,RegBase,RegIndex,Mult,Offset,Size):-
    code(EA),
    instruction_get_op(EA,Op_index,Op),
    op_indirect_mapped(Op,RegSegment,RegBase,RegIndex,Mult,Offset,_),
    instruction_memory_access_size(EA,Op_index,Size).

// the register Reg has the given value at instruction EA and operand Op_index
.decl value_reg_at_operand(EA:address,Op_index:operand_index,Reg:reg_nullable,EA_from:address,Mult:number,Offset:number,Type:symbol)


// value_reg_at_operand_loop is just used to give priority to "loop" values over other kinds of values
.decl value_reg_at_operand_loop(EA:address,Op_index:operand_index,Reg:reg_nullable,EA_from:address,Mult:number,Offset:number,Type:symbol)


value_reg_at_operand(EA,Op_index,Reg,EA_from,Mult,BaseAddress,"loop"),
value_reg_at_operand_loop(EA,Op_index,Reg,EA_from,Mult,BaseAddress,"loop"):-
    data_access(EA,Op_index,_,Reg2,Reg3,_,_,_),
    (
        Reg = Reg2,
        UNUSED(Reg3)
        ;
        Reg = Reg3,
        UNUSED(Reg2)
    ),
    reg_nonnull(Reg,Reg_nn),
    def_used(EA_def,Reg_nn,EA,Op_index),
    best_value_reg(EA_def,Reg_nn,EA_from,Mult,Offset,"loop"),
    (
        // the access is after the increment
        !def_used(EA_from,Reg_nn,EA,Op_index),
        BaseAddress = Offset
        ;
        // the access is before the increment
        def_used(EA_from,Reg_nn,EA,Op_index),
        BaseAddress = Offset-Mult
    ).

value_reg_at_operand(EA,Op_index,Reg,EA_from,Mult,Offset_final,Type):-
    data_access(EA,Op_index,_,Reg2,Reg3,_,_,_),
    (
        Reg = Reg2,
        UNUSED(Reg3)
        ;
        Reg = Reg3,
        UNUSED(Reg2)
    ),
    reg_nonnull(Reg,Reg_nn),
    !value_reg_at_operand_loop(EA,Op_index,Reg,_,_,_,_),
    def_used(EA_def,Reg_nn,EA,Op_index),
    best_value_reg(EA_def,Reg_nn,EA_from,Mult,Offset,Type),
    (
        Offset_final = max(Offset,0)
        ;
        Type = "incomplete",
        Offset_final = 0,
        Offset = Offset // avoid warning
    ).

// case where there is not apparent definition
value_reg_at_operand(EA,Op_index,Reg,0,1,0,"incomplete"):-
    data_access(EA,Op_index,_,Reg2,Reg3,_,_,_),
    (
        Reg = Reg2,
        UNUSED(Reg3)
        ;
        Reg = Reg3,
        UNUSED(Reg2)
    ),
    reg_nonnull(Reg,Reg_nn),
    !def_used(_,Reg_nn,EA,Op_index).

// NONE registers have 0 value
value_reg_at_operand(EA,Op_index,Reg,0,0,0,"complete"):-
    data_access(EA,Op_index,_,Reg2,Reg3,_,_,_),
    (
        Reg = Reg2,
        UNUSED(Reg3)
        ;
        Reg = Reg3,
        UNUSED(Reg2)
    ),
    Reg = "NONE".

/**
The address 'Address' is accessed from an instruction at address 'FromWhere'.
The access has size 'Size' and uses a multiplier 'Multiplier'.
*/
.decl data_access_pattern(Address:address,Size:unsigned,Multiplier:number,FromWhere:address)
.output data_access_pattern

/**
Auxiliary predicate that computes initial approximation of `data_access_pattern`
*/
.decl data_access_pattern_candidate(Address:address,Size:unsigned,Multiplier:number,FromWhere:address)
.output data_access_pattern_candidate

/**
The address at 'EA' is probably accessed using the same pattern as
the data access in 'AccessEA'. Preferred data accesses are computed
by propagating data accesses based on their multiplier.
*/
.decl preferred_data_access(EA:address,AccessEA:address)
.output preferred_data_access

//////////////////////////////////////////////////


//single access
data_access_pattern_candidate(Address,Size,0,EA):-
    data_access(EA,_,"NONE","NONE","NONE",_,Offset,Size),
    Address = as(Offset,address),
    data_segment(Beg,End),
    Address >= Beg,
    Address <= End.

// pc relative
data_access_pattern_candidate(Address,Size,0,EA):-
    code(EA),
    (
        pc_relative_operand(EA,Op_index,Address);
        split_load_operand(EA,Op_index,Address)
    ),
    instruction_memory_access_size(EA,Op_index,Size),
    data_segment(Beg,End),
    Address >= Beg,
    Address <= End.

// directly computed
data_access_pattern_candidate(Address,Size,Mult*Mult2,EA):-
    data_access(EA,Op_index,"NONE",RegBase,RegMult,Mult,Offset1,Size),
    !pc_relative_operand(EA,Op_index,_),
    !split_load_operand(EA,Op_index,_),
    RegMult != "NONE",
    RegMult != RegBase,
    value_reg_at_operand(EA,Op_index,RegMult,_,Mult2,Offset2,_),
    value_reg_at_operand(EA,Op_index,RegBase,_,0,Offset3,"complete"),
    // the absolute value of the multiplier cannot be
    // smaller that the size (unless we have 0 multiplier)
    (
        Mult*Mult2 > 0, as(Size,number) <= Mult*Mult2;
        Mult*Mult2 = 0;
        Mult*Mult2 < 0, as(Size,number) <= -(Mult*Mult2)
    ),
    Address = as(Offset1+(Offset2*Mult)+Offset3,address),
    data_segment(Beg,End),
    Address >= Beg,
    Address <= End.

// indirectly computed
data_access_pattern_candidate(Address,Size,Mult,EA):-
    data_access(EA,Op_index,"NONE",RegBase,RegMult,Mult2,Offset1,Size),
    !pc_relative_operand(EA,Op_index,_),
    !split_load_operand(EA,Op_index,_),
    RegMult != RegBase,
    value_reg_at_operand(EA,Op_index,RegMult,_,0,Offset2,"complete"),
    value_reg_at_operand(EA,Op_index,RegBase,_,Mult,Offset3,_),
    // the absolute value of the multiplier cannot be
    // smaller that the size (unless we have 0 multiplier)
    (
        Mult > 0, as(Size,number) <= Mult;
        Mult = 0;
        Mult < 0, as(Size,number) <= -Mult
    ),
    Address = as(Offset1+Offset2*Mult2+Offset3,address),
    data_segment(Beg,End),
    Address >= Beg,
    Address <= End.

//repeated register
data_access_pattern_candidate(Address,Size,FinalMult,EA):-
    data_access(EA,Op_index,"NONE",Reg,Reg,Mult,Offset1,Size),
    Reg != "NONE",
    value_reg_at_operand(EA,Op_index,Reg,_,Mult2,Offset2,_),
    FinalMult = Mult*Mult2+Mult2,
    (as(Size,number) <= FinalMult; FinalMult = 0),
    Address = as(Offset1+(Offset2*Mult)+Offset2, address),
    data_segment(Beg,End),
    Address >= Beg,
    Address <= End.

/**
Filter out some invalid DAP candidates before performing expensive aggregation
*/
.decl data_access_pattern_candidate_refined(Address:address,Size:unsigned,Multiplier:number,FromWhere:address)

data_access_pattern_candidate_refined(Address,Size,Multiplier,From):-
    data_access_pattern_candidate(Address,Size,Multiplier,From),
    instruction_get_operation(From,Operation),
    Operation != "LEA",
    (
        // if it is an indirect call or jump, the destination should be a potential address
        address_in_data(Address,_);
        !indirect_jump(From),
        !indirect_call(From)
    ).

/**
Unique DAP Address,Size pairs at which the max must be evaluated.

Prevents evaluating the max for each non-unique copy of the pair.
*/
.decl dap_location(Address:address,Size:unsigned)

dap_location(Address,Size):-
    data_access_pattern_candidate_refined(Address,Size,_,_).

/**
The largest multiplier for each Address,Size combination among the data access pattern candidates
*/
.decl dap_max_mult(Address:address,Size:unsigned,Max:number)

dap_max_mult(Address,Size,Max):-
    dap_location(Address,Size),
    Max = max Mult : data_access_pattern_candidate_refined(Address,Size,Mult,_).

data_access_pattern(Address,Size,Multiplier,From):-
    data_access_pattern_candidate_refined(Address,Size,Multiplier,From),
    dap_max_mult(Address,Size,Multiplier).

data_access_pattern(Address,Size,Multiplier,From):-
    data_access_pattern_candidate_refined(Address,Size,Multiplier,From),
    Multiplier = as(Size,number).

///////////////////////////////////////////////////////////////////////////////
// This code takes care of obtaining an ordering in the data_access_patterns.
// This ordering is later used to propagate data accesses.

/**
Data limits are the candidates for labeled data
and the boundaries of data segments.
*/
.decl possible_data_limit(EA:address)

possible_data_limit(EA):-
    labeled_data_candidate(EA);
    data_segment(_,EA);
    data_segment(EA,_).

/**
The next data limit after 'EA' is at 'Next'.
*/
.decl next_data_limit(EA:address,Next:address)

next_data_limit(EA,Next):-
    possible_data_limit(EA),
    Next = min Next : {possible_data_limit(Next), Next > EA},
    data_segment(Beg,End), EA >= Beg, Next <= End.

/**
The first data limit after the data access at address
'Access' is at address 'DataLimit'.
*/
.decl data_limit_after_access(Access:address,DataLimit:address)


data_limit_after_access(Access,DataLimit):-
    data_access_pattern(Access,_,_,_),
    DataLimit = min DataLimit : {possible_data_limit(DataLimit), DataLimit > Access},
    data_segment(Beg,End), Access >= Beg, DataLimit <= End.

/**
The next data access after the one at 'EA' is at 'Next'.
*/
.decl next_data_access(EA:address,Next:address)

next_data_access(EA,Next):-
    data_access_pattern(EA,_,_,_),
    Next = min Next : {data_access_pattern(Next,_,_,_), Next > EA},
    data_segment(Beg,End), EA >= Beg, Next <= End.


// FIXME: This predicate has been added to avoid exceptions when mult is 0
// due to https://github.com/souffle-lang/souffle/issues/1513
.decl data_access_pattern_non_zero(Address:address,Size:unsigned,Multiplier:unsigned,FromWhere:address)

data_access_pattern_non_zero(Address,Size,as(Mult,unsigned),FromWhere):-
    data_access_pattern(Address,Size,Mult,FromWhere), Mult > 0.


/**
'InitialEA' contains the first data access synchronous with 'SyncEA'.

Two data accesses are synchronous if:
1. The second access has multiplier 0 and it originates from the same address
  as the first.
2. Or, They have the same multiplier and the space between them
  means they do not collide with each other even if they are propagated.
*/
.decl first_synchronous_access(InitialEA:address,SyncEA:address)
.output first_synchronous_access

// the beginning of a synchronous access is
// the first access of a segment
first_synchronous_access(EA,EA):-
    data_access_pattern_non_zero(EA,_,_,_),
    !next_data_access(_,EA).

// Or an access whose previous access is not synchronous
first_synchronous_access(Next,Next):-
    data_access_pattern_non_zero(Next,Size2,Mult2,_),
    next_data_access(EA,Next),
    data_access_pattern(EA,Size,Mult_s,_),
    Mult_s>=0, Mult = as(Mult_s,unsigned),
    // this is the negation of the synchronous condition
    // simplified to skip the case 1 (Mult=0).
    (
        Mult2 != Mult,
        // avoid warnings
        UNUSED(Size),
        UNUSED(Size2)
        ;
        Mult2 = Mult,
        Rem = Next - EA % Mult2,
        (
            Rem < Size, Size2 = Size2;
            Mult2 - Rem < Size2, Size = Size
        )
    ).

first_synchronous_access(EA_ref,Next):-
    first_synchronous_access(EA_ref, EA),
    data_access_pattern_non_zero(EA_ref,Size,Mult,From),
    next_data_access(EA,Next),
    data_access_pattern(Next,Size2,Mult2,From2),
    Mult2_u = as(Mult2,unsigned),
    (
        Mult2_u=0,
        From2 = From,
        Size2 = Size,
        Next - EA_ref % Mult = 0
        ;
        Mult2_u = Mult,
        Rem = Next - EA % Mult,
        Size <= Rem,
        Size2 <= Mult - Rem
    ).

/**
The next data access after 'EA' that is not synchronous with 'EA'
is located at address 'Next'.
*/
.decl next_dyssynchronous_data_access(EA:address,Next:address)
.output next_dyssynchronous_data_access

next_dyssynchronous_data_access(EA,Next):-
    first_synchronous_access(EA,SyncEA), EA != SyncEA,
    next_data_access(SyncEA,Next),
    !first_synchronous_access(EA,Next).

/////////////////////////////////////////////
// The actual propagation of data accesses

preferred_data_access(EA,EA):-
    data_access_pattern(EA,_,Mult,_),
    data_byte(EA,_),
    // We only propagate data accesses with positive multipliers (for now)
    // This is just easier and gives us enough information.
    Mult >= 0.


// Data accesses with non-zero multiplier are propagated until the next
// dysynchronous data access or the next data limit, whichever comes first.
// This propagation is not recursive, it uses range to iterate.
preferred_data_access(EA_prop,EA_access):-
    data_access_pattern_non_zero(EA_access,_,Mult,_),
    data_byte(EA_access,_),
    (
        next_dyssynchronous_data_access(EA_access, Next_access),
        Limit = min(Next_access,Next_limit)
        ;
        !next_dyssynchronous_data_access(EA_access, _),
        Limit = Next_limit
    ),
    data_limit_after_access(EA_access, Next_limit),
    EA_prop = range(EA_access, Limit,Mult).
