.symbol_type register

.number_type address
.number_type operand_code
.number_type operand_index


#include "printable_chars.dl"
//#include "float_operations.dl"
#include "jump_operations.dl"

// infer what is code and what is not
#include "code_inference.dl"


// infer what is a pointer and what is not
// compute symbolic_operand, symbolic_data, labeled_data
// and strings
#include "symbolization.dl"

#include "function_inference.dl"

/////////////////////////////////////////////////////////////
// Inputs generated by the decoder
/////////////////////////////////////////////////////////////

// metadata
.decl entry_point(ea:address)
.input entry_point

.decl symbol(ea:address,n:number,type:symbol,scope:symbol,name:symbol)
.input symbol

.decl section(name:symbol,size:number,addr:address)
.input section

.decl relocation(ea:address,type:symbol,name:symbol,addend:number)
.input relocation


//FIXME: add eh_frames


.decl instruction(ea:address, size:number, opcode:symbol,
		  op1:operand_code, op2:operand_code, op3:operand_code)
.input instruction

.decl invalid_op_code(ea:address)
.input invalid_op_code

	
// three kinds of operators
.decl op_regdirect(code:operand_code,register_name:register)
.input op_regdirect

.decl op_immediate(code:operand_code,offset:number)
.input op_immediate

.decl op_indirect(code:operand_code,reg1:register, reg2:register, reg3:register,
		multiplier:number, offset:number, size_value:number)
.input op_indirect

//data from data sections

.decl data_byte(ea:address,value:number)
.input data_byte

.decl address_in_data(ea:address,value:number)

.input address_in_data


/////////////////////////////////////////////////////////////
// auxiliary definitions
/////////////////////////////////////////////////////////////

.decl instruction_get_operation(ea:address,operation:symbol) 

instruction_get_operation(EA,Operation):-
	instruction(EA,_,Operation,_,_,_).
	
.decl instruction_get_op(ea:address, index:number, operator:operand_code)

instruction_get_op(EA,Index,Op):-
	instruction(EA,_,_,Op1,Op2,Op3),
	(
	Op1!=0,
	Op=Op1,Index=1
	;
	Op2!=0,
	Op=Op2,Index=2
	;
	Op3!=0,
	Op=Op3,Index=3
	).

.decl instruction_get_dest_op(ea:address,index:number,op:operand_code)

instruction_get_dest_op(EA,Index,Op):-
	instruction(EA,_,Operation,_,Op2,Op3),
	!read_only_operation(Operation),
	(
	Op3=0,
	Op2!=0,
	Op=Op2,
	Index=2
	;
	Op3!=0,
	Op=Op3,
	Index=3
	).
instruction_get_dest_op(EA,1,Op):-
	instruction(EA,_,Operation,Op,0,0),
	one_op_write(Operation).


.decl instruction_get_src_op(ea:address,Index:operand_index,op:operand_code)

//when the dest is used as a source as well
instruction_get_src_op(EA,Index,Op2):-
	instruction(EA,_,_Operation,_,Op2,_),Op2!=0,
	Index=2,
	!mov(EA).
//	!read_only_operation(Operation).

instruction_get_src_op(EA,Index,Op):-
	(
	instruction(EA,_,_,Op,_,_),Op!=0,Index=1
	;
	instruction(EA,_,_,_,Op,Op3),Op!=0,Op3!=0,Index=2
	).
/////////////////////////////////////////////////////////////
// hard-coded facts
/////////////////////////////////////////////////////////////
.decl conditional_mov(EA:address)

conditional_mov(EA):-
	instruction_get_operation(EA,Operation),
	contains("CMOV",Operation).
	
.decl mov(EA:address)

mov(EA):-
	instruction_get_operation(EA,Operation),
	contains("MOV",Operation).	


.decl is_nop(EA:address)

is_nop(EA):-
    instruction_get_operation(EA,"NOP").

is_nop(EA):-
    instruction(EA,_,"XCHG",Op,Op,0),
    op_regdirect(Op,"AX").

.decl comparison_operation(Operation:symbol)

comparison_operation("CMP").
comparison_operation("TEST").

.decl read_only_operation(Operation:symbol)

read_only_operation("TEST").
read_only_operation("CMP").

.decl one_op_write(Operation:symbol)

one_op_write("INC").
one_op_write("DEC").

.decl null_reg(name:symbol)

null_reg("NullReg64").
null_reg("NullReg32").
null_reg("NullReg16").
null_reg("NullSReg").

.decl pointer_size(n:number) inline
pointer_size(8).

.decl data_section(name:symbol)

data_section(".rodata").
data_section(".data").
data_section(".bss").
data_section(".got").
data_section(".got.plt").
data_section(".init_array").
data_section(".fini_array").

	
.decl code_section(name:symbol)

code_section(".text").
code_section(".plt").
code_section(".plt.got").
code_section(".fini").
code_section(".init").



/////////////////////////////////////////////////////////////
// inference of basic facts
/////////////////////////////////////////////////////////////


.decl next(n:address,m:address)

next(EA,EA+Size):-
	instruction(EA,Size,_,_,_,_).
	
.decl pc_relative_operand(src:address,index:number, dest:address)
.output pc_relative_operand

pc_relative_operand(EA,Index,Dest):-
	pc_relative_operand_complete(EA,Index,Dest,_).

.decl pc_relative_operand_complete(src:address,index:number, dest:address, size:number)

pc_relative_operand_complete(EA,Index,EA_next+Offset,Size):-
	instruction_get_op(EA, Index, Op),
	op_indirect(Op,NullSReg,"RIP",NullReg1,1,Offset,Size),
	null_reg(NullSReg),
	null_reg(NullReg1),
	next(EA,EA_next).		
// JUMPS
.decl inconditional_jump(n:address)

inconditional_jump(EA):-
	instruction_get_operation(EA,"JMP").



// direct jumps
.decl direct_jump(src:address, dest:address)
.output direct_jump

direct_jump(EA,Dest):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_immediate(Op1,Dest).

direct_jump(EA,Dest):-
	instruction(EA,_,Operation,_,Op2,_),
	loop_operation(Operation),
	op_immediate(Op2,Dest).

.decl loop_operation(operation:symbol)

loop_operation("LOOP").
loop_operation("LOOPNE").
loop_operation("LOOPE").

// Special kinds of indirect jumps
// PC relative jumps
.decl pc_relative_jump(src:address, dest:address)
.output pc_relative_jump

pc_relative_jump(EA,Dest):-
	instruction_get_operation(EA,Operation),
	jump_operation(Operation),
	pc_relative_operand(EA,1,Dest).

	
// jump to the address of a register
// for now we do not compute anything about these

 .decl reg_jump(src:address)
// .output reg_jump

reg_jump(EA):-
 	instruction(EA,_,Operation,Op1,_,_),
 	jump_operation(Operation),
 	op_regdirect(Op1,_).
	
	
// indirect jump	

 .decl indirect_jump(src:address)
// .output indirect_jump

indirect_jump(EA):-
 	instruction(EA,_,Operation,Op1,_,_),
 	jump_operation(Operation),
 	op_indirect(Op1,_,_,_, _,_,_),
 	!pc_relative_jump(EA,_).


	
// CALLS
// direct calls
.decl direct_call(src:address, dest:address)
.output direct_call

direct_call(EA,Dest):-
	instruction(EA,_,"CALL",Op1,_,_),
	op_immediate(Op1,Dest).


.decl pc_relative_call(src:address,dest:address)
.output pc_relative_call

pc_relative_call(Src,Dest):-
	instruction_get_operation(Src,"CALL"),
	pc_relative_operand(Src,1,Dest).


// for now we do not compute anything about these
.decl reg_call(src:address)
.output reg_call

reg_call(EA):-
 	instruction(EA,_,"CALL",Op1,_,_),
 	op_regdirect(Op1,_).




 .decl indirect_call(src:address)
// .output indirect_call

indirect_call(EA):-
	instruction(EA,_,"CALL",Op1,_,_),
 	op_indirect(Op1,_,_,_,_,_,_),
 	!pc_relative_jump(EA,_).


// Returns
.decl return(n:address)

return(EA):-
	instruction_get_operation(EA,"Ret").

.decl halt(EA:address)

halt(EA):-
	instruction_get_operation(EA,"HLT").

halt(EA):-
	instruction_get_operation(EA,"UD2").

.decl ambiguous_symbol(name:symbol)
.output ambiguous_symbol

ambiguous_symbol(Name):-
        symbol(_,_,_,_,Name),
 	1< count :{symbol(_,_,_,_,Name)}.

// Function symbols
.decl function_symbol(ea:address,name:symbol)
.output function_symbol

function_symbol(EA,Name):-
	symbol(EA,_,"FUNC",_,Name).

/////////////////////////////////////////////////////////////

.decl may_fallthrough(o:address,d:address)

may_fallthrough(From,To):-
	next(From,To),
	!return(From),
	!inconditional_jump(From),
//	!no_return_call(From),
	!halt(From).
		
.decl must_fallthrough(o:address,d:address)

must_fallthrough(From,To):-
	may_fallthrough(From,To),
	!instruction_get_operation(From,"CALL").



.decl basic_target(ea:address)

// FIXME: add exception frame addresses

basic_target(Val):-
	address_in_data(_,Val).

basic_target(EA):-
	entry_point(EA).

basic_target(EA):-
	code_section(Name),
	section(Name,_,EA).

basic_target(EA):-
	function_symbol(EA,_).
	
	
////////////////////////////////////////////////////////////////////////////
// detect references  to libraries (calls to plt)
.decl plt_code_reference(ea:address, function:symbol)


plt_code_reference(EA,Function):-
	code(EA),
	instruction_get_op(EA,1,Op),
	op_immediate(Op,Dest),
	section(".plt",Size,Beg),
	Dest<Beg+Size,
	Dest>=Beg,
	pc_relative_jump(Dest,Got_entry),
	relocation(Got_entry,_,Function,_).

.decl plt_data_reference(ea:address, function:symbol)

plt_data_reference(EA,Function):-
	symbolic_data(EA,Dest),
	section(".plt",Size,Beg),
	Dest<Beg+Size,
	Dest>=Beg,
	pc_relative_jump(Dest,Got_entry),
	relocation(Got_entry,_,Function,_).

.decl plt_reference(ea:address, function:symbol)
.output plt_reference

plt_reference(EA,Function):-
	(
	plt_code_reference(EA,Function)
	;
	plt_data_reference(EA,Function)
	).

//////////////////////////////////////////////////////////////////////////
// find the main function even if it does not have a symbol
//

.decl main_function(ea:address)
.output main_function

main_function(EA):-
	function_symbol(EA,"main").
	
main_function(Main_location):-
	!function_symbol(Main_location,"main"),
	First_call= min EA:{
		    entry_point(Entry),
		    direct_call(EA,_),
		    code(EA),
		    EA>=Entry
		    	},
	next(Prev,First_call),
        code(Prev),
	symbolic_code_operand_candidate(Prev,1,Main_location).

.decl start_function(ea:address)
.output start_function

start_function(EA):-
	function_symbol(EA,"_start").
	
start_function(Start_location):-
	!function_symbol(Start_location,"_start"),
	entry_point(Start_location).
