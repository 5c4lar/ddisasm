//===- main.dl --------------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This is the main module of the datalog disassembler.
The disassembly has 3 main components:
 1- code_inference.dl
    -code_inference_postprocess.dl
    -cfg.dl
 2- symbolization.pl
    - use_def_analysis.dl
    - value_analysis.dl
    - data_access_analysis.dl
    - pointer_reatribution.dl

In addition there are several modules that consider special cases,
generic components and tables.

Special cases:
    -relative_jump_tables.dl

Generic components:
    -ordered_set.dl
    -empty_range.dl

Tables:
    -float_operations.dl
    -jump_operations.dl
    -printable_chars.dl

This module:
- defines the input generated by the decoder
- defines a series of auxiliary predicates and basic facts that are used everywhere.
- defines some hard-code parameters of the analysis, such as the code and data sections
  explored.
*/

.symbol_type register

.number_type address
.number_type operand_code
.number_type operand_index

// binary format specific predicates
#include "elf_binaries.dl"
#include "pe_binaries.dl"

// architecture specific predicates
#include "x64/arch_x64.dl"
#include "ARM/arch_arm.dl"

// tables with basic facts
#include "printable_chars.dl"


// Detection of relative jump tables
#include "relative_jump_tables.dl"

#include "exceptions.dl"

// Inference of instruction boundaries
#include "code_inference.dl"

// Performs literal-reference desambiguation
// and strings
#include "symbolization.dl"

// Inferece of function boundaries
#include "basic_function_inference.dl"

// predicates for debugging and statistics
#include "debug_stats.dl"
#include "self_diagnose.dl"
/////////////////////////////////////////////////////////////
// Inputs generated by the decoder
/////////////////////////////////////////////////////////////

// metadata
.decl entry_point(ea:address)
.input entry_point

.decl base_address(ea:address)
.input base_address

.decl symbol(ea:address,size:number,type:symbol,scope:symbol,sectionIndex:number,name:symbol)
.input symbol

.decl section_complete(name:symbol,size:number,addr:address,type:number,flags:number)
.input section_complete

.decl relocation(ea:address,type:symbol,name:symbol,addend:number)
.input relocation

.decl binary_type(Type:symbol)
.input binary_type

.decl binary_format(Format:symbol)
.input binary_format

.decl binary_isa(isa:symbol)
.input binary_isa


// instructions

.decl instruction_complete(ea:address, size:number, prefix:symbol, opcode:symbol,
          op1:operand_code, op2:operand_code, op3:operand_code, op4:operand_code,
          immOffset:number,displacementOffset:number, decodeMode: symbol)
.input instruction_complete

.decl instruction(ea:address, size:number, prefix:symbol, opcode:symbol,
          op1:operand_code, op2:operand_code, op3:operand_code, op4:operand_code, decodeMode: symbol)

instruction(EA,Size,Prefix,OpCode,Op1,Op2,Op3,Op4,DecodeMode):-
    instruction_complete(EA,Size,Prefix,OpCode,Op1,Op2,Op3,Op4,_,_,DecodeMode).

.decl invalid_op_code(ea:address,DecodeMode:symbol)
.input invalid_op_code

// three kinds of operators
.decl op_regdirect(code:operand_code,register_name:register)
.input op_regdirect

.decl op_immediate(code:operand_code,offset:number)
.input op_immediate

.decl op_indirect(code:operand_code,reg1:register, reg2:register, reg3:register,
        multiplier:number, offset:number, size_value:number)
.input op_indirect

// data from sections
.decl data_byte(ea:address,value:number)
.input data_byte

.decl address_in_data(ea:address,value:number)

.input address_in_data

///////////////////////////////////////////////////////////////
// Initialize components
#define X64_CODE 1
#define ARM_CODE 2

#if ISA == X64_CODE
    .init arch = X64
#else
    .init arch = ARM
    #include "arm_binaries.dl"
#endif

.init function_inference = basic_function_inference

/////////////////////////////////////////////////////////////
// auxiliary definitions
/////////////////////////////////////////////////////////////

.decl instruction_immediate_offset(EA:address,DecodeMode:symbol,Index:number,Offset:number)
.output instruction_immediate_offset

instruction_immediate_offset(EA,DecodeMode,Index,ImmediateOffset):-
    instruction_complete(EA,_,_,_,_,_,_,_,ImmediateOffset,_,DecodeMode),
    instruction_get_op(EA,DecodeMode,Index,Op),
    op_immediate(Op,_).

.decl instruction_displacement_offset(EA:address,DecodeMode:symbol,Index:number,Offset:number)
.output instruction_displacement_offset

instruction_displacement_offset(EA,DecodeMode,Index,DisplacementOffset):-
    instruction_complete(EA,_,_,_,_,_,_,_,_,DisplacementOffset,DecodeMode),
    instruction_get_op(EA,DecodeMode,Index,Op),
    op_indirect(Op,_,_,_,_,_,_).

.decl instruction_get_operation(ea:address,DecodeMode:symbol,operation:symbol) 

instruction_get_operation(EA,DecodeMode,Operation):-
    instruction(EA,_,_,Operation,_,_,_,_,DecodeMode).

.decl instruction_get_op(ea:address,DecodeMode:symbol, index:number, operator:operand_code)

instruction_get_op(EA,DecodeMode,Index,Op):-
    instruction(EA,_,_,_,Op1,Op2,Op3,Op4,DecodeMode),
    (
        Op1 != 0,
        Op = Op1, Index = 1
        ;
        Op2 != 0,
        Op = Op2, Index = 2
        ;
        Op3 != 0,
        Op = Op3, Index = 3
        ;
        Op4 != 0,
        Op = Op4, Index = 4
    ).

.decl instruction_get_dest_op(ea:address,DecodeMode:symbol,index:number,op:operand_code)

instruction_get_dest_op(EA,DecodeMode,Index,Op):-
    instruction(EA,_,_,Operation,_,Op2,Op3,Op4,DecodeMode),
    !arch.read_only_operation(Operation),
    (
        Op4 = 0,
        Op3 = 0,
        Op2 != 0,
        Op = Op2,
        Index = 2
        ;
        Op4 = 0,
        Op3 != 0,
        Op = Op3,
        Index = 3
        ;
        Op4 != 0,
        Op = Op4,
        Index = 4
    ).
instruction_get_dest_op(EA,DecodeMode,1,Op):-
    instruction(EA,_,_,Operation,Op,0,0,0,DecodeMode),
    arch.one_op_write(Operation).

.decl instruction_get_src_op(ea:address,DecodeMode:symbol,Index:operand_index,op:operand_code)

//when the dest is used as a source as well
instruction_get_src_op(EA,DecodeMode,Index,Op2):-
    instruction(EA,_,_,Operation,_,Op2,_,_,DecodeMode),Op2 != 0,
    Index = 2,
    !arch.mov(EA,DecodeMode),
    !arch.op_does_not_read_dest_reg(Operation),
    !arch.write_only_operation(Operation).

instruction_get_src_op(EA,DecodeMode,Index,Op):-
    (
        instruction(EA,_,_,Operation,Op,_,_,_,DecodeMode), Op != 0, Index = 1;
        instruction(EA,_,_,Operation,_,Op,Op3,_,DecodeMode), Op != 0, Op3 != 0, Index = 2;
        instruction(EA,_,_,Operation,_,_,Op,Op4,DecodeMode), Op != 0, Op4 != 0, Index = 3
    ),
    !arch.write_only_operation(Operation).

/////////////////////////////////////////////////////////////
// inference of basic facts
/////////////////////////////////////////////////////////////


.decl next(n:address,DecodeMode:symbol,m:address)

next(EA,DecodeMode,EA+Size):-
    instruction(EA,Size,_,_,_,_,_,_,DecodeMode).

.decl pc_relative_operand(src:address,DecodeMode:symbol,index:number, dest:address)
.output pc_relative_operand

pc_relative_operand(EA,DecodeMode,Index,EA_next+Offset):-
    instruction_get_op(EA,DecodeMode, Index, Op),
    op_indirect(Op,"NONE",Reg,"NONE",1,Offset,_),
    arch.pc_register(Reg),
    next(EA,DecodeMode,EA_next).

.decl instruction_has_loop_prefix(EA:address,DecodeMode:symbol)

instruction_has_loop_prefix(EA,DecodeMode):-
    instruction(EA,_,Prefix,_,_,_,_,_,DecodeMode),
    arch.loop_prefix(Prefix).

// JUMPS
.decl unconditional_jump(n:address,DecodeMode:symbol)

unconditional_jump(EA,DecodeMode):-
    arch.jump(EA,DecodeMode),
    instruction_get_operation(EA,DecodeMode,Operation),
    arch.unconditional_jump_operation(Operation).

.decl conditional_jump(src:address,DecodeMode:symbol)

conditional_jump(EA,DecodeMode):-
    arch.jump(EA,DecodeMode),
    instruction_get_operation(EA,DecodeMode,Operation),
    !arch.unconditional_jump_operation(Operation).


// direct jumps
.decl direct_jump(src:address,DecodeMode:symbol, dest:address, DecodeModeDest: symbol)
.output direct_jump

direct_jump(EA,DecodeMode,Dest,DecodeMode2):-
    arch.jump(EA,DecodeMode),
    instruction(EA,_,_,Operation,Op1,_,_,_,DecodeMode),
    op_immediate(Op1,Dest),
    (
        arch.switch_decode_mode_operation(Operation),
        arch.other_decode_mode(DecodeMode,DecodeMode2)
        ;
        !arch.switch_decode_mode_operation(Operation),
        DecodeMode2= DecodeMode
    ).

direct_jump(EA,DecodeMode,Dest,DecodeMode):-
    instruction(EA,_,_,Operation,_,Op2,_,_,DecodeMode),
    arch.loop_operation(Operation),
    op_immediate(Op2,Dest).

direct_jump(EA,DecodeMode,EA,DecodeMode):-
    instruction_has_loop_prefix(EA,DecodeMode).

// Special kinds of indirect jumps
// PC relative jumps
.decl pc_relative_jump(src:address,DecodeMode:symbol, dest:address, DecodeModeDest: symbol)
.output pc_relative_jump

pc_relative_jump(EA,DecodeMode,Dest,DecodeMode2):-
    arch.jump(EA,DecodeMode),
    instruction_get_operation(EA,DecodeMode,Operation),
    pc_relative_operand(EA,DecodeMode,1,Dest),
    (
        arch.switch_decode_mode_operation(Operation),
        arch.other_decode_mode(DecodeMode,DecodeMode2)
        ;
        !arch.switch_decode_mode_operation(Operation),
        DecodeMode2= DecodeMode
    ).

// jump to the address of a register
 .decl reg_jump(src:address,DecodeMode:symbol,Reg:symbol)

reg_jump(EA,DecodeMode,Reg):-
    arch.jump(EA,DecodeMode),
    instruction(EA,_,_,_,Op1,_,_,_,DecodeMode),
    op_regdirect(Op1,Reg).

// indirect jump
 .decl indirect_jump(src:address,DecodeMode:symbol)

indirect_jump(EA,DecodeMode):-
    arch.jump(EA,DecodeMode),
    instruction(EA,_,_,_,Op1,_,_,_,DecodeMode),
    op_indirect(Op1,_,_,_, _,_,_),
    !pc_relative_jump(EA,DecodeMode,_,_).

// CALLS
// direct calls
.decl direct_call(src:address,DecodeMode:symbol, dest:address, DecodeModeDest: symbol)
.output direct_call

direct_call(EA,DecodeMode,Dest,DecodeMode2):-
    arch.call_operation(Operation),
    instruction(EA,_,_,Operation,Op1,_,_,_,DecodeMode),
    op_immediate(Op1,Dest),
        (
        arch.switch_decode_mode_operation(Operation),
        arch.other_decode_mode(DecodeMode,DecodeMode2)
        ;
        !arch.switch_decode_mode_operation(Operation),
        DecodeMode2= DecodeMode
    ).


.decl pc_relative_call(src:address,DecodeMode:symbol,dest:address, DecodeModeDest: symbol)
.output pc_relative_call

pc_relative_call(Src,DecodeMode,Dest, DecodeMode2):-
    instruction_get_operation(Src,DecodeMode,Operation),
    arch.call_operation(Operation),
    pc_relative_operand(Src,DecodeMode,1,Dest),
        (
        arch.switch_decode_mode_operation(Operation),
        arch.other_decode_mode(DecodeMode,DecodeMode2)
        ;
        !arch.switch_decode_mode_operation(Operation),
        DecodeMode2= DecodeMode
    ).


// for now we do not compute anything about these
.decl reg_call(src:address,DecodeMode:symbol,reg:register)
.output reg_call

reg_call(EA,DecodeMode,Reg):-
    arch.call_operation(Operation),
    instruction(EA,_,_,Operation,Op1,_,_,_,DecodeMode),
    op_regdirect(Op1,Reg).

 .decl indirect_call(src:address,DecodeMode:symbol)
// .output indirect_call

indirect_call(EA,DecodeMode):-
    arch.call_operation(Operation),
    instruction(EA,_,_,Operation,Op1,_,_,_,DecodeMode),
    op_indirect(Op1,_,_,_,_,_,_),
    !pc_relative_call(EA,DecodeMode,_,_).

// Returns
.decl return(n:address,DecodeMode:symbol)

return(EA,DecodeMode):-
    arch.return_operation(Operation),
    instruction_get_operation(EA,DecodeMode,Operation).

.decl halt(EA:address,DecodeMode:symbol)

halt(EA,DecodeMode):-
    arch.halt_operation(Operation),
    instruction_get_operation(EA,DecodeMode,Operation).

//////////////////////////////////////////////////////////////////////////////////
// Operations to abstract features of instructions

.decl op_indirect_contains_reg(op:operand_code,reg:register)

// we ignore segment registers
op_indirect_contains_reg(Op,Reg_uniform):-
    op_indirect(Op,_,Reg2,_,_,_,_),
    arch.track_register(Reg2,Reg_uniform).

op_indirect_contains_reg(Op,Reg_uniform):-
    op_indirect(Op,_,_,Reg3,_,_,_),
    arch.track_register(Reg3,Reg_uniform).

.decl op_regdirect_contains_reg(op:operand_code,reg:register)

op_regdirect_contains_reg(Op,Reg_uniform):-
    op_regdirect(Op,Reg),
    arch.track_register(Reg,Reg_uniform).


// The instruction at EA has operation Operation and two operands: a register Reg and an immediate Immediate
.decl op_immediate_and_reg(EA:address,DecodeMode:symbol,Operation:symbol,Reg:register,Imm_index:number,Immediate:number)

op_immediate_and_reg(EA,DecodeMode,Operation,Reg,Imm_index,Immediate):-
    instruction_get_operation(EA,DecodeMode,Operation),
    instruction_get_op(EA,DecodeMode,Imm_index,Op),
    op_immediate(Op,Immediate),
    instruction_get_op(EA,DecodeMode,_,Op2),
    op_regdirect_contains_reg(Op2,Reg).

// The instruction at EA is a comparison between a register Reg and an immediate Immediate
.decl cmp_immediate_to_reg(EA:address,DecodeMode:symbol,Reg:register,Imm_index:number,Immediate:number)

cmp_immediate_to_reg(EA,DecodeMode,Reg,Imm_index,Immediate):-
    op_immediate_and_reg(EA,DecodeMode,Operation,Reg,Imm_index,Immediate),
    arch.cmp_operation(Operation).

/////////////////////////////////////////////////////////////////////////////////
.decl ambiguous_symbol(name:symbol)
.output ambiguous_symbol

ambiguous_symbol(Name):-
    symbol(_,_,_,_,_,Name),
    1 < count :{symbol(_,_,_,_,_,Name)}.

// Function symbols
.decl function_symbol(ea:address,name:symbol)
.output function_symbol

function_symbol(EA,Name):-
    symbol(EA,_,"FUNC",_,_,Name).

.decl defined_symbol(ea:address,size:number,type:symbol,scope:symbol,sectionIndex:number,name:symbol)

defined_symbol(EA,Size,Type,Scope,SectIndex,Name):-
    symbol(EA,Size,Type,Scope,SectIndex,Name),
    SHN_UNDEF = 0,
    SHN_LORESERVE = 65280,
    SHN_HIRESERVE = 65535,
    //the symbol is not undefined
    SectIndex != SHN_UNDEF,
    (SectIndex < SHN_LORESERVE; SectIndex > SHN_HIRESERVE).
////////////////////////////////////////////////////////////////////////////////////////

.decl section(name:symbol,size:number,addr:address)
.decl data_section(name:symbol)
.decl exception_section(name:symbol)
.decl special_data_section(name:symbol)
.decl regular_data_section(name:symbol)
.decl code_section(name:symbol)
.decl bss_section(name:symbol)
.output bss_section

regular_data_section(Name):-
    data_section(Name),
    !special_data_section(Name).

.decl non_zero_data_section(name:symbol)
.output non_zero_data_section

.decl bss_section_limits(Begin:address,End:address)
.output bss_section_limits

bss_section_limits(0,0):-
    !bss_section(_).

bss_section_limits(Begin,LastSect+SizeLast):-
    Begin = min X:{ bss_section(Name),section(Name,_,X)},
    LastSect = max X:{ bss_section(Name),section(Name,_,X)},
    section(_,SizeLast,LastSect).

/*
data segments can be data sections or fragments of the code section that
contain data instead of code.
*/
.decl initialized_data_segment(Begin:address,End:address)
.output initialized_data_segment

initialized_data_segment(Begin,Begin+Size):-
    non_zero_data_section(Section),
    section(Section,Size,Begin).

initialized_data_segment(Begin,End):-
    data_in_code(Begin,End).

.decl data_segment(Begin:address,End:address)

data_segment(Begin,Begin+Size):-
    data_section(Section),
    section(Section,Size,Begin).

data_segment(Begin,End):-
    initialized_data_segment(Begin,End).

////////////////////////////////////////////////////////////////////////////
// detect references  to libraries (calls to plt)
.decl plt_block(block:address,function:symbol)
.output plt_block

.decl got_reference(Got_entry:address,Symbol:symbol)
.output got_reference

.decl got_local_reference(Got_entry:address,Dest:address)
.output got_local_reference

//////////////////////////////////////////////////////////////////////////
// find special functions and symbols
.decl main_function(ea:address)

.decl inferred_symbol_name(ea:address,name:symbol,scope:symbol)
.output inferred_symbol_name

inferred_symbol_name(EA,"main","GLOBAL"):-
    binary_format("ELF"),
    main_function(EA).

.decl no_return_call(EA:address,DecodeMode:symbol)
.decl function_pointer_section(Name:symbol)

.decl no_return_function(Name:symbol)

no_return_call(EA,DecodeMode):-
    direct_call(EA,DecodeMode,Dest,_),
    plt_entry(Dest,Function),
    no_return_function(Function).
