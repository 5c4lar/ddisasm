//===- mips_binaries.dl --------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2020 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to abstract from MIPS specific instruction set
and characteristics
*/

instruction_get_dest_op(EA,Index,Op):-
    arch.store_operation(Operation),
    (
        instruction(EA,_,_,Operation,Op,_,_,_,_,_), Op != 0, Index = 1;
        instruction(EA,_,_,Operation,_,Op,Op3,_,_,_), Op != 0, Op3 != 0, Index = 2;
        instruction(EA,_,_,Operation,_,_,Op,Op4,_,_), Op != 0, Op4 != 0, Index = 3
    ),
    !arch.read_only_operation(Operation).

instruction_get_dest_op(EA,Index,Op):-
    !arch.store_operation(Operation),
    instruction(EA,_,_,Operation,_,Op2,Op3,Op4,_,_),
    !arch.read_only_operation(Operation),
    (
        Op4 = 0,
        Op3 = 0,
        Op2 != 0,
        Op = Op2,
        Index = 2
        ;
        Op4 = 0,
        Op3 != 0,
        Op = Op3,
        Index = 3
        ;
        Op4 != 0,
        Op = Op4,
        Index = 4
    ).

instruction_get_src_op(EA,Index,Op):-
    arch.store_operation(Operation),
    instruction(EA,_,_,Operation,_,Op2,Op3,Op4,_,_),
    !arch.write_only_operation(Operation),
    (
        Op4 = 0,
        Op3 = 0,
        Op2 != 0,
        Op = Op2,
        Index = 2
        ;
        Op4 = 0,
        Op3 != 0,
        Op = Op3,
        Index = 3
        ;
        Op4 != 0,
        Op = Op4,
        Index = 4
    ).

instruction_get_src_op(EA,Index,Op):-
    !arch.store_operation(Operation),
    (
        instruction(EA,_,_,Operation,Op,_,_,_,_,_), Op != 0, Index = 1;
        instruction(EA,_,_,Operation,_,Op,Op3,_,_,_), Op != 0, Op3 != 0, Index = 2;
        instruction(EA,_,_,Operation,_,_,Op,Op4,_,_), Op != 0, Op4 != 0, Index = 3
    ),
    !arch.write_only_operation(Operation).

// e.g., sw gp, 16(sp)
reg_stored_in_stack(EA,Reg,StackPos,StackFrameDefinedAt):-
    def_used(StackFrameDefinedAt,"SP",EA,_),
    arch.mov(EA),
    instruction_get_dest_op(EA,_,DestOp),
    op_indirect(DestOp,"NONE","SP","NONE",_,StackPos,_),
    instruction_get_src_op(EA,_,SrcOp),
    op_regdirect_contains_reg(SrcOp,Reg).

// e.g., lw gp, 16(fp)
reg_loaded_from_stack(EA,Reg,StackPos,StackFrameDefinedAt):-
    def_used(StackFrameDefinedAt,"FP",EA,_),
    arch.mov(EA),
    instruction_get_src_op(EA,_,SrcOp),
    op_indirect(SrcOp,"NONE","FP","NONE",_,StackPos,_),
    instruction_get_dest_op(EA,_,DestOp),
    op_regdirect_contains_reg(DestOp,Reg).

value_reg_edge(EALoad,"GP",EAPrev,"GP",1,0):-
    reg_stored_in_stack(EAStore,"GP",StackPos,StackFrameDefinedAt),
    reg_loaded_from_stack(EALoad,"GP",StackPos,StackFrameDefinedAt2),
    def_used(EAPrev,"GP",EAStore,_),
    // StackFrameDefinedAt2: move fp, sp
    def_used(StackFrameDefinedAt,Reg_origin,StackFrameDefinedAt2,_),
    arch.mov(StackFrameDefinedAt2),
    instruction_get_op(StackFrameDefinedAt2,1,Op1),
    op_regdirect_contains_reg(Op1,Reg_origin),
    instruction_get_op(StackFrameDefinedAt2,2,Op2),
    op_regdirect_contains_reg(Op2,Reg),
    StackFrameDefinedAt2 != StackFrameDefinedAt.

// addiu reg, zero, immediate
value_reg_edge(EA,Reg,EA,"NONE",0,Immediate):-
    instruction(EA,_,_,"ADDIU",Op1,Op2,Op3,0,_,_),
    op_immediate(Op2,Immediate),
    op_regdirect_contains_reg(Op3,Reg),
    op_regdirect_contains_reg(Op1,"ZERO").

// move reg, zero
value_reg_edge(EA,Reg,EA,"NONE",0,0):-
    arch.move_operation(Operation),
    instruction(EA,_,_,Operation,Op1,Op2,_,0,_,_),
    op_regdirect(Op1,Reg),
    op_regdirect(Op2,"ZERO").

// lui reg immediate
value_reg_edge(EA,Reg,EA,"NONE",0,Immediate*(2^16)):-
    op_immediate_and_reg(EA,"LUI",Reg,_,Immediate).

//addiu reg reg2 immediate
value_reg_edge(EA,Reg,EA_prev,Reg2,1,Immediate):-
    def_used(EA_prev,Reg2,EA,_),
    instruction(EA,_,_,"ADDIU",Op1,Op2,Op3,0,_,_),
    op_immediate(Op2,Immediate),
    op_regdirect_contains_reg(Op3,Reg),
    op_regdirect_contains_reg(Op1,Reg2),
    EA != EA_prev.

// load word from got table: e.g., lw v0, -32696(gp)
value_reg_edge(EA,Reg,EA,"NONE",0,Val):-
    instruction(EA,_,_,"LW",Op1,Op2,0,0,_,_),
    op_regdirect_contains_reg(Op2,Reg),
    op_indirect(Op1,"NONE","GP","NONE",_,Offset,_),
    def_used(EA_gp_def,"GP",EA,_),
    value_reg(EA_gp_def,"GP",_,"NONE",_,Immediate,_),
    Offset_addr = as(Immediate + Offset,address),
    data_word_be(Offset_addr, Val).

// lui reg3, hi(xxx)
// addiu reg2, reg3, lo(xxx)
// addu reg, reg2, t9 <--- (A)
// Get the value of reg at (A)
// NOTE: This assumes t9 holds the address of the current function, and
//       lui is the first instruction of the current function.
// TODO: Find a way of safely getting the function-entry address for t9.
value_reg_edge(EA,Reg,PrevEA1,Reg,1,as(PrevEA0,number)):-
    split_load(PrevEA0, PrevEA1, _, "ADDU"), // check on the idiom
    next(PrevEA1,EA),
    instruction_get_operation(EA, "ADDU"),
    instruction_get_dest_op(EA,_,DestOp),
    op_regdirect_contains_reg(DestOp,Reg).

// e.g., lw v0, -32696(gp)
gp_relative_operand(EA,Index,as(GpValue+Offset,address)):-
    instruction_get_op(EA, Index, Op),
    op_indirect(Op,"NONE","GP","NONE",1,Offset,_),
    def_used(EA_gp_def,"GP",EA,_),
    value_reg(EA_gp_def,"GP",_,"NONE",_,GpValue,_).

// Global entries
got_reference(GotEntry,Symbol):-
    symbol(_,_,_,_,_, ".dynsym",Index,Symbol),
    dynamic_entry("MIPS_GOTSYM",FirstIndex),
    dynamic_entry("MIPS_LOCAL_GOTNO",NumLocalEntries),
    Index >= FirstIndex,
    section(".got",Size,Beg),
    GotEntry = Beg + NumLocalEntries*4 + (Index-FirstIndex)*4.

// Local entries
got_reference(GotEntry,Symbol):-
    symbol(_,_,_,_,_,".dynsym",Index,Symbol),
    dynamic_entry("MIPS_GOTSYM",FirstIndex),
    Index < FirstIndex,
    section(".got",Size,Beg),
    Offset = Index*4 + 12,
    Size >= Offset,
    GotEntry = Beg + Offset.

// Compute an immediate load performed across two consecutive instructions
.decl split_load(ea:address, nextea:address, dest:address, type:symbol)
.output split_load

// E.g., lui reg, hi(xxx)
//       addiu reg2, reg, lo(xxx)
split_load(EA, NextEA, as(Base*2^16 + Offset,address), "ADDIU") :-
    // LUI <Register> <Immediate>
    // e.g. lui reg, BaseOp
    instruction_get_operation(EA, "LUI"),
    instruction_get_op(EA, 1, BaseOp),
    instruction_get_op(EA, 2, RegOp),
    op_immediate(BaseOp, Base),
    op_regdirect_contains_reg(RegOp,Reg),

    def_used(EA,Reg,NextEA,_),

    // ADDIU <Register> <Register> <Immediate>
    // e.g. addiu reg2, reg, <OffsetOp>
    instruction_get_operation(NextEA, "ADDIU"),
    instruction_get_op(NextEA, 1, RegOp2),
    op_regdirect_contains_reg(RegOp2,Reg),
    instruction_get_op(NextEA, 2, OffsetOp),
    op_immediate(OffsetOp, Offset).

// PIC
// E.g., lui reg, hi(xxx)
//       addiu reg2, reg, lo(xxx)
//       addu reg3, reg2, t9
split_load(EA, NextEA, as(Base*2^16 + Offset + T9Value,address), "ADDU") :-
    // LUI <Register> <Immediate>
    // e.g. lui reg, BaseOp
    instruction_get_operation(EA, "LUI"),
    instruction_get_op(EA, 1, BaseOp),
    instruction_get_op(EA, 2, RegOp),
    op_immediate(BaseOp, Base),
    op_regdirect_contains_reg(RegOp,Reg),

    def_used(EA,Reg,NextEA,_),

    // ADDIU <Register> <Register> <Immediate>
    // e.g. addiu reg2, reg, <OffsetOp>
    instruction_get_operation(NextEA, "ADDIU"),
    instruction_get_op(NextEA, 1, RegOp_),
    op_regdirect_contains_reg(RegOp_,Reg),
    instruction_get_op(NextEA, 2, OffsetOp),
    op_immediate(OffsetOp, Offset),
    instruction_get_op(NextEA, 3, RegOp__),
    op_regdirect_contains_reg(RegOp__,Reg2),

    def_used(NextEA,Reg2,NextEA2,_),

    // ADDU <Register> <Register> T9
    // e.g. addu reg2, reg, <OffsetOp>
    instruction_get_operation(NextEA2, "ADDU"),
    instruction_get_op(NextEA2, 1, Reg2Op),
    op_regdirect_contains_reg(Reg2Op,Reg2),
    instruction_get_op(NextEA2, 2, T9Op),
    op_regdirect_contains_reg(T9Op,"T9"),

    // NOTE: This assumes t9 holds the address of the current function, and
    //       lui is the first instruction of the current function.
    // TODO: Find a way of safely getting the function-entry address for t9.
    T9Value = as(EA, number).

// E.g., lui reg, hi(xxx)
//       lw reg2, lo(xxx)(reg)
//       lwc1, ldc1, etc.
split_load(EA, NextEA, as(Base*2^16 + Offset,address), "LW") :-
    // LUI <Register> <Immediate>
    // e.g. lui reg, BaseOp
    instruction_get_operation(EA, "LUI"),
    instruction_get_op(EA, 1, BaseOp),
    instruction_get_op(EA, 2, RegOp),
    op_immediate(BaseOp, Base),
    op_regdirect_contains_reg(RegOp,Reg),

    def_used(EA,Reg,NextEA,_),

    // Load <Register> <Indirect>
    // e.g. lw reg2, SrcOp(reg)
    instruction_get_operation(NextEA, Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(NextEA,_,SrcOp),
    op_indirect(SrcOp,"NONE",Reg,"NONE",1,Offset,_).

gp_relative_operand(EA, 1, as(Dest,address)):-
    split_load(EA, _, Dest, "ADDIU").

gp_relative_operand(EA, 2, as(Dest,address)):-
    split_load(_, EA, Dest, "ADDIU").

gp_relative_operand(EA, 1, as(Dest,address)):-
    split_load(EA, _, Dest, "ADDU").

gp_relative_operand(EA, 2, as(Dest,address)):-
    split_load(_, EA, Dest, "ADDU").

gp_relative_operand(EA, 1, as(Dest,address)):-
    split_load(EA, _, Dest, "LW").

gp_relative_operand(EA, 1, as(Dest,address)):-
    split_load(_, EA, Dest, "LW").

// Hi
symbolic_operand_attribute(EA, 1, "Part1"):-
    split_load(EA, _, Dest_addr, _),
    (
        data_segment(Begin,End),
        Dest_addr >= Begin,
        Dest_addr <= End
        ;
        symbol(Dest_addr,_,_,_,_,_,_,_)
        ;
        got_reference(Dest_addr,_)
    ).

// Lo
symbolic_operand_attribute(EA, Index, "Part0"):-
    (
        split_load(PrevEA, EA, Dest_addr, "ADDIU"),
        Index = 2
        ;
        split_load(PrevEA, EA, Dest_addr, "ADDU"),
        Index = 2
        ;
        split_load(PrevEA, EA, Dest_addr, "LW"),
        Index = 1
    ),
    (
        data_segment(Begin,End),
        Dest_addr >= Begin,
        Dest_addr <= End
        ;
        symbol(Dest_addr,_,_,_,_,_,_,_)
        ;
        got_reference(Dest_addr,_)
    ).

// E.g., lw t9, %got(puts)(gp)
symbolic_operand_attribute(EA,Index,"AddrRelGot"):-
    gp_relative_operand(EA,Index,Dest_addr),
    got_reference(Dest_addr,_).

symbolic_operand_candidate(EA,Op_index,Dest_addr,Type):-
  binary_type("EXEC"),
    code(EA),
    instruction_get_op(EA,Op_index,Op),
    gp_relative_operand(EA,Op_index,Dest_addr),
    (
        code(Dest_addr), Type="code"
        ;
        data_segment(Begin,End),
        Dest_addr >= Begin, Dest_addr <= End,
        Type = "data"
        ;
        symbol(Dest_addr,_,_,_,_,_,_,_),
        Type = "data"
    ).

symbolic_operand_point(EA,Op_index,1,"lookup-got"):-
    symbolic_operand_candidate(EA,Op_index,_,_),
    instruction_get_op(EA,Op_index,Op),
    op_indirect(Op,"NONE","GP","NONE",1,Offset,_),
    def_used_for_address(EA,_).
