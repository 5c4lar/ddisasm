//===- noreturn.dl ------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2022 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module performs an early noreturn analysis after code inference but before
use-def analysis begins. It is intended to eliminate CFG edges that may
otherwise produce spurious def_used instances.
*/

/**
Intraprocedural edges in an initial view of the CFG which we use for an early
noreturn analysis.
*/
.decl early_cfg_edge(Block:address,BlockNext:address)
.output early_cfg_edge

early_cfg_edge(Block,BlockNext):-
    block_last_instruction(Block,BlockEnd),
    may_fallthrough(BlockEnd,BlockNext),
    !inter_procedural_edge(BlockEnd,BlockNext).

early_cfg_edge(Block,BlockNext):-
    block_last_instruction(Block,BlockEnd),
    direct_jump(BlockEnd,BlockNext),
    !inter_procedural_edge(BlockEnd,BlockNext).

.type edge = [
    From: address,
    To: address
]

.type edge_list = [
    Head: edge,
    Tail: edge_list
]

/**
Assign ordering to edges to use when building a list.
*/
.decl early_cfg_next_edge(Node:address,PrevTo:address,NextTo:address)

early_cfg_next_edge(From,PrevTo,NextTo):-
    early_cfg_edge(From,PrevTo),
    NextTo = min T : {early_cfg_edge(From,T), T > PrevTo}.

/**
Build a list of the edges that we can process with a Functor.
*/
.decl early_cfg_edge_list(Edges:edge_list,Length:unsigned)

early_cfg_edge_list([[From,To],nil],1):-
    From = min F : {early_cfg_edge(F,_)},
    To = min T : {early_cfg_edge(From,T)},
    early_cfg_edge(From,To).

early_cfg_edge_list([[From,To],[[PrevFrom,PrevTo],Remainder]],Length+1):-
    early_cfg_edge_list([[PrevFrom,PrevTo],Remainder],Length),
    (
        // From the same node, but to a different node.
        early_cfg_next_edge(PrevFrom,PrevTo,To),
        From = PrevFrom
        ;
        // From the next node.
        !early_cfg_next_edge(PrevFrom,PrevTo,_),
        From = min F : {early_cfg_edge(F,_), F > PrevFrom},
        To = min T : {early_cfg_edge(From,T)}
    ).

// TODO: enable after we upgrade to Souffle 2.3
// Subsume smaller lists with longer lists - only the complete list should
// remain when this relation is complete.
/*
early_cfg_edge_list(_,Length1) <= early_cfg_edge_list(_,Length2):-
    Length1 < Length2.
*/

.type scc_id <: unsigned
.type address_list = [
    Head: address,
    Tail: address_list
]
.type scc_membership = [
    SCC: scc_id,
    Member: address
]
.type scc_membership_list = [
    Head: scc_membership,
    Tail: scc_membership_list
]

/**
Determine SCC membership of block. SCC IDs are arbitrary unsigned integers.
*/
.functor build_scc_list(Edges:edge_list):scc_membership_list stateful

/**
Unrolls a scc_membership_list generated by the functor build_scc_list.
*/
.decl early_cfg_scc_membership(SCCMembers:scc_membership_list)

// Generate list with functor
early_cfg_scc_membership(SCCMembers):-
    Length = max L : { early_cfg_edge_list(_,L) },
    early_cfg_edge_list(Edges,Length),
    SCCMembers = @build_scc_list(Edges).

// Unroll the list.
early_cfg_scc_membership(SCCMembers):-
    early_cfg_scc_membership([_,SCCMembers]).

/**
Deconstruct SCC membership list records
*/
.decl early_cfg_scc_member(SCC:scc_id,Member:address)
.output early_cfg_scc_member

early_cfg_scc_member(SCC,Member):-
    early_cfg_scc_membership([[SCC,Member],_]).

/**
The set of SCCs.
*/
.decl early_cfg_scc(SCC:scc_id)

early_cfg_scc(SCC):-
    early_cfg_scc_member(SCC,_).

/**
Edges between SCCs
*/
.decl early_cfg_scc_edge(FromSCC:scc_id,ToSCC:scc_id)
.output early_cfg_scc_edge

early_cfg_scc_edge(FromSCC,ToSCC):-
    early_cfg_scc_member(FromSCC,Block),
    early_cfg_edge(Block,BlockNext),
    early_cfg_scc_member(ToSCC,BlockNext),
    FromSCC != ToSCC.

/**
Number of outgoing edges from each SCC.
*/
.decl early_cfg_outgoing_edge_count(SCC:scc_id,Count:unsigned)
.output early_cfg_outgoing_edge_count

early_cfg_outgoing_edge_count(SCC,Count):-
    early_cfg_scc(SCC),
    Count = as(count : {early_cfg_scc_edge(SCC,_)},unsigned).

/**
Edges from a SCC not supported by the early noreturn analysis.
*/
.decl early_cfg_unsupported_scc_edge(SCC:scc_id)
.output early_cfg_unsupported_scc_edge

early_cfg_unsupported_scc_edge(SCC):-
    block_last_instruction(Block,BlockEnd),
    (
        pc_relative_jump(BlockEnd,_);
        indirect_jump(BlockEnd);
        reg_jump(BlockEnd,_);
        arch.return(BlockEnd);
        direct_jump(BlockEnd,BlockNext), inter_procedural_edge(BlockEnd,BlockNext);
        may_fallthrough(BlockEnd,BlockNext),inter_procedural_edge(BlockEnd,BlockNext)
    ),
    early_cfg_scc_member(SCC,Block).


/**
Calls to known no return functions or their PLT blocks.
*/
.decl no_return_call_refined(EA:address)

no_return_call_refined(EA):-
    no_return_call(EA).

// Find noreturn calls to plt_block instead of the earlier plt_entry
no_return_call_refined(EA):-
    direct_call(EA,Dest),
    plt_block(Dest,Function),
    no_return_function(Pattern),
    match(Pattern,Function).

/**
Discover no-return Blocks.

This is a underapproximation, since it cannot propagate through jumptables or
indirect calls (which are not yet resolved), or could call library functions
that are not known to be no-return.

The only situation where it would generate false-positive noreturns is if a
"known noreturn" library function does, in fact, return.
*/
.decl no_return_block(EA:address)
.output no_return_block

no_return_block(Block):-
    no_return_call_refined(BlockEnd),
    block_last_instruction(Block,BlockEnd).

no_return_block(Block):-
    no_return_block(BlockNext),
    (
        // If something must fallthrough to a no return block, it is also a no return block.
        must_fallthrough(BlockEnd,BlockNext)
        ;
        // In a direct call, it is not a "must_fallthrough" because the call may itself not return.
        // Either way, the block ending in the call cannot return.
        may_fallthrough(BlockEnd,BlockNext),
        direct_call(BlockEnd,_)
        ;
        // Conditionally jumps to a noreturn block, and the fallthrough is also a noreturn block.
        direct_jump(BlockEnd,BlockNext),
        arch.conditional(BlockEnd,_),
        may_fallthrough(BlockEnd,BlockNext2),
        no_return_block(BlockNext2)
        ;
        // Unconditional jump to a noreturn block
        direct_jump(BlockEnd,BlockNext),
        !arch.conditional(BlockEnd,_)
        ;
        // Unconditionally call a noreturn function.
        direct_call(BlockEnd,BlockNext),
        !arch.conditional(BlockEnd,_)
    ),
    block_last_instruction(Block,BlockEnd).

// If a block is a noreturn block, is a member of a SCC, and there is only one
// outgoing edge from the SCC, then the entire SCC must be noreturn.
no_return_block(SCCBlock):-
    no_return_block(Block),
    early_cfg_scc_member(ToSCC,Block),
    early_cfg_scc_edge(FromSCC,ToSCC),
    early_cfg_outgoing_edge_count(FromSCC,1),
    !early_cfg_unsupported_scc_edge(FromSCC),
    early_cfg_scc_member(FromSCC,SCCBlock).

// If a SCC has no outgoing edges, it is noreturn.
no_return_block(Block):-
    early_cfg_outgoing_edge_count(SCC,0),
    !early_cfg_unsupported_scc_edge(SCC),
    early_cfg_scc_member(SCC,Block).

/**
Calls to noreturn blocks.
*/
.decl no_return_call_propagated(EA:address)

no_return_call_propagated(EA):-
    no_return_call_refined(EA).

no_return_call_propagated(EA):-
    direct_call(EA,Block),
    no_return_block(Block),
    !pc_load_call(EA,Block).
