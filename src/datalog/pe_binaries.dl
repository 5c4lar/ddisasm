//===- pe_binaries.dl --------------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//

// This module defines predicates specific of PE binaries

.decl import_entry(Address:address,Ordinal:number,Function:symbol,Library:symbol)
.input import_entry

.decl export_entry(Address:address,Ordinal:number,Name:symbol)
.input export_entry

.decl pe_section_characteristics(Name:symbol,Mask:unsigned)

pe_section_characteristics("IMAGE_SCN_TYPE_NO_PAD",0x00000008).
pe_section_characteristics("IMAGE_SCN_CNT_CODE",0x00000020).
pe_section_characteristics("IMAGE_SCN_CNT_INITIALIZED_DATA",0x00000040).
pe_section_characteristics("IMAGE_SCN_CNT_UNINITIALIZED_DATA",0x00000080).
pe_section_characteristics("IMAGE_SCN_LNK_OTHER",0x00000100).
pe_section_characteristics("IMAGE_SCN_LNK_INFO",0x00000200).
pe_section_characteristics("IMAGE_SCN_LNK_REMOVE",0x00000800).
pe_section_characteristics("IMAGE_SCN_LNK_COMDAT",0x00001000).
pe_section_characteristics("IMAGE_SCN_GPREL",0x00008000).
pe_section_characteristics("IMAGE_SCN_MEM_PURGEABLE",0x00020000).
pe_section_characteristics("IMAGE_SCN_MEM_16BIT",0x00020000).
pe_section_characteristics("IMAGE_SCN_MEM_LOCKED",0x00040000).
pe_section_characteristics("IMAGE_SCN_MEM_PRELOAD",0x00080000).
pe_section_characteristics("IMAGE_SCN_ALIGN_1BYTES",0x00100000).
pe_section_characteristics("IMAGE_SCN_ALIGN_2BYTES",0x00200000).
pe_section_characteristics("IMAGE_SCN_ALIGN_4BYTES",0x00300000).
pe_section_characteristics("IMAGE_SCN_ALIGN_8BYTES",0x00400000).
pe_section_characteristics("IMAGE_SCN_ALIGN_16BYTES",0x00500000).
pe_section_characteristics("IMAGE_SCN_ALIGN_32BYTES",0x00600000).
pe_section_characteristics("IMAGE_SCN_ALIGN_64BYTES",0x00700000).
pe_section_characteristics("IMAGE_SCN_ALIGN_128BYTES",0x00800000).
pe_section_characteristics("IMAGE_SCN_ALIGN_256BYTES",0x00900000).
pe_section_characteristics("IMAGE_SCN_ALIGN_512BYTES",0x00A00000).
pe_section_characteristics("IMAGE_SCN_ALIGN_1024BYTES",0x00B00000).
pe_section_characteristics("IMAGE_SCN_ALIGN_2048BYTES",0x00C00000).
pe_section_characteristics("IMAGE_SCN_ALIGN_4096BYTES",0x00D00000).
pe_section_characteristics("IMAGE_SCN_ALIGN_8192BYTES",0x00E00000).
pe_section_characteristics("IMAGE_SCN_LNK_NRELOC_OVFL",0x01000000).
pe_section_characteristics("IMAGE_SCN_MEM_DISCARDABLE",0x02000000).
pe_section_characteristics("IMAGE_SCN_MEM_NOT_CACHED",0x04000000).
pe_section_characteristics("IMAGE_SCN_MEM_NOT_PAGED",0x08000000).
pe_section_characteristics("IMAGE_SCN_MEM_SHARED",0x10000000).
pe_section_characteristics("IMAGE_SCN_MEM_EXECUTE",0x20000000).
pe_section_characteristics("IMAGE_SCN_MEM_READ",0x40000000).
pe_section_characteristics("IMAGE_SCN_MEM_WRITE",0x80000000).

section(Name,Size,Addr):-
    binary_format("PE"),
    section_complete(Name,Size,Addr,_,_).

data_section(Section):-
    binary_format("PE"),
    section_complete(Section,_,_,_,Flags),
    pe_section_characteristics("IMAGE_SCN_CNT_INITIALIZED_DATA",Data),
    Flags band Data >0.

bss_section(Section),
data_section(Section):-
    binary_format("PE"),
    section_complete(Section,_,_,_,Flags),
    pe_section_characteristics("IMAGE_SCN_CNT_UNINITIALIZED_DATA",Data),
    Flags band Data >0.

code_section(Section):-
    binary_format("PE"),
    section_complete(Section,_,_,_,Flags),
    pe_section_characteristics("IMAGE_SCN_CNT_CODE",Exec),
    Flags band Exec >0.

// Entries of external libraries
symbol(0,0,"NONE","EXTERN",0,Function),
got_reference(Address,Function):-
    import_entry(Address,_,Function,_).

//PE binaries have plt-like entries
// These are no delimited to their own section
plt_block(EA,Function):-
    binary_format("PE"),
    pc_relative_jump(EA,Got_entry),
    unconditional_jump(EA),
    got_reference(Got_entry,Function),
    code_in_refined_block(EA,EA).

.decl base_relative_operand(EA:address,Index:operand_index,Dest:address)
.output base_relative_operand

base_relative_operand(EA_used,Op_index,as(Value,address)):-
    base_address(ImageBase),
    pc_relative_operand(EA_def,_,ImageBase),
    def_used(EA_def,_,EA_used,Op_index),
    instruction_get_op(EA_used,Op_index,Op),
    op_indirect(Op,_,_,_,_,Value,_), Value >= 0.

.decl base_relative_symbolic_operand(EA:address,Index:operand_index,Dest:address)

symbol_minus_symbol(EA+Disp_offset,Size/8,ImageBase,ImageBase+Value,1),
base_relative_symbolic_operand(EA,Op_index,Value):-
    base_relative_operand(EA,Op_index,Value),
    instruction_displacement_offset(EA,Op_index,Disp_offset),
    instruction_get_op(EA,Op_index,Op),
    op_indirect(Op,_,_,_,_,_,Size),
    base_address(ImageBase).

inferred_symbol_name(ImageBase,"__ImageBase","LOCAL"):-
    binary_format("PE"),
    base_address(ImageBase).

symbolic_operand_candidate(EA,Op_index,Dest,"imagebase"):-
    base_address(ImageBase),
    pc_relative_operand(EA,Op_index,Dest),
    Dest = ImageBase.

.decl base_relative_operation(EA_relop:address,EA:address)
.output base_relative_operation

base_relative_operation(EA_relop,EA_inst):-
    base_relative_operand(EA_relop,_,_),
    def_used(EA_relop,_,EA_inst,_).

base_relative_operation(EA_relop,EA_next):-
    base_relative_operand(EA_relop,_,_),
    def_used(EA_relop,_,EA_inst,_),
    def_used(EA_inst,_,EA_next,_).

.decl base_relative_jump(EA_relop:address,EA:address)
.output base_relative_jump

// TODO: narrow by restricting base_relative_operation chain to operations a
//       jump table address calculation would actually use.
base_relative_jump(EA_relop,EA):-
    reg_jump(EA,_),
    base_relative_operation(EA_relop,EA).

.decl base_relative_jump_table(EA:address,Value:address)
.output base_relative_jump_table

base_relative_jump_table(EA_jmp,ImageBase+Value):-
    base_address(ImageBase),
    base_relative_jump(EA_relop,EA_jmp),
    base_relative_operand(EA_relop,_,Value).

.decl base_relative_address(EA:address,Reference:address,Value:address)
.output base_relative_address

.decl base_relative_address_start(EA:address,Reference:address,Value:address)

base_relative_address(EA,EA,as(Val,address)),
base_relative_address_start(EA,EA,as(Val,address)):-
    base_relative_jump_table(_,EA),
    data_word(EA,4,Val),
    Val > 0.

base_relative_address(EA+4,Ref,as(Val,address)):-
    base_relative_address(EA,Ref,_),
    data_word(EA+4,4,Val),
    propagated_data_access(EA,4,Ref),
    !arch.is_nop(EA+4),
    !base_relative_address_start(EA+4,_,_),
    !data_access_pattern(EA+4,1,1,_),
    Val > 0.

labeled_data_candidate(EA):-
    base_relative_address_start(EA,_,_).

.decl base_relative_symbolic_data(EA:address,Size:unsigned,Value:address)

symbol_minus_symbol_jump_table(EA,TableStart,4,ImageBase,ImageBase+Val,"first",1),
base_relative_symbolic_data(EA,4,Val):-
    base_relative_address(EA,TableStart,Val),
    base_address(ImageBase),
    code(ImageBase+Val).

labeled_data_candidate(ImageBase+Dest):-
    base_address(ImageBase),
    base_relative_symbolic_operand(_,_,Dest),
    !base_relative_jump_table(_,ImageBase+Dest).

.decl dos_header_symbolic_operand(EA:address,Dest:unsigned)
.output dos_header_symbolic_operand

symbolic_expr_from_relocation(EA+Disp_offset,Size/8,"__ImageBase",as(Dest-ImageBase,number)),
dos_header_symbolic_operand(EA,Dest):-
    base_address(ImageBase),
    pc_relative_operand(EA,_,Dest),
    instruction_displacement_offset(EA,Op_index,Disp_offset),
    instruction_get_op(EA,Op_index,Op),
    op_indirect(Op,_,_,_,_,_,Size),
    Dest > ImageBase,
    Dest < ImageBase + 64.

// lea R8,QWORD PTR [$L_180016d58]  ; load offset-table
// mov R8,QWORD PTR [R8+RDX*8-16]   ; index into offset-table
// lea R9,QWORD PTR [$L_180015e50]  ; load base address
// add R8,R9
// call R8
// Detect potential label-relative offset table before data analyses.
relative_address_start(Table,8,Ref,Dest, "first"):-
    // loads table address
    take_address(EA1,Table),
    next(EA1,EA2),
    // indexes table
    arch.mov(EA2),
    next(EA2,EA3),
    // loads reference address
    take_address(EA3,Ref),
    data_word(Table,8,Diff),
    RefSigned = as(Ref,number),
    Dest = as(RefSigned + Diff,address),
    possible_ea(Dest).

// mov ECX,DWORD PTR [R9+R8*4+(IMAGEREL N_1a050)]
relative_address_start(ImageBase+OffsetUnsigned,MultUnsigned,ImageBase,Dest,"first"):-
    base_address(ImageBase),
    instruction_get_operation(EA,"MOV"),
    instruction_get_src_op(EA,_,Op),
    op_indirect(Op,_,RegBase,RegIndex,Mult,Offset,Size), Offset > 0,
    MultUnsigned = as(Mult, unsigned),
    OffsetUnsigned = as(Offset,unsigned),
    MultUnsigned * 8 = Size,
    RegBase != "NONE", RegIndex != "NONE",
    (MultUnsigned = 4; MultUnsigned = 8),
    data_word(ImageBase+OffsetUnsigned,MultUnsigned,Diff),
    ImageBaseSigned = as(ImageBase, number),
    Dest = as(ImageBaseSigned + Diff,address),
    possible_ea(Dest).

// Detect potential byte-offset, indirect jump-table index before data analyses.
// NOTE: This is essentially two levels of indirection, a table of single-byte
//       offsets for a second table of four-byte, imagebase-relative addresses.
// lea R14,[__ImageBase]
// ...
// movsxd RAX,EDX
// movzx EAX,BYTE PTR [R14+RAX*1+(IMAGEREL N_)]
// mov ECX,DWORD PTR [R14+RAX*4+(IMAGEREL N_)]
// add RCX,R14
// jmp RCX
relative_address_start(Table,1,Ref,Dest,"first"):-
    base_address(ImageBase),
    // base-relative table address load and index
    instruction_get_src_op(EA1,_,Op1),
    op_indirect(Op1,_,_,_,1,Offset1,8), Offset1 > 0,
    Table = ImageBase+as(Offset1,unsigned),
    data_byte(Table,Byte),
    // loads base-relative reference address
    next(EA1,EA2),
    instruction_get_src_op(EA2,_,Op2),
    op_indirect(Op2,_,_,_,4,Offset2,32), Offset2 > 0,
    Ref = ImageBase+as(Offset2,unsigned),
    Dest = Ref + Byte.

relative_address(EA+1,1,Ref,Dest,"first"):-
    base_address(ImageBase),
    relative_address(EA,1,Ref,_,"first"),
    data_byte(EA+1,Byte),
    Dest = Ref+Byte*4,
    data_word(Dest,4,Word),
    possible_ea(ImageBase+as(Word,unsigned)),
    !relative_address_start(EA+1,_,_,_,_).

symbol_minus_symbol_jump_table(EA,TableStart,1,Ref,Dest,"first",4):-
    relative_address(EA,1,Ref,Dest,"first"),
    // Byte offsets reference a preceding relative address table.
    relative_address_start(Ref,4,_,_,_),
    relative_address_start(ByteOffsetTable,1,Ref,_,_), Dest < ByteOffsetTable,
    // Note that TableStart references the RVA table not the byte offset table.
    TableStart = Ref.

// the call to main is right after the call to "__p___argc"
main_function(EA):-
    code(EA1),
    direct_call(EA1,PLT_ARGC),
    plt_block(PLT_ARGC,"__p___argc"),
    next(EA1,Block),
    code_in_refined_block(EA_call_main,Block),
    direct_call(EA_call_main,EA).

inferred_symbol_name(EA,"main","PUBLIC"):-
    binary_format("PE"),
    main_function(EA).

// Label addresses in data section that are exported.
labeled_data(EA):-
    export_entry(EA,_,_),
    data_section(Name),
    section(Name,Size,Addr),
    EA >= Addr,
    EA < Addr+Size.

is_padding(EA):-
    binary_format("PE"),
    instruction_get_operation(EA,"INT3").

// Off-cut base-relative reference to symbol:
//    e.g.  movzx EDX,BYTE PTR [RAX+RCX*1+((IMAGEREL N_180fa2570)+7)]
//                                                               ^^
moved_label_class(EA,Op_index,"base-relative collides with pointer"),
moved_label(EA,Op_index,ImageBase+Dest,NewDest):-
    base_address(ImageBase),
    base_relative_symbolic_operand(EA,Op_index,Dest),
    // Reference collides with a pointer.
    arch.pointer_size(Pt_size),
    address_in_data_refined_range.overlap(ImageBase+Dest,Pt_size,NewDest),
    symbolic_data(NewDest,_,_).
