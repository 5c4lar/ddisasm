//===- pe_binaries.dl --------------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//

// This module defines predicates specific of PE binaries

.decl data_directory(Address:address,Size:number,Type:symbol)
.input data_directory
.output data_directory


.decl import_entry(Address:address,Ordinal:number,Function:symbol,Library:symbol)
.input import_entry
.output import_entry

.decl pe_section_characteristics(Name:symbol,Mask:number)

pe_section_characteristics("IMAGE_SCN_TYPE_NO_PAD",0x00000008).
pe_section_characteristics("IMAGE_SCN_CNT_CODE",0x00000020).
pe_section_characteristics("IMAGE_SCN_CNT_INITIALIZED_DATA",0x00000040).
pe_section_characteristics("IMAGE_SCN_CNT_UNINITIALIZED_DATA",0x00000080).
pe_section_characteristics("IMAGE_SCN_LNK_OTHER",0x00000100).
pe_section_characteristics("IMAGE_SCN_LNK_INFO",0x00000200).
pe_section_characteristics("IMAGE_SCN_LNK_REMOVE",0x00000800).
pe_section_characteristics("IMAGE_SCN_LNK_COMDAT",0x00001000).
pe_section_characteristics("IMAGE_SCN_GPREL",0x00008000).
pe_section_characteristics("IMAGE_SCN_MEM_PURGEABLE",0x00020000).
pe_section_characteristics("IMAGE_SCN_MEM_16BIT",0x00020000).
pe_section_characteristics("IMAGE_SCN_MEM_LOCKED",0x00040000).
pe_section_characteristics("IMAGE_SCN_MEM_PRELOAD",0x00080000).
pe_section_characteristics("IMAGE_SCN_ALIGN_1BYTES",0x00100000).
pe_section_characteristics("IMAGE_SCN_ALIGN_2BYTES",0x00200000).
pe_section_characteristics("IMAGE_SCN_ALIGN_4BYTES",0x00300000).
pe_section_characteristics("IMAGE_SCN_ALIGN_8BYTES",0x00400000).
pe_section_characteristics("IMAGE_SCN_ALIGN_16BYTES",0x00500000).
pe_section_characteristics("IMAGE_SCN_ALIGN_32BYTES",0x00600000).
pe_section_characteristics("IMAGE_SCN_ALIGN_64BYTES",0x00700000).
pe_section_characteristics("IMAGE_SCN_ALIGN_128BYTES",0x00800000).
pe_section_characteristics("IMAGE_SCN_ALIGN_256BYTES",0x00900000).
pe_section_characteristics("IMAGE_SCN_ALIGN_512BYTES",0x00A00000).
pe_section_characteristics("IMAGE_SCN_ALIGN_1024BYTES",0x00B00000).
pe_section_characteristics("IMAGE_SCN_ALIGN_2048BYTES",0x00C00000).
pe_section_characteristics("IMAGE_SCN_ALIGN_4096BYTES",0x00D00000).
pe_section_characteristics("IMAGE_SCN_ALIGN_8192BYTES",0x00E00000).
pe_section_characteristics("IMAGE_SCN_LNK_NRELOC_OVFL",0x01000000).
pe_section_characteristics("IMAGE_SCN_MEM_DISCARDABLE",0x02000000).
pe_section_characteristics("IMAGE_SCN_MEM_NOT_CACHED",0x04000000).
pe_section_characteristics("IMAGE_SCN_MEM_NOT_PAGED",0x08000000).
pe_section_characteristics("IMAGE_SCN_MEM_SHARED",0x10000000).
pe_section_characteristics("IMAGE_SCN_MEM_EXECUTE",0x20000000).
pe_section_characteristics("IMAGE_SCN_MEM_READ",0x40000000).
pe_section_characteristics("IMAGE_SCN_MEM_WRITE",0x80000000).

section(Name,Size,Addr):-
    binary_format("PE"),
    section_complete(Name,Size,Addr,_,_).

data_section(Section):-
    binary_format("PE"),
    section_complete(Section,_,_,_,Flags),
    pe_section_characteristics("IMAGE_SCN_CNT_INITIALIZED_DATA",Data),
    Flags band Data >0.

bss_section(Section),
data_section(Section):-
    binary_format("PE"),
    section_complete(Section,_,_,_,Flags),
    pe_section_characteristics("IMAGE_SCN_CNT_UNINITIALIZED_DATA",Data),
    Flags band Data >0.

code_section(Section):-
    binary_format("PE"),
    section_complete(Section,_,_,_,Flags),
    pe_section_characteristics("IMAGE_SCN_CNT_CODE",Exec),
    Flags band Exec >0.

// Entries of external libraries
symbol(0,0,"NONE","EXTERN",0,Function),
got_reference(Address,Function):-
    import_entry(Address,_,Function,_).

//PE binaries have plt-like entries
// These are no delimited to their own section
plt_block(EA,Function):-
    pc_relative_jump(EA,Got_entry),
    unconditional_jump(EA),
    got_reference(Got_entry,Function),
    code_in_refined_block(EA,EA).

.decl base_relative_operand(EA:address,Index:number,Dest:address)
.output base_relative_operand

base_relative_operand(EA_used,Op_index,Value):-
    base_address(ImageBase),
    pc_relative_operand(EA_def,_,ImageBase),
    def_used(EA_def,_,EA_used,Op_index),
    instruction_get_op(EA_used,Op_index,Op),
    op_indirect(Op,_,_,_,_,Value,_).

.decl base_relative_symbolic_operand(EA:address,Index:number,Dest:address)

symbol_minus_symbol(EA+Disp_offset,Size/8,ImageBase,ImageBase+Value),
base_relative_symbolic_operand(EA,Op_index,Value):-
    base_relative_operand(EA,Op_index,Value),
    instruction_displacement_offset(EA,Op_index,Disp_offset),
    instruction_get_op(EA,Op_index,Op),
    op_indirect(Op,_,_,_,_,_,Size),
    base_address(ImageBase).

inferred_symbol_name(ImageBase,"__ImageBase","LOCAL"):-
    binary_format("PE"),
    base_address(ImageBase).

.decl base_relative_operation(EA_relop:address,EA:address)
.output base_relative_operation

base_relative_operation(EA_relop,EA_inst):-
    base_relative_operand(EA_relop,_,_),
    def_used(EA_relop,_,EA_inst,_).

base_relative_operation(EA_relop,EA_next):-
    base_relative_operand(EA_relop,_,_),
    def_used(EA_relop,_,EA_inst,_),
    def_used(EA_inst,_,EA_next,_).

.decl base_relative_jump(EA_relop:address,EA:address)
.output base_relative_jump

// TODO: narrow by restricting base_relative_operation chain to operations a
//       jump table address calculation would actually use.
base_relative_jump(EA_relop,EA):-
    reg_jump(EA,_),
    base_relative_operation(EA_relop,EA).

.decl base_relative_jump_table(EA:address,Value:number)
.output base_relative_jump_table

base_relative_jump_table(EA_jmp,ImageBase+Value):-
    base_address(ImageBase),
    base_relative_jump(EA_relop,EA_jmp),
    base_relative_operand(EA_relop,_,Value).

.decl base_relative_address(EA:address,Reference:address,Value:address)
.output base_relative_address

.decl base_relative_address_start(EA:address,Reference:address,Value:address)

base_relative_address(EA,EA,Val),
base_relative_address_start(EA,EA,Val):-
    base_relative_jump_table(_,EA),
    data_word(EA,4,Val).

base_relative_address(EA+4,Ref,Val):-
    base_relative_address(EA,Ref,_),
    data_word(EA+4,4,Val),
    // FIXME: Not working for sqlite /Ox
    // propagated_data_access(EA,4,Ref),
    !arch.is_nop(EA+4),
    !base_relative_address_start(EA+4,_,_),
    !data_access_pattern(EA+4,1,1,_),
    Val > 0.

.decl base_relative_symbolic_data(EA:address,Size:number,Value:address)

symbol_minus_symbol_candidate(EA,4,ImageBase,ImageBase+Val,"first"),
base_relative_symbolic_data(EA,4,Val):-
    base_relative_address(EA,_,Val),
    base_address(ImageBase),
    code(ImageBase+Val).

// TODO: Create use-def component for block candidates.
//   OR  Treat these as address arrays instead of jump tables?
//
// base_relative_operand relies on def_used, which will not stratify with the
// relative_address/block_points. This follows from the dependence of def_use on
// having already resolved the block candidates into blocks.
//
// Here we sort of "if it looks like a duck" we'll make it quack like one. We
// should implement a use-def for block candidates instead of this "special"
// move heuristic.

// mov ECX,DWORD PTR [R9+R8*4+(IMAGEREL N_1a050)]
relative_address(ImageBase+Offset,Mult,ImageBase+Offset,ImageBase+Val),
relative_address_start(ImageBase+Offset,Mult,ImageBase+Offset,ImageBase+Val):-
    base_address(ImageBase),
    instruction_get_operation(EA,"MOV"),
    instruction_get_src_op(EA,_,Op),
    op_indirect(Op,_,_,_,Mult,Offset,Size),
    Offset > 0,
    Mult * 8 = Size,
    (Mult = 4; Mult = 8),
    data_word(ImageBase+Offset,Mult,Val),
    possible_ea(ImageBase+Val).

relative_address(EA+Size,Size,Ref,ImageBase+Dest):-
    base_address(ImageBase),
    relative_address(EA,Size,Ref,_),
    data_word(EA+Size,Size,Dest),
    possible_ea(ImageBase+Dest),
    !relative_address_start(EA+Size,_,_,_).

labeled_data_candidate(ImageBase+Dest):-
    base_address(ImageBase),
    base_relative_symbolic_operand(_,_,Dest),
    !base_relative_jump_table(_,ImageBase+Dest).

.decl dos_header_symbolic_operand(EA:address,Dest:number)
.output dos_header_symbolic_operand

symbolic_expr_from_relocation(EA+Disp_offset,Size/8,"__ImageBase",Dest-ImageBase),
dos_header_symbolic_operand(EA,Dest):-
    base_address(ImageBase),
    pc_relative_operand(EA,_,Dest),
    instruction_displacement_offset(EA,Op_index,Disp_offset),
    instruction_get_op(EA,Op_index,Op),
    op_indirect(Op,_,_,_,_,_,Size),
    Dest > ImageBase,
    Dest < ImageBase + 64.

.decl relative_offset_table(EA:address,Size:number,Base:address,Dest:address)
.output relative_offset_table

// lea R8,QWORD PTR [$L_180016d58]  ; load offset-table
// mov R8,QWORD PTR [R8+RDX*8-16]   ; index offset-table
// lea R9,QWORD PTR [$L_180015e50]  ; load base address
// add R8,R9
// call R8
// Detect potential label-relative offset table before data analyses.
relative_address(Table,8,Ref,Dest),
relative_address_start(Table,8,Ref,Dest):-
    // loads table address
    take_address(EA1,Table),
    next(EA1,EA2),
    // indexes table
    instruction_get_operation(EA2,"MOV"),
    next(EA2,EA3),
    // loads reference address
    take_address(EA3,Ref),
    data_word(Table,8,Diff),
    Dest = Ref + Diff,
    possible_ea(Dest).

relative_address(EA+Size,Size,Ref,Dest):-
    binary_format("PE"), Size > 4,
    relative_address(EA,Size,Ref,_),
    data_word_maybe_zero(EA+Size,Size,Diff),
    Dest = Ref+Diff,
    possible_ea(Dest),
    !relative_address_start(EA+Size,_,_,_).

// Find the jump table precisely after we have the results of the analyses.
jump_table_start(EA_call,Size/8,EA,Base,"ADD"),
relative_offset_table(EA,Size/8,Base,Base+Offset):-
    // CALL register
    reg_call(EA_call,Reg_call),

    // which was defined in an ADD,
    def_used(EA_add,Reg_call,EA_call,_),
    instruction(EA_add,_,_,"ADD",_,_,_,_),

    // where one register is a base address
    def_used(EA_base,_,EA_add,_),
    instruction_get_operation(EA_base,"LEA"),
    pc_relative_operand(EA_base,_,Base),
    code(Base),

    // and the other an offset from an offset-table
    def_used(EA_index,Reg_index,EA_add,_),
    instruction_get_operation(EA_index,"MOV"),
    instruction_get_src_op(EA_index,_,Op_index),
    op_indirect(Op_index,_,Reg_index,_,Mult,_,Size),
    Mult * 8 = Size,

    // referencing the start of a table
    def_used(EA_table,Reg_index,EA_index,_),
    instruction_get_operation(EA_table,"LEA"),
    pc_relative_operand(EA_table,_,EA),
    data_word(EA,Size/8,Offset),
    code(Base+Offset).

.decl data_word_maybe_zero(EA:address,Size:number,Val:number)
data_word_maybe_zero(EA,8,Val):-
    data_byte(EA,Byte0),
    (binary_format("PE"); EA % 8 = 0),//jump tables are assumed to be aligned
    data_byte(EA+1,Byte1),
    data_byte(EA+2,Byte2),
    data_byte(EA+3,Byte3),
    data_byte(EA+4,Byte4),
    data_byte(EA+5,Byte5),
    data_byte(EA+6,Byte6),
    data_byte(EA+7,Byte7),

    Val =  (Byte7*2^56)  bor (Byte6*2^48)   bor (Byte5*2^40)  bor (Byte4*2^32) +
           (Byte3*2^24) bor (Byte2*2^16) bor (Byte1*2^8) bor Byte0.

symbol_minus_symbol_candidate(EA+Size,Size,Reference,Symbol,"first"):-
    relative_offset_table(_,Size,Reference,_),
    symbol_minus_symbol_candidate(EA,Size,Reference,_,"first"),
    !jump_table_start(_,_,EA+Size,_,_),
    data_word_maybe_zero(EA+Size,Size,Diff), Size > 1,
    Symbol = Reference + Diff,
    code(Symbol).
    // TODO: These would be nice, can we use them?
    // preferred_data_access(EA+Size,Label),
    // data_access_pattern(Label,Size,Size,_).

// the call to main is right after the call to "__p___argc"
main_function(EA):-
    code(EA1),
    direct_call(EA1,PLT_ARGC),
    plt_block(PLT_ARGC,"__p___argc"),
    next(EA1,Block),
    code_in_refined_block(EA_call_main,Block),
    direct_call(EA_call_main,EA).

inferred_symbol_name(EA,"main","PUBLIC"):-
    binary_format("PE"),
    main_function(EA).
