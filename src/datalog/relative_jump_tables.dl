//===- relative_jump_tables.dl ------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module deals exclusively with detecting jump tables with relative addresses.
*/


.decl data_word(EA:address,Size:unsigned,Val:number)

data_word(EA,2,Val):-
    data_byte(EA,Byte0),
    data_byte(EA+1,Byte1),
    Byte1 < 128,//the number is positive
    (
        Byte1 >= 128,//the number is negative
        (
            (endianness("LE"), Val = -(2^16 -as(Byte1*2^8 + Byte0,number)));
            (endianness("BE"), Val = -(2^16 -as(Byte0*2^8 + Byte1,number)))
        ),
        Val != 0
        ;
        Byte1 < 128,//the number is positive
        (
            (endianness("LE"), Val = as(Byte1*2^8 + Byte0,number));
            (endianness("BE"), Val = as(Byte0*2^8 + Byte1,number))
        )
    ).

data_word(EA,4,Val):-
    data_byte(EA,Byte0),
    data_byte(EA+1,Byte1),
    data_byte(EA+2,Byte2),
    data_byte(EA+3,Byte3),
    (
        Byte3 >= 128,//the number is negative
        (
            (endianness("LE"), Val = -(2^32 -as( Byte3*2^24+ Byte2*2^16 + Byte1*2^8 + Byte0,number)));
            (endianness("BE"), Val = -(2^32 -as( Byte0*2^24+ Byte1*2^16 + Byte2*2^8 + Byte3,number)))
        ),
        Val != 0
        ;
        Byte3 < 128,//the number is positive
        (
            (endianness("LE"), Val = as(Byte3*2^24+ Byte2*2^16 + Byte1*2^8 + Byte0,number));
            (endianness("BE"), Val = as(Byte0*2^24+ Byte1*2^16 + Byte2*2^8 + Byte3,number))
        )
    ).

data_word(EA,8,Val):-
    data_byte(EA,Byte0),
    data_byte(EA+1,Byte1),
    data_byte(EA+2,Byte2),
    data_byte(EA+3,Byte3),
    data_byte(EA+4,Byte4),
    data_byte(EA+5,Byte5),
    data_byte(EA+6,Byte6),
    data_byte(EA+7,Byte7),

    (
        (endianness("LE"), Val = as((Byte7*2^56) bor (Byte6*2^48) bor (Byte5*2^40) bor (Byte4*2^32) + (Byte3*2^24) bor (Byte2*2^16) bor (Byte1*2^8) bor Byte0,number));
        (endianness("BE"), Val = as((Byte0*2^56) bor (Byte1*2^48) bor (Byte2*2^40) bor (Byte3*2^32) + (Byte4*2^24) bor (Byte5*2^16) bor (Byte6*2^8) bor Byte7,number))
    ).


.decl take_address(Src:address,Address_taken:address)

take_address(Src,Address):-
    pc_relative_operand(Src,1,Address),
    instruction_get_operation(Src,"LEA").

/*
This detects potential jump tables even before any of the data analyses is performed.
It is used to find jump tables in the code section.

These jump tables seem to have entries of sizes 4 or 8 only.
Jump tables with entry sizes of 1 or 2 appear in data and can be detected later.

In these jump tables, the reference address coincides with the starting address
of the jump table.
*/
.decl relative_address(EA:address,Size:unsigned,TableStart:address,Reference:address,Dest:address,DestIsFirstOrSecond:symbol)
.output relative_address

.decl relative_address_start(EA:address,Size:unsigned,Reference:address,Dest:address, DestIsFirstOrSecond:symbol)

relative_address_start(EA,Size,EA,Dest,DestIsFirstOrSecond):-
    take_address(_,EA),
    EASigned = as(EA,number),
    data_word(EA,Size,Diff),
    (binary_format("PE"); EA % Size = 0), // jump tables are assumed to be aligned
    // Check if the second entry is reasonable, too.
    // This is based on the assumption that a jump-table consists of multiple
    // entries.
    data_word(EA+Size,Size,Diff2),
    // This is according to what we have seen generated by ICC
    (
        Size = 4, Diff <= 0, Diff2 <= 0
        ;
        Size = 8,
        // The read addresses are not regular pointers already
        !relocation(EA,_,_,_,_,_,_)
    ),
    // sometimes the jump table entry is Diff = Reference-JumpTarget
    // and sometimes it is Diff = JumpTarget-Reference
    (
        Dest = as(EASigned-Diff,address), DestIsFirstOrSecond = "second",
        Dest2 = as(EASigned-Diff2,address)
        ;
        Dest = as(EASigned+Diff,address), DestIsFirstOrSecond = "first",
        Dest2 = as(EASigned+Diff2,address)
    ),
    possible_ea(Dest),
    possible_ea(Dest2).

relative_address(EA,Size,EA,Ref,Dest,DestIsFirstOrSecond):-
    relative_address_start(EA,Size,Ref,Dest,DestIsFirstOrSecond).

relative_address(EA+Size,Size,TableStart,Ref,Dest,DestIsFirstOrSecond):-
    relative_address(EA,Size,TableStart,Ref,_,DestIsFirstOrSecond),
    data_word(EA+Size,Size,Diff),
    RefSigned = as(Ref,number),
    (
        DestIsFirstOrSecond = "second", Dest = as(RefSigned-Diff,address),Size >= 4;
        DestIsFirstOrSecond = "first", Dest = as(RefSigned+Diff,address)
    ),
    possible_ea(Dest),
    !relative_address_start(EA+Size,_,_,_,_).

///////////////////////////////////////////////////////////////////////////////////////////////////////
// detect jump tables precisely once we have all results of the analyses


// auxiliary predicate for detecting accessing an element of a jump table.
.decl jump_table_element_access(EA:address,Size:unsigned,TableStart:address)

jump_table_element_access(EA,Size,TableStartAddr):-
    data_access(EA,_,"NONE","NONE",RegIndex,as(Size,number),TableStart,Size),
    TableStartAddr = as(TableStart,address),
    RegIndex != "NONE",
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

jump_table_element_access(EA,1,TableStartAddr):-
    data_access(EA,_,"NONE",RegBase,"NONE",_,TableStart,1),
    TableStartAddr = as(TableStart,address),
    RegBase != "NONE",
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

jump_table_element_access(EA,Size,TableStartAddr):-
    data_access(EA,_,"NONE",RegBase,RegIndex,as(Size,number),Offset,Size),
    RegIndex != "NONE",
    def_used(EA_regdef,RegBase,EA,_),
    value_reg(EA_regdef,RegBase,_,"NONE",0,Base,_),
    TableStartAddr = as(Base+Offset,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

// sometimes the regBase contains the index (already multiplied)
// and the regIndex contains the base address
jump_table_element_access(EA,Size,TableStartAddr):-
    data_access(EA,_,"NONE",RegBase,RegIndex,1,0,Size),
    RegBase != "NONE",
    def_used(EA_regdef,RegIndex,EA,_),
    value_reg(EA_regdef,RegIndex,_,"NONE",0,TableStart,_),
    TableStartAddr = as(TableStart,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.


.decl jump_table_start(EA_jump:address,Size:unsigned,TableStart:address,TableRef:address,Scale:number)
.output jump_table_start

jump_table_start(EA_jump,Size,TableStart,as(Base,address),Scale):-
    // Looks like a jump table access occurs at EA...
    jump_table_element_access(EA,Size,TableStart),
    // ...and the register defined at EA (Reg) is used as RegJump = Base + Reg * Scale
    value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
    Reg != "NONE",
    // ...and something jumps to that register.
    def_used(EA_add,RegJump,EA_jump,_),
    (
        reg_call(EA_jump,_);
        reg_jump(EA_jump,_)
    ),
    code(EA_jump).

//  mov REG, TableReference
//  add REG, SIZE PTR [_*Size+TableStart] OR sub REG, SIZE PTR [_*Size+TableStart]
//  jmp REG
jump_table_start(EA_jump,Size,TableStart,TableReferenceAddr,Scale):-
    reg_jump(EA_jump,_),
    code(EA_jump),
    def_used(EA_base,Reg,EA_jump,_),
    instruction_get_operation(EA_base,Operation),
    (
        Operation = "ADD", Scale=1;
        Operation = "SUB", Scale=-1
    ),
    jump_table_element_access(EA_base,Size,TableStart),
    def_used(EA_def_ref,Reg,EA_base,_),
    value_reg(EA_def_ref,Reg,_,"NONE",0,TableReference,_),
    TableReferenceAddr = as(TableReference,address),
    (
        code(TableReferenceAddr);
        TableStart=TableReferenceAddr
    ).

// mov EAX,DWORD PTR [ECX+EAX*4+.L_804a008@GOTOFF]   load
// add EAX,ECX                                       base
// jmp EAX                                           jump
jump_table_start(EA_jump,4,TableStart,TableReference,1):-
    binary_isa("X86"),
    got_reference_pointer(TableReference),
    // Load offset.
    got_relative_operand(EA_load,1,TableStart),
    def_used(EA_load,Reg_got,EA_base,_),
    // Base is GOT.
    arch.reg_reg_arithmetic_operation(EA_base,Reg_jump,Reg_got,_,1,0),
    // Jump to register.
    def_used(EA_base,_,EA_jump,_),
    reg_jump(EA_jump,Reg_jump).

///////////////////////////////////////////////////////////////////////////////////////////////////////
// propagate jump tables

/**
An entry in a relative jump table of the form (Dest-Reference)/Scale

These are generated during value analysis, and referenced by value analysis,
so cannot negate any results of value analysis.

Some of these are discarded to form relative_jump_table_entry, which is used by
symbolization.
*/
.decl relative_jump_table_entry_candidate(EA:address,TableStart:address,Size:unsigned,Reference:address,Dest:address,Scale:number,Offset:number)
.output relative_jump_table_entry_candidate

relative_jump_table_entry_candidate(TableStart,TableStart,Size,TableReference,Dest,Scale,0):-
    !binary_isa("ARM"),
    jump_table_start(_,Size,TableStart,TableReference,Scale),
    (
        Size > 1,data_word(TableStart,Size,Diff);
        Size = 1,data_byte(TableStart,DiffUnsigned), Diff = as(DiffUnsigned,number)
    ),
    TableReference_signed = as(TableReference,number),
    Dest = as(TableReference_signed + as(Scale,number)*Diff,unsigned),
    code(Dest),
    // The table is in a loaded section.
    section(_,SectionSize,SectionStart),
    TableStart >= SectionStart, TableStart < (SectionStart + SectionSize).

// propagate until finding:
// * something that doesn't resolve to a code pointer.
// * a symbol
// * the end of a data section

// we can't do much better without negating something or adding an entirely
// new boundary value analysis to analyze comparisons on the jump table index
// register.
relative_jump_table_entry_candidate(EA+Size,TableStart,Size,Reference,Dest,Scale,Offset):-
    !binary_isa("ARM"),
    relative_jump_table_entry_candidate(EA,TableStart,Size,Reference,_,Scale,Offset),
    !symbol(EA+Size,_,_,_,_,_,_,_,_),
    !data_segment(_,EA+Size),
    (
        Size>1,data_word(EA+Size,Size,Diff);
        Size=1,data_byte(EA+Size,DiffUnsigned), Diff = as(DiffUnsigned,number)
    ),
    Reference_signed = as(Reference,number),
    Dest = as(Reference_signed + as(Scale,number)*Diff,unsigned),
    code(Dest).

.decl discarded_jump_table_entry(TableStart:address,EA:address)
.output discarded_jump_table_entry

// Truncate a jump table if a separate data access is encountered.
discarded_jump_table_entry(TableStart,EA):-
    relative_jump_table_entry_candidate(EA,TableStart,_,_,_,_,_),
    possible_data_limit(EA),
    EA != TableStart.

// Recursively discard after truncation
discarded_jump_table_entry(TableStart,EA):-
    discarded_jump_table_entry(TableStart,DiscardEA),
    jump_table_start(_,Size,TableStart,_,_),
    EA = DiscardEA + Size,
    relative_jump_table_entry_candidate(EA,TableStart,Size,_,_,_,_).

/**
An entry in a relative jump table of the form (Dest-Reference)/Scale.

These are generated after value analysis, and used for symbolization and final
CFG generation. This allows using the final results of value analysis to
resolve overlapping jump tables.
*/
.decl relative_jump_table_entry(EA:address,TableStart:address,Size:unsigned,Reference:address,Dest:address,Scale:number,Offset:number)
.output relative_jump_table_entry

relative_jump_table_entry(EA,TableStart,Size,Reference,Dest,Scale,Offset):-
    relative_jump_table_entry_candidate(EA,TableStart,Size,Reference,Dest,Scale,Offset),
    !discarded_jump_table_entry(TableStart,EA).
