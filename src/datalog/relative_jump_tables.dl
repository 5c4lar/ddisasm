//===- relative_jump_tables.dl ------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module deals exclusively with detecting jump tables with relative addresses.
*/


.decl data_word(EA:address,Size:number,Val:number)
.output data_word

data_word(EA,2,Val):-
    data_byte(EA,Byte0), EA % 2 = 0,//jump tables are assumed to be aligned
    data_byte(EA+1,Byte1),
    Byte1 < 128,//the number is positive
    Val = Byte1*2^8 + Byte0.

data_word(EA,4,Val):-
    data_byte(EA,Byte0), EA % 4 = 0,//jump tables are assumed to be aligned
    data_byte(EA+1,Byte1),
    data_byte(EA+2,Byte2),
    data_byte(EA+3,Byte3),
    Byte3 >= 128,//the number is negative
    Val = -(2^32 -( Byte3*2^24+ Byte2*2^16 + Byte1*2^8 + Byte0)),
    Val != 0.

data_word(EA,8,Val):-
    data_byte(EA,Byte0), EA % 8 = 0,//jump tables are assumed to be aligned
    data_byte(EA+1,Byte1),
    data_byte(EA+2,Byte2),
    data_byte(EA+3,Byte3),
    data_byte(EA+4,Byte4),
    data_byte(EA+5,Byte5),
    data_byte(EA+6,Byte6),
    data_byte(EA+7,Byte7),

    Val =  (Byte7*2^56)  bor (Byte6*2^48)   bor (Byte5*2^40)  bor (Byte4*2^32) +
           (Byte3*2^24) bor (Byte2*2^16) bor (Byte1*2^8) bor Byte0,
    Val != 0.


.decl take_address(Src:address,Address_taken:address)

take_address(Src,Address):-
    pc_relative_operand(Src,1,Address),
    instruction_get_operation(Src,"LEA").

/*
This detects potential jump tables even before any of the data analyses is performed.
It is used to find jump tables in the code section.

*/
.decl relative_address(EA:address,Size:number,Reference:address,Dest:address)
.output relative_address

.decl relative_address_start(EA:address,Size:number,Reference:address,Dest:address)

relative_address(EA,Size,EA,Dest),
relative_address_start(EA,Size,EA,Dest):-
    take_address(_,EA),
    data_word(EA,Size,Diff),
    Size >= 4,
    (
        Dest = EA-Diff;
        Dest = EA+Diff
    ),
    possible_ea(Dest).

relative_address(EA+Size,Size,Ref,Dest):-
    relative_address(EA,Size,Ref,_),
    data_word(EA+Size,Size,Diff),
    (
        Dest = Ref-Diff,Size >= 4;
        Dest = Ref+Diff
    ),
    possible_ea(Dest),
    !relative_address_start(EA+Size,_,_,_).
