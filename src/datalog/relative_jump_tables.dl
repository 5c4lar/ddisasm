//===- relative_jump_tables.dl ------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module deals exclusively with detecting jump tables with relative addresses.
*/


.decl data_word(EA:address,Size:unsigned,Val:number)

data_word(EA,2,Val):-
    data_byte(EA,Byte0),
    data_byte(EA+1,Byte1),
    (
        Byte1 >= 128,//the number is negative
        (
            (endianness("LE"), Val = -(2^16 -as(Byte1*2^8 + Byte0,number)));
            (endianness("BE"), Val = -(2^16 -as(Byte0*2^8 + Byte1,number)))
        ),
        Val != 0
        ;
        Byte1 < 128,//the number is positive
        (
            (endianness("LE"), Val = as(Byte1*2^8 + Byte0,number));
            (endianness("BE"), Val = as(Byte0*2^8 + Byte1,number))
        )
    ).

data_word(EA,4,Val):-
    data_byte(EA,Byte0),
    data_byte(EA+1,Byte1),
    data_byte(EA+2,Byte2),
    data_byte(EA+3,Byte3),
    (
        Byte3 >= 128,//the number is negative
        (
            (endianness("LE"), Val = -(2^32 -as( Byte3*2^24+ Byte2*2^16 + Byte1*2^8 + Byte0,number)));
            (endianness("BE"), Val = -(2^32 -as( Byte0*2^24+ Byte1*2^16 + Byte2*2^8 + Byte3,number)))
        ),
        Val != 0
        ;
        Byte3 < 128,//the number is positive
        (
            (endianness("LE"), Val = as(Byte3*2^24+ Byte2*2^16 + Byte1*2^8 + Byte0,number));
            (endianness("BE"), Val = as(Byte0*2^24+ Byte1*2^16 + Byte2*2^8 + Byte3,number))
        )
    ).

data_word(EA,8,Val):-
    data_byte(EA,Byte0),
    data_byte(EA+1,Byte1),
    data_byte(EA+2,Byte2),
    data_byte(EA+3,Byte3),
    data_byte(EA+4,Byte4),
    data_byte(EA+5,Byte5),
    data_byte(EA+6,Byte6),
    data_byte(EA+7,Byte7),

    (
        (endianness("LE"), Val = as((Byte7*2^56) bor (Byte6*2^48) bor (Byte5*2^40) bor (Byte4*2^32) + (Byte3*2^24) bor (Byte2*2^16) bor (Byte1*2^8) bor Byte0,number));
        (endianness("BE"), Val = as((Byte0*2^56) bor (Byte1*2^48) bor (Byte2*2^40) bor (Byte3*2^32) + (Byte4*2^24) bor (Byte5*2^16) bor (Byte6*2^8) bor Byte7,number))
    ).

.decl take_address(Src:address,Address_taken:address)

take_address(Src,Address):-
    pc_relative_operand(Src,1,Address),
    instruction_get_operation(Src,"LEA").

/*
This detects potential jump tables even before any of the data analyses is performed.
It is used to find jump tables in the code section.

These jump tables seem to have entries of sizes 4 or 8 only.
Jump tables with entry sizes of 1 or 2 appear in data and can be detected later.

In these jump tables, the reference address coincides with the starting address
of the jump table.
*/
.decl relative_address(EA:address,Size:unsigned,TableStart:address,Reference:address,Dest:address,DestIsFirstOrSecond:symbol)
.output relative_address

.decl relative_address_start(EA:address,Size:unsigned,Reference:address,Dest:address, DestIsFirstOrSecond:symbol)

relative_address_start(EA,Size,EA,Dest,DestIsFirstOrSecond):-
    take_address(_,EA),
    EASigned = as(EA,number),
    data_word(EA,Size,Diff),
    // Check if the second entry is reasonable, too.
    // This is based on the assumption that a jump-table consists of multiple
    // entries.
    data_word(EA+Size,Size,Diff2),
    // This is according to what we have seen generated by ICC
    (
        Size = 4, Diff <= 0, Diff2 <= 0
        ;
        Size = 8,
        // The read addresses are not regular pointers already
        !relocation(EA,_,_,_,_,_,_)
    ),
    // sometimes the jump table entry is Diff = Reference-JumpTarget
    // and sometimes it is Diff = JumpTarget-Reference
    (
        Dest = as(EASigned-Diff,address), DestIsFirstOrSecond = "second",
        Dest2 = as(EASigned-Diff2,address)
        ;
        Dest = as(EASigned+Diff,address), DestIsFirstOrSecond = "first",
        Dest2 = as(EASigned+Diff2,address)
    ),
    possible_ea(Dest),
    possible_ea(Dest2).

relative_address(EA,Size,EA,Ref,Dest,DestIsFirstOrSecond):-
    relative_address_start(EA,Size,Ref,Dest,DestIsFirstOrSecond).

relative_address(EA+Size,Size,TableStart,Ref,Dest,DestIsFirstOrSecond):-
    relative_address(EA,Size,TableStart,Ref,_,DestIsFirstOrSecond),
    data_word(EA+Size,Size,Diff),
    RefSigned = as(Ref,number),
    (
        DestIsFirstOrSecond = "second", Dest = as(RefSigned-Diff,address),Size >= 4;
        DestIsFirstOrSecond = "first", Dest = as(RefSigned+Diff,address)
    ),
    possible_ea(Dest),
    !relative_address_start(EA+Size,_,_,_,_).

///////////////////////////////////////////////////////////////////////////////////////////////////////
// detect jump tables precisely once we have all results of the analyses


// auxiliary predicate for detecting accessing an element of a jump table.
.decl jump_table_element_access(EA:address,Size:unsigned,TableStart:address)

jump_table_element_access(EA,Size,TableStartAddr):-
    data_access(EA,_,"NONE","NONE",RegIndex,as(Size,number),TableStart,Size),
    TableStartAddr = as(TableStart,address),
    RegIndex != "NONE",
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

jump_table_element_access(EA,1,TableStartAddr):-
    data_access(EA,_,"NONE",RegBase,"NONE",_,TableStart,1),
    TableStartAddr = as(TableStart,address),
    RegBase != "NONE",
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

jump_table_element_access(EA,Size,TableStartAddr):-
    data_access(EA,_,"NONE",RegBase,RegIndex,as(Size,number),Offset,Size),
    RegIndex != "NONE",
    def_used(EA_regdef,RegBase,EA,_),
    value_reg(EA_regdef,RegBase,_,"NONE",0,Base,_),
    TableStartAddr = as(Base+Offset,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

// sometimes the regBase contains the index (already multiplied)
// and the regIndex contains the base address
jump_table_element_access(EA,Size,TableStartAddr):-
    data_access(EA,_,"NONE",RegBase,RegIndex,1,0,Size),
    RegBase != "NONE",
    def_used(EA_regdef,RegIndex,EA,_),
    value_reg(EA_regdef,RegIndex,_,"NONE",0,TableStart,_),
    TableStartAddr = as(TableStart,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.


.decl jump_table_start(EA_jump:address,Size:unsigned,TableStart:address,TableRef:address,Scale:number)
.output jump_table_start

jump_table_start(EA_jump,Size,TableStart,as(Base,address),Scale):-
    // Looks like a jump table access occurs at EA...
    jump_table_element_access(EA,Size,TableStart),
    // ...and the register defined at EA (Reg) is used as RegJump = Base + Reg * Scale
    value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
    Reg != "NONE",
    // ...and something jumps to that register.
    def_used(EA_add,RegJump,EA_jump,_),
    (
        reg_call(EA_jump,_);
        reg_jump(EA_jump,_)
    ),
    code(EA_jump).

//  mov REG, TableReference
//  add REG, SIZE PTR [_*Size+TableStart] OR sub REG, SIZE PTR [_*Size+TableStart]
//  jmp REG
jump_table_start(EA_jump,Size,TableStart,TableReferenceAddr,Scale):-
    reg_jump(EA_jump,_),
    code(EA_jump),
    def_used(EA_base,Reg,EA_jump,_),
    instruction_get_operation(EA_base,Operation),
    (
        Operation = "ADD", Scale=1;
        Operation = "SUB", Scale=-1
    ),
    jump_table_element_access(EA_base,Size,TableStart),
    def_used(EA_def_ref,Reg,EA_base,_),
    value_reg(EA_def_ref,Reg,_,"NONE",0,TableReference,_),
    TableReferenceAddr = as(TableReference,address),
    (
        code(TableReferenceAddr);
        TableStart=TableReferenceAddr
    ).

// mov EAX,DWORD PTR [ECX+EAX*4+.L_804a008@GOTOFF]   load
// add EAX,ECX                                       base
// jmp EAX                                           jump
jump_table_start(EA_jump,4,TableStart,TableReference,1):-
    binary_isa("X86"),
    got_reference_pointer(TableReference),
    // Load offset.
    got_relative_operand(EA_load,1,TableStart),
    def_used(EA_load,Reg_got,EA_base,_),
    // Base is GOT.
    arch.reg_reg_arithmetic_operation(EA_base,Reg_jump,Reg_got,_,1,0),
    // Jump to register.
    def_used(EA_base,_,EA_jump,_),
    reg_jump(EA_jump,Reg_jump).
