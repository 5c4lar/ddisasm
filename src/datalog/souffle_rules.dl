.symbol_type register

.number_type address
.number_type operand_code
.number_type operand_index


#include "printable_chars.dl"
#include "float_operations.dl"
#include "jump_operations.dl"

// define component traverse_code
#include "traverse_code.dl"

// compute symbolic_operand, symbolic_data, labeled_data
// float and strings

#include "symbolization.dl"



/////////////////////////////////////////////////////////////
// Inputs generated by the decoder
/////////////////////////////////////////////////////////////

// metadata
.decl entry_point(ea:address)
.input entry_point

.decl symbol(ea:address,n:number,type:symbol,scope:symbol,name:symbol)
.input symbol

.decl section(name:symbol,size:number,addr:address)
.input section

.decl relocation(ea:address,name:symbol,addend:number)
.input relocation

.decl word_size_in_bytes(n:number)
word_size_in_bytes(8).


//FIXME: add eh_frames


.decl instruction(ea:address, size:number, opcode:symbol,
		  op1:operand_code, op2:operand_code, op3:operand_code)
.input instruction

.decl invalid_op_code(ea:address)
.input invalid_op_code

// three kinds of operators
.decl op_regdirect(code:operand_code,register_name:register)
.input op_regdirect

.decl op_immediate(code:operand_code,offset:number)
.input op_immediate

.decl op_indirect(code:operand_code,reg1:register, reg2:register, reg3:register,
		multiplier:number, offset:number, noidea:number, size_value:number)
.input op_indirect

//data from data sections

.decl data_byte(ea:address,value:number)
.input data_byte

.decl address_in_data(ea:address,value:number)

.input address_in_data


/////////////////////////////////////////////////////////////
// auxiliary definitions
/////////////////////////////////////////////////////////////

.decl instruction_get_operation(ea:address,operation:symbol) 

instruction_get_operation(EA,Operation):-
	instruction(EA,_,Operation,_,_,_).
	
.decl instruction_get_op(ea:address, index:number, operator:operand_code)

instruction_get_op(EA,Index,Op):-
	instruction(EA,_,_,Op1,Op2,Op3),
	(
	Op1!=0,
	Op=Op1,Index=1
	;
	Op2!=0,
	Op=Op2,Index=2
	;
	Op3!=0,
	Op=Op3,Index=3
	).
	


/////////////////////////////////////////////////////////////
// inference of basic facts
/////////////////////////////////////////////////////////////


.decl next(n:address,m:address)

next(EA,EA+Size):-
	instruction(EA,Size,_,_,_,_).
	
.decl pc_relative_operand(src:address,index:number, dest:address)
.output pc_relative_operand

pc_relative_operand(EA,Index,Dest):-
	pc_relative_operand_complete(EA,Index,Dest,_).

.decl pc_relative_operand_complete(src:address,index:number, dest:address, size:number)

pc_relative_operand_complete(EA,Index,EA_next+Offset,Size):-
	instruction_get_op(EA, Index, Op),
	op_indirect(Op,"NullSReg","RIP","NullReg64",1,Offset,_,Size),
	next(EA,EA_next).
	
	
// JUMPS
.decl inconditional_jump(n:address)

inconditional_jump(EA):-
	instruction_get_operation(EA,"JMP").



// direct jumps
.decl direct_jump(src:address, dest:address)
.output direct_jump

direct_jump(EA,Dest):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_immediate(Op1,Dest).


// Special kinds of indirect jumps
// PC relative jumps
.decl pc_relative_jump(src:address, dest:address)
.output pc_relative_jump

pc_relative_jump(EA,Dest):-
	instruction_get_operation(EA,Operation),
	jump_operation(Operation),
	pc_relative_operand(EA,1,Dest).

	
// jump to the address of a register
// for now we do not compute anything about these

 .decl reg_jump(src:address)
// .output reg_jump

reg_jump(EA):-
 	instruction(EA,_,Operation,Op1,_,_),
 	jump_operation(Operation),
 	op_regdirect(Op1,_).
	


	
// indirect jump	

 .decl indirect_jump(src:address)
// .output indirect_jump

indirect_jump(EA):-
 	instruction(EA,_,Operation,Op1,_,_),
 	jump_operation(Operation),
 	op_indirect(Op1,_,_,_, _,_,_,_),
 	!pc_relative_jump(EA,_).


	
// CALLS
// direct calls
.decl direct_call(src:address, dest:address)
.output direct_call

direct_call(EA,Dest):-
	instruction(EA,_,"CALL",Op1,_,_),
	op_immediate(Op1,Dest).


.decl pc_relative_call(src:address,dest:address)
.output pc_relative_call

pc_relative_call(Src,Dest):-
	instruction_get_operation(Src,"CALL"),
	pc_relative_operand(Src,1,Dest).


// for now we do not compute anything about these
.decl reg_call(src:address)
.output reg_call

reg_call(EA):-
 	instruction(EA,_,"CALL",Op1,_,_),
 	op_regdirect(Op1,_).




 .decl indirect_call(src:address)
// .output indirect_call

indirect_call(EA):-
	instruction(EA,_,"CALL",Op1,_,_),
 	op_indirect(Op1,_,_,_,_,_,_,_),
 	!pc_relative_jump(EA,_).


// Returns
.decl return(n:address)

return(EA):-
	instruction_get_operation(EA,"Ret").


.decl ambiguous_symbol(name:symbol)
.output ambiguous_symbol

ambiguous_symbol(Name):-
        symbol(_,_,_,_,Name),
 	1< count :{symbol(_,_,_,_,Name)}.

// Function symbols
.decl function_symbol(ea:address,name:symbol)
.output function_symbol

function_symbol(EA,Name):-
	symbol(EA,_,"FUNC",_,Name).

	

.decl data_section(name:symbol)

data_section(".rodata").
data_section(".data").
data_section(".bss").

.decl code_section(name:symbol)

code_section(".text").
code_section(".plt").


.decl may_fallthrough(o:address,d:address)

may_fallthrough(From,To):-
	next(From,To),
	!return(From),
	!inconditional_jump(From).
	
.decl must_fallthrough(o:address,d:address)

must_fallthrough(From,To):-
	may_fallthrough(From,To),
	instruction_get_operation(From,"CALL").



.decl basic_target(ea:address)

// FIXME: add exception frame addresses

basic_target(Val):-
	address_in_data(_,Val).

basic_target(EA):-
	entry_point(EA).

basic_target(EA):-
	function_symbol(EA,_).
	
	
/////////////////////////////////////////////////////////////
// We go through several phases of increasing confidence
/////////////////////////////////////////////////////////////

/////////////////////////////
// Phase 1
// Get an initial approximation of things that look like code
/////////////////////////////
.init phase1=traverse_code

phase1.possible_ea(EA):-
	instruction(EA,_,_,_,_,_).
	
phase1.block_limit(EA):-
	op_immediate(_,EA).

phase1.block_limit(EA):-
	pc_relative_jump(_,EA).
	
phase1.block_limit(EA):-
	pc_relative_call(_,EA).

phase1.block_limit(EA):-
	basic_target(EA).	
	
// these are many starting points but maybe not all
phase1.possible_target(EA):-
	phase1.block_limit(EA).


/////////////////////////////
// Phase 2
// In this propagation the possible targets
// are discovered incrementally
/////////////////////////////

.init phase2=traverse_code

phase2.possible_ea(EA):-
	phase1.remaining_ea(EA).	

// we can start traversing the code in two places and end up in the same
// sequence, we want to slit those common sequences apart
// get chunks that don't have common tails

phase2.block_limit(EA):-
	phase1.block_limit(EA).
	
phase2.block_limit(EA):-
	common_tail(EA).


.decl common_tail(ea:address)

common_tail(EA):-
	phase1.likely_ea(EA,Chunk),
	may_fallthrough(From,EA),
	//get the head of the tail only
	!phase1.likely_ea(From,Chunk),
	phase1.likely_ea(From,Chunk2),
	Chunk2!=Chunk.
//////////////////////////////////////////	
// The targets are computed incrementally now as we traverse the code

.decl possible_target_from(dest:address,src:address)

possible_target_from(Dest,Src):-
	phase2.likely_ea(Src,_),
	instruction_get_op(Src,_,Op),
	op_immediate(Op,Dest).

possible_target_from(Dest,Src):-
	phase2.likely_ea(Src,_),
	pc_relative_jump(Src,Dest).
	
possible_target_from(Dest,Src):-
	phase2.likely_ea(Src,_),
	pc_relative_call(Src,Dest).


phase2.possible_target(EA):-
	basic_target(EA).

phase2.possible_target(EA):-
	possible_target_from(EA,_).


//.output phase2.possible_target
//.output phase2.likely_ea
.output phase2.remaining_ea

////////////////////////////////////////////////////////////////////////
// Even at this point we can have chunks of code that overlap

.decl chunk_start(ea_chunk:address)
.output chunk_start

//special node for function calls
chunk_start(0).
chunk_start(EA):-phase2.likely_ea(_,EA).




.decl chunk_overlap(ea:address,ea2:address)
//.output chunk_overlap

chunk_overlap(EA_chunk,EA_chunk2):-
	phase2.likely_ea(EA,EA_chunk),
	phase2.overlap(EA,EA2),
	phase2.likely_ea(EA2,EA_chunk2).
	
//////////////////////////////////////////////////////////////////////
// We need to solve the chunk overlaps
// we do it with heuristics
///

.decl discarded_chunk(ea_chunk:address)
.output discarded_chunk

discarded_chunk(Chunk):-
	(
	chunk_overlap(Chunk,Chunk2)
	;
	chunk_overlap(Chunk2,Chunk)
	),
	//heuristic: one is a externally defined function
	function_symbol(Chunk2,_),
	!function_symbol(Chunk,_).

discarded_chunk(Chunk):-
	(
	chunk_overlap(Chunk,Chunk2)
	;
	chunk_overlap(Chunk2,Chunk)
	),
	//heuristic: keep the one that has more predecessors
	// but we value different kinds of predecessors differently
	Chunk_pred= sum X:{chunk_pred(Chunk,_,X)},
	Chunk2_pred= sum X:{chunk_pred(Chunk2,_,X)},
	Chunk2_pred>Chunk_pred.
	
.decl chunk_pred(chunk:address,predecessor:address,importance:number)

chunk_pred(Chunk,0,1):-
	basic_target(Chunk).
	
chunk_pred(Chunk,Chunk_pred,3):-
	direct_jump(EA,Chunk),
	phase2.likely_ea(EA,Chunk_pred),
	Chunk_pred!=Chunk.

chunk_pred(Chunk,Chunk_pred,3):-
	may_fallthrough(EA,Chunk),
	phase2.likely_ea(EA,Chunk_pred).
	
chunk_pred(Chunk,Chunk_pred,1):-
	possible_target_from(Chunk,EA),
	!direct_jump(EA,Chunk),
	phase2.likely_ea(EA,Chunk_pred),
	Chunk_pred!=Chunk.
	
	
.decl chunk_overlap2(ea:address,ea2:address)
.output chunk_overlap2

chunk_overlap2(Chunk,Chunk2):-
	chunk_overlap(Chunk,Chunk2),
	!discarded_chunk(Chunk),
	!discarded_chunk(Chunk2).

.decl likely_ea_final(ea:address,chunk:address)
.output likely_ea_final

likely_ea_final(EA,Chunk):-
	phase2.likely_ea(EA,Chunk),
	!discarded_chunk(Chunk).

	

////////////////////////////////////////////////////////////////////////////
// detect references  to libraries (calls to plt)
.decl plt_code_reference(ea:address, function:symbol)


plt_code_reference(EA,Function):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,1,Op),
	op_immediate(Op,Dest),
	section(".plt",Size,Beg),
	Dest<Beg+Size,
	Dest>=Beg,
	pc_relative_jump(Dest,Got_entry),
	relocation(Got_entry,Function,_).

.decl plt_data_reference(ea:address, function:symbol)

plt_data_reference(EA,Function):-
	symbolic_data(EA,Dest),
	section(".plt",Size,Beg),
	Dest<Beg+Size,
	Dest>=Beg,
	pc_relative_jump(Dest,Got_entry),
	relocation(Got_entry,Function,_).

.decl plt_reference(ea:address, function:symbol)
.output plt_reference

plt_reference(EA,Function):-
	(
	plt_code_reference(EA,Function)
	;
	plt_data_reference(EA,Function)
	).

//////////////////////////////////////////////////////////////////////////
// find the main function even if it does not have a symbol
//

.decl main_function(ea:address)
.output main_function

main_function(EA):-
	function_symbol(EA,"main").
	
main_function(Main_location):-
	!function_symbol(Main_location,"main"),
	First_call= min EA:{
		    entry_point(Entry),
		    direct_call(EA,_),
		    likely_ea_final(EA,_),
		    EA>=Entry
		    	},
	next(Prev,First_call),
        likely_ea_final(Prev,_),
	symbolic_code_operand_candidate(Prev,1,Main_location).


