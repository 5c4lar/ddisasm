//////////////////////////////////////////////////////////////////////
//
.decl symbolic_operand(ea:address,operand_index:number)
.output symbolic_operand

.decl symbolic_data(ea:address,value:number)
.output symbolic_data

// data that is dereferenced somewhere in the code
.decl labeled_data(EA:address)
.output labeled_data

// labels of un-initialized data
.decl bss_data(EA:address)
.output bss_data

// type classification heuristics
.decl float_data(ea:address)
.output float_data

.decl string(ea:address,end:address)
.output string

////////////////////////////////////////////////////////////////////////

.decl conditional_mov(EA:address)

conditional_mov(EA):-
	instruction_get_operation(EA,Operation),
	contains("CMOV",Operation).
	
.decl mov(EA:address)

mov(EA):-
	instruction_get_operation(EA,Operation),
	contains("MOV",Operation).	
	
.decl read_only_operation(Operation:symbol)

read_only_operation("TEST").
read_only_operation("CMP").



.decl instruction_get_dest_op(ea:address,index:number,op:operand_code)

instruction_get_dest_op(EA,Index,Op):-
	instruction(EA,_,Operation,_,Op2,Op3),
	!read_only_operation(Operation),
	(
	Op3=0,
	Op2!=0,
	Op=Op2,
	Index=2
	;
	Op3!=0,
	Op=Op3,
	Index=3
	).
.decl instruction_get_src_op(ea:address,Index:operand_index,op:operand_code)

//when the dest is used as a source as well
instruction_get_src_op(EA,Index,Op2):-
	instruction(EA,_,Operation,_,Op2,_),
	Index=2,
	!mov(EA),
	!read_only_operation(Operation).

instruction_get_src_op(EA,Index,Op):-
	(
	instruction(EA,_,_,Op,_,_),Index=1
	;
	instruction(EA,_,_,_,Op,Op3),Op3!=0,Index=2
	).
	
// limit the registers that are tracked
// and transform the names to the largest version
.decl track_register(Reg32:symbol,Reg64:symbol)

track_register("EAX","RAX").
track_register("EBX","RBX").
track_register("ECX","RCX").
track_register("EDX","RDX").


track_register("RAX","RAX").
track_register("RBX","RBX").
track_register("RCX","RCX").
track_register("RDX","RDX").

track_register("RDI","RDI").
//track_register("RSI","RSI").
//track_register("RBP","RBP").

//local underapproximation of control flow
.decl local_next(ea:address,ea_next:address)

local_next(EA,EA_next):-
	likely_ea_final(EA,_),
	may_fallthrough(EA,EA_next).
local_next(EA,EA_next):-
	likely_ea_final(EA,_),
	direct_jump(EA,EA_next).



.decl op_indirect_contains_reg(op:operand_code,reg:register)

//op_contains_reg(Op,Reg):-
//	op_regdirect(Op,Reg).

op_indirect_contains_reg(Op,Reg_uniform):-
	op_indirect(Op,_,Reg2,_,_,_,_,_),
	track_register(Reg2,Reg_uniform).
	
op_indirect_contains_reg(Op,Reg_uniform):-
	op_indirect(Op,_,_,Reg3,_,_,_,_),
	track_register(Reg3,Reg_uniform).

.decl op_regdirect_uniform(op:operand_code,reg_uniform:register)

op_regdirect_uniform(Op,Reg2):-
	op_regdirect(Op,Reg),
	track_register(Reg,Reg2).

// register is defined in this location
.decl def(EA:address,Reg:register)

def(EA,Reg):-
	likely_ea_final(EA,_),
	instruction_get_dest_op(EA,_,Op),
	op_regdirect_uniform(Op,Reg).


.decl used_for_address(ea:address,reg:register,where:address, index:operand_index)


//used register for memory here
used_for_address(EA,Tracked_reg,EA,Index):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Index,Op),
	op_indirect_contains_reg(Op,Reg),
	track_register(Reg,Tracked_reg).

// used to compute something used for memory later
used_for_address(EA,Tracked_reg,EA,Index):-
	//the instruction defines a register that is used for memory
	used_for_address(EA_next,Reg_defined,_,_),
	local_next(EA,EA_next),
	def(EA,Reg_defined),
	
	instruction_get_src_op(EA,Index,Op),
	(
	op_indirect_contains_reg(Op,Tracked_reg)
	;
	op_regdirect_uniform(Op,Tracked_reg)
	).
	
used_for_address(EA,Reg,Where,Index):-
	//weak update with conditional mov
	conditional_mov(EA),
	local_next(EA,EA_next),
	used_for_address(EA_next,Reg,Where,Index).
	
used_for_address(EA,Reg,Where,Index):-
	used_for_address(EA_next,Reg,Where,Index),
	local_next(EA,EA_next),
	!conditional_mov(EA),
	!def(EA,Reg).

	
.decl def_used(ea_def:address,ea_used:address,index_used:operand_index)
.output def_used

def_used(EA_def,EA_used,Index):-
	def(EA_def,Reg),
	local_next(EA_def,EA_next),
	used_for_address(EA_next,Reg,EA_used,Index).



// very basic value analysis
// the value of a register at a point is expressed as the value of another
// multiplied by a multiplier and plus an offset
.decl value_reg(EA:address,Reg:register,
                EA_reg1:address,Reg1:register,Multiplier:number,Offset:number,steps:number)
.output value_reg

// possible loop
value_reg(EA,Reg,0,"Unkown",Immediate,Base-Immediate,Steps+1):-
	def(EA,Reg),
	def_used(EA,EA,_),
	instruction(EA,_,"ADD",Op1,Op2,0),	
	op_immediate(Op1,Immediate),
	op_regdirect_uniform(Op2,Reg),
	// the base case
	value_reg(EA,Reg,0,NullReg,0,Base,Steps),
	null_reg(NullReg).


value_reg(EA,Reg,EA_prev,Reg,1,Immediate,1):-
	def(EA,Reg),
	def_used(EA_prev,EA,_),
	instruction(EA,_,"ADD",Op1,Op2,0),
	op_immediate(Op1,Immediate),
	op_regdirect_uniform(Op2,Reg),
	EA!=EA_prev.

value_reg(EA,Reg,EA_prev,Reg,2^Immediate,0,1):-
	def(EA,Reg),
	def_used(EA_prev,EA,_),
	instruction(EA,_,"SHL",Op1,Op2,0),
	op_immediate(Op1,Immediate),
	op_regdirect_uniform(Op2,Reg),
	EA!=EA_prev.

value_reg(EA,Reg,0,NullReg,0,Immediate,1):-
	null_reg(NullReg),
	def(EA,Reg),
	instruction(EA,_,"MOV",Op1,Op2,0),
	op_immediate(Op1,Immediate),
	op_regdirect_uniform(Op2,Reg).


value_reg(EA,Reg,EA_prev,Reg_origin,1,0,1):-
	def(EA,Reg),
	def_used(EA_prev,EA,_),
	instruction(EA,_,"MOV",Op1,Op2,0),
	op_regdirect_uniform(Op1,Reg_origin),
	op_regdirect_uniform(Op2,Reg),
	EA!=EA_prev.

value_reg(EA,Reg,EA_prev,Reg_origin,Multiplier,Offset,1):-
	def(EA,Reg),
	def_used(EA_prev,EA,_),
	instruction(EA,_,"LEA",Op1,Op2,0),
	op_indirect(Op1,_,NullReg,Reg_origin_non_uniform,Multiplier,Offset,_,_),
	null_reg(NullReg),
	track_register(Reg_origin_non_uniform,Reg_origin),
	op_regdirect_uniform(Op2,Reg),
	EA!=EA_prev.
	
value_reg(EA,Reg,EA_prev,Reg_origin,Multiplier+1,Offset,1):-
	def(EA,Reg),
	def_used(EA_prev,EA,_),
	instruction(EA,_,"LEA",Op1,Op2,0),
	op_indirect(Op1,_,Reg_origin_non_uniform,Reg_origin_non_uniform,Multiplier,Offset,_,_),
	track_register(Reg_origin_non_uniform,Reg_origin),
	op_regdirect_uniform(Op2,Reg),
	EA!=EA_prev.	

value_reg(EA,Reg,EA_prev,Reg_origin,1,Offset,1):-
	def(EA,Reg),
	def_used(EA_prev,EA,_),
	instruction(EA,_,"LEA",Op1,Op2,0),
	op_indirect(Op1,_,Reg_origin_non_uniform,NullReg,1,Offset,_,_),
	null_reg(NullReg),
	track_register(Reg_origin_non_uniform,Reg_origin),
	op_regdirect_uniform(Op2,Reg),
	EA!=EA_prev.

// this one requires propagation before
// Reg2=Reg2-Reg1
// when Reg2 is defined in terms of Reg1
// Reg2= (Reg1*mult+offset)-Reg1 = Reg1 *(mult-1)+offset
value_reg(EA,Reg2,EA2,Reg1,Multiplier-1,Offset,Steps+1):-
	def(EA,Reg2),
	instruction(EA,_,"SUB",Op1,Op2,0),
	op_regdirect_uniform(Op1,Reg1),
	op_regdirect_uniform(Op2,Reg2),
	// Reg2 is defined in EA_prev in terms of reg1
	def_used(EA_prev,EA,_),
	def(EA_prev,Reg2),
	value_reg(EA_prev,Reg2,EA2,Reg1,Multiplier,Offset,Steps),
	Multiplier>1,
	// Reg1 is defined at the same point
	def_used(EA2,EA,_),
	op_regdirect_uniform(Op1,Reg1),
	EA!=EA2.
	


value_reg(EA1,Reg1,EA3,Reg3,Multiplier*Multiplier2,(Offset2*Multiplier)+Offset,Steps+Steps2):-
	value_reg(EA1,Reg1,EA2,Reg2,Multiplier,Offset,Steps),
	value_reg(EA2,Reg2,EA3,Reg3,Multiplier2,Offset2,Steps2),
	EA1!=EA3,
	Steps+Steps2<6.


.decl data_access_pattern(Address:address,Size:number,Multiplier:number,FromWhere:address)
.output data_access_pattern
//single access
data_access_pattern(Address,Size,0,EA):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,_Op_index,Op),
	op_indirect(Op,NullSReg,NullReg1,NullReg2,_,Address,_,Size),
	null_reg(NullSReg),
	null_reg(NullReg1),
	null_reg(NullReg2),
	data_section(Name),
	section(Name,SizeSect,Base),
	Address>=Base,
	Address<=Base+SizeSect.

	
// directly computed
data_access_pattern(Address,Size,Multiplier,EA):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,_Op_index,Op),
	op_indirect(Op,NullSReg,NullReg1,RegMult,Multiplier,Address,_,Size),
	null_reg(NullSReg),
	null_reg(NullReg1),
	!null_reg(RegMult),
	data_section(Name),
	section(Name,SizeSect,Base),
	Address>=Base,
	Address<=Base+SizeSect.

// pc relative
data_access_pattern(Address,Size,0,EA):-
	likely_ea_final(EA,_),
	pc_relative_operand_complete(EA,_,Address,Size),
	
	data_section(Name),
	section(Name,SizeSect,Base),
	Address>=Base,
	Address<=Base+SizeSect.
	
// indirectly computed
data_access_pattern(Offset+Address,Size,Multiplier,EA):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Op_index,Op),
	op_indirect(Op,NullSReg,Reg,NullReg1,_,Address,_,Size),
	null_reg(NullSReg),
	null_reg(NullReg1),
	def_used(EA_def,EA,Op_index),
	Max_steps=max Steps:{value_reg(EA_def,Reg,_,_,_,_,Steps)},	
	value_reg(EA_def,Reg,_,_,Multiplier,Offset,St),
	St>=Max_steps,
	
	data_section(Name),
	section(Name,SizeSect,Base),
	Offset+Address>=Base,
	Offset+Address<=Base+SizeSect.

//typical byte index
data_access_pattern(Address,8,1,EA):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,_,Op),
	op_indirect(Op,NullSReg,Reg,NullReg1,_,Address,_,1),
	null_reg(NullSReg),
	null_reg(NullReg1),
	!null_reg(Reg),

	def_used(EA_def,EA,_),	
	!value_reg(EA_def,Reg,_,_,_,_,_),

	data_section(Name),
	section(Name,SizeSect,Base),
	Address>=Base,
	Address<=Base+SizeSect.

//typical word index
data_access_pattern(Address,16,2,EA):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,_,Op),
	op_indirect(Op,NullSReg,Reg,Reg,1,Address,_,16),
	null_reg(NullSReg),
	!null_reg(Reg),


	def_used(EA_def,EA,_),	
	!value_reg(EA_def,Reg,_,_,_,_,_),

	data_section(Name),
	section(Name,SizeSect,Base),
	Address>=Base,
	Address<=Base+SizeSect.

//typical string access
data_access_pattern(Address,0,0,EA):-
	likely_ea_final(EA,_),
	instruction(EA,_,"MOV",Op1,Op2,0),
	op_immediate(Op1,Address),
	op_regdirect(Op2,Reg),
	string_register(Reg),

	data_section(Name),
	section(Name,SizeSect,Base),
	Address>=Base,
	Address<=Base+SizeSect.



.decl taken_by_data_access_pattern(EA:address,Offset:number)

taken_by_data_access_pattern(EA,Size/ 8):-
	data_access_pattern(EA,Size,_,_).
taken_by_data_access_pattern(EA+1,Rem-1):-
	taken_by_data_access_pattern(EA,Rem),
	Rem>1.
	
.decl string_register(reg:register)

string_register("EDI").
string_register("ESI").



////////////////////////////





.decl symbolic_code_operand_candidate(ea:address,operand_index:number,Dest:address)
.decl symbolic_data_operand_candidate(ea:address,operand_index:number,Dest:address)
				      
symbolic_code_operand_candidate(EA,Op_index,Dest):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Op_index,Op),
	(
		op_immediate(Op,Dest)

	;
		pc_relative_operand_complete(EA,Op_index,Dest,_Size)
	;

   	       op_indirect(Op,_,_,_,_,Dest,_,_Size)
	),
	likely_ea_final(Dest,_).
	

symbolic_data_operand_candidate(EA,Op_index,Dest):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Op_index,Op),
	(
		op_immediate(Op,Dest)
	;
		pc_relative_operand_complete(EA,Op_index,Dest,_Size)
	;

   	       op_indirect(Op,_,_,_,_Multiplier,Dest,_,_Size)
	),
	data_section(Name),
	section(Name,SizeSect,Base),
	Dest>=Base,
	Dest<=Base+SizeSect.


.decl moved_label(EA:address,Index:number,Val:address,New_val:address)
.output moved_label

moved_label(EA,Op_index,Dest,New_dest):-
	symbolic_data_operand_candidate(EA,Op_index,Dest),
	1>=count:{symbolic_data_operand_candidate(_,_,Dest)},//it appear only once
//	1>=count:{data_access_pattern(_,_,_,EA)},//only 1 access pattern

	data_access_pattern(New_dest,_,_,EA),
	(Dest>New_dest+3
	;
	Dest+3<New_dest
	),
	//it might collide with a pointer
	(
	address_in_data2(Dest-1,_)
	;
	address_in_data2(Dest-2,_)
	;
	address_in_data2(Dest-3,_)
	;
	address_in_data2(Dest-4,_)
	;
	address_in_data2(Dest-5,_)
	;
	address_in_data2(Dest-6,_)
	;
	address_in_data2(Dest-7,_)
	).
	


// overapproximation of labels
labeled_data(EA):-
	symbolic_data_operand_candidate(Src,_,EA),
	!moved_label(Src,_,EA,_).
labeled_data(EA_moved):-
	symbolic_data_operand_candidate(Src,_,EA),
	moved_label(Src,_,EA,EA_moved).
	

labeled_data(Val):-
	address_in_data(_,Val),
	data_byte(Val,_).
///////////////////////////////////////////////////////////////////////////////////////////

.comp empty_range{

.decl in_ea(ea:address)
.decl no_overlap(ea:address,size:number)


no_overlap(EA,16):-
	data_byte(EA,_),
	!in_ea(EA-1).
	
no_overlap(EA,32):-
	data_byte(EA,_),
	!in_ea(EA-1),
	!in_ea(EA-2),
	!in_ea(EA-3).
	
no_overlap(EA,64):-
	data_byte(EA,_),
	no_overlap(EA,32),
	!in_ea(EA-4),
	no_overlap(EA-4,32).

	
no_overlap(EA,128):-
	no_overlap(EA,64),
	!in_ea(EA-8),
	no_overlap(EA-8,64).

}
.init address_array_range=empty_range

address_array_range.in_ea(EA):-
	address_array(EA).



// group data according to labels
.decl data_label(ea:address,ea_label:address,offset:number,multiplier:number)
.output data_label

data_label(EA,EA,0,Mult):-
	data_access_pattern(EA,_Size,Mult,_).
	
data_label(EA+Multiplier,EA_label,EA+Multiplier-EA_label,Multiplier):-
	data_label(EA,EA_label,_,Multiplier),
	data_byte(EA+Multiplier,_),
//do not cross data access or labels	
//	!data_access_pattern(EA+Multiplier,_,_,_),
	!taken_by_data_access_pattern(EA+Multiplier,_),
	!labeled_data(EA+Multiplier),
	address_array_range.no_overlap(EA,64).
	


.decl preferred_label(ea:address,ea_label:address)
.output preferred_label
preferred_label(EA,EA_label):-
	Min_Offset= min Offset:{data_label(EA,_,Offset,_)},
	data_label(EA,EA_label,Selected_offset,_),
	Min_Offset>=Selected_offset.

.decl address_in_data2(EA:address,Val:number)

address_in_data2(EA,Val):-
      address_in_data(EA,Val),
      data_section(Name),
      section(Name,Size,Beg),
      Val>=Beg,
      Val<=Size+Beg.
      
address_in_data2(EA,Val):-
      address_in_data(EA,Val),
      likely_ea_final(_,Val).

// an array has to have at least 3 elements to give us some confidence
.decl address_array(EA:address)

address_array(EA):-
	address_in_data2(EA,_),
	EA % 8 =0,
	address_in_data2(EA+8,_),
	address_in_data2(EA+16,_).
address_array(EA):-
	address_array(EA-8),
	address_in_data2(EA,_).
	
	
	

.decl address_can_contain_pointers(ea:address)
.output address_can_contain_pointers
// address accessed from recognized pattern
address_can_contain_pointers(EA):-
	preferred_label(EA,Label),
	(
	data_access_pattern(Label,64,_,_)
	;
	data_access_pattern(Label,0,_,_)	
	).




//FIXME maybe we have to refine this
symbolic_operand(EA,Op_index):-
	symbolic_code_operand_candidate(EA,Op_index,_).
symbolic_operand(EA,Op_index):-
	symbolic_data_operand_candidate(EA,Op_index,_).	
	

symbolic_data(EA,Val):-
 	address_in_data2(EA,Val),
	address_can_contain_pointers(EA),
 	!labeled_data(EA+1),
	!labeled_data(EA+2),
	!labeled_data(EA+3),
	!labeled_data(EA+4),
	!labeled_data(EA+5),
	!labeled_data(EA+6),
	!labeled_data(EA+7).
	
symbolic_data(EA,Val):-
 	address_in_data2(EA,Val),
	address_array(EA),
 	!labeled_data(EA+1),
	!labeled_data(EA+2),
	!labeled_data(EA+3),
	!labeled_data(EA+4),
	!labeled_data(EA+5),
	!labeled_data(EA+6),
	!labeled_data(EA+7).	
	
// address accessed from other pattern
// this one is unlikely so we only allow aligned pointers
symbolic_data(EA,Val):-
	EA % 8 =0,
	address_in_data2(EA,Val),
	 !labeled_data(EA+1),
	!labeled_data(EA+2),
	!labeled_data(EA+3),
	!labeled_data(EA+4),
	!labeled_data(EA+5),
	!labeled_data(EA+6),
	!labeled_data(EA+7),
	
	!preferred_label(EA,_),
 	!preferred_label(EA+1,_),
	!preferred_label(EA+2,_),
	!preferred_label(EA+3,_),
	!preferred_label(EA+4,_),
	!preferred_label(EA+5,_),
	!preferred_label(EA+6,_),
	!preferred_label(EA+7,_).

// for bss there is no decision to make
bss_data(EA):-
	(
	symbolic_data_operand_candidate(_,_,EA)
	;
	symbolic_data(_,EA)
	),
	section(".bss",SizeSect,Base),
	EA>=Base,
	EA<=Base+SizeSect.
// This is not necessary but helful for debugging



float_data(EA):-
	labeled_data(EA),
	symbolic_data_operand_candidate(Ref,_,EA),
	float_instruction(Ref).

.decl float_instruction(ea:address)

float_instruction(EA):-
	instruction_get_operation(EA,Operation),
	float_operation(Operation).


string(Beg,End+1):-
	data_byte(End,0),
	string_candidate(End-1,Beg),
	!labeled_data(End).

   

.decl string_candidate(ea:address,base:address)


string_candidate(EA,EA):-
    preferred_label(EA,_),
    !float_data(EA),
    !symbolic_data(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).
    
string_candidate(EA,EA):-
    labeled_data(EA),
    !float_data(EA),
    !symbolic_data(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).

string_candidate(EA+1,Base):-
   string_candidate(EA,Base),
   !labeled_data(EA+1),
   data_byte(EA+1,Byte),
   printable_char(Byte).


