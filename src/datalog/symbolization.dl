//////////////////////////////////////////////////////////////////////
//
.decl symbolic_operand(ea:address,operand_index:number)
.output symbolic_operand

.decl symbolic_data(ea:address,value:number)
.output symbolic_data

// data that is dereferenced somewhere in the code
.decl labeled_data(EA:address)
.output labeled_data

// labels of un-initialized data
.decl bss_data(EA:address)
.output bss_data

// type classification heuristics
.decl float_data(ea:address)
.output float_data

.decl string(ea:address,end:address)
.output string


////////////////////////////////////////////////////////////////////////

.decl conditional_mov(EA:address)

conditional_mov(EA):-
	instruction_get_operation(EA,Operation),
	contains("CMOV",Operation).
	
.decl mov(EA:address)

mov(EA):-
	instruction_get_operation(EA,Operation),
	contains("MOV",Operation).	
	

// limit the registers that are tracked
// and transform the names to the largest version
.decl track_register(Reg32:symbol,Reg64:symbol)

track_register("EAX","RAX").
track_register("EBX","RBX").
track_register("ECX","RCX").
track_register("EDX","RDX").

track_register("RAX","RAX").
track_register("RBX","RBX").
track_register("RCX","RCX").
track_register("RDX","RDX").

//local underapproximation of control flow
.decl local_next(ea:address,ea_next:address)

local_next(EA,EA_next):-
	likely_ea_final(EA,_),
	may_fallthrough(EA,EA_next).
local_next(EA,EA_next):-
	likely_ea_final(EA,_),
	direct_jump(EA,EA_next).

.decl instruction_get_dest_op(ea:address,index:number,op:operand_code)

instruction_get_dest_op(EA,Index,Op):-
	(
	instruction(EA,_,_,_,Op,0),Op!=0,Index=2
	;
	instruction(EA,_,_,_,_,Op),Op!=0,Index=3
	).
.decl instruction_get_src_op(ea:address,Index:operand_index,op:operand_code)

instruction_get_src_op(EA,Index,Op):-
	(
	instruction(EA,_,_,Op,_,_),Index=1
	;
	instruction(EA,_,_,_,Op,Op3),Op3!=0,Index=2
	).	

.decl op_contains_reg(op:operand_code,reg:register)

op_contains_reg(Op,Reg):-
	op_regdirect(Op,Reg).

op_contains_reg(Op,Reg2):-
	op_indirect(Op,_,Reg2,_,_,_,_,_).
	
op_contains_reg(Op,Reg3):-
	op_indirect(Op,_,_,Reg3,_,_,_,_).	


// register is defined in this location
.decl def(EA:address,Reg:register)

def(EA,Super_reg):-
	likely_ea_final(EA,_),
	instruction_get_dest_op(EA,_,Op),
	op_regdirect(Op,Reg),
	track_register(Reg,Super_reg).


//used register is the location
.decl used_local(ea:address,reg:register,where:address, index:operand_index)



used_local(EA,Tracked_reg,EA,Index):-
	likely_ea_final(EA,_),
	instruction_get_src_op(EA,Index,Op),
	op_contains_reg(Op,Reg),
	track_register(Reg,Tracked_reg).

// used (can be in the destination address or an operation that uses the dest e.g. ADD)
used_local(EA,Tracked_reg,EA,Index):-
	likely_ea_final(EA,_),
	instruction_get_dest_op(EA,Index,Op),
	!mov(EA),
	op_contains_reg(Op,Reg),
	track_register(Reg,Tracked_reg).	


	
//top case
// in all these cases we consider all registers might be
// used in an unkwown manner (index=0)
used_local(EA,Tracked_reg,EA,0):-
	likely_ea_final(EA,_),
	(
	direct_jump(EA,_),
	plt_code_reference(EA,_)
	;
	pc_relative_jump(EA,_),
	plt_code_reference(EA,_)
	;
	reg_jump(EA)
	;
	indirect_jump(EA)
	;
	direct_call(EA,_)
	;
	pc_relative_call(EA,_)
	;
	reg_call(EA)
	;
	indirect_call(EA)
	;
	return(EA)
	),
	track_register(_,Tracked_reg).
	
.decl used(ea:address, reg:register, where:address, index:operand_index)
// used register in the location or later

used(EA,Reg,Where,Index):-
	//weak update with conditional mov
	conditional_mov(EA),
	local_next(EA,EA_next),
	used(EA_next,Reg,Where,Index).
	
used(EA,Reg,Where,Index):-
	local_next(EA,EA_next),
	!conditional_mov(EA),
	used(EA_next,Reg,Where,Index),
	!def(EA,Reg).
	
used(EA,Reg,Where,Index):-
	used_local(EA,Reg,Where,Index).
	
.decl def_used(ea_def:address,ea_used:address,index_used:operand_index)
//.output def_used

def_used(EA_def,EA_used,Index):-
	def(EA_def,Reg),
	local_next(EA_def,EA_next),
	used(EA_next,Reg,EA_used,Index).

.decl def_used_size(ea_def:address,ea_used:address,index_used:operand_index,size:number)
//.output def_used_size

def_used_size(EA_def,EA_used,Index,Size):-
	def_used(EA_def,EA_used,Index),
	instruction_get_op(EA_used,Index,Op_used),
	!op_indirect(Op_used,_,_,_,_,_,_,_),
	Size=0.
	
def_used_size(EA_def,EA_used,Index,Size):-
	def_used(EA_def,EA_used,Index),
	instruction_get_op(EA_used,Index,Op_used),
	op_indirect(Op_used,_,_,_,_,_,_,Size).

	
////////////////////////////

.decl symbolic_operand_candidate(ea:address,operand_index:number,dest:address,size:number)

symbolic_operand_candidate(EA,Op_index,Dest,Size):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Op_index,Op),
	(
		op_immediate(Op,Dest),
		(
		//the defined reg is not one of the tracked ones
		!def(EA,_),
		Size=0
		;
		//unknown use
		def_used(EA,EA_used,0),
		Size=0
		;
		// use
		def_used_size(EA,EA_used,Index_used,Size)
		)

	;
		pc_relative_operand_complete(EA,Op_index,Dest,Size)
	;
	// here we do not compute the real destination but the base address
   	       op_indirect(Op,_,_,_,_,Dest,_,Size)
	),
	(
		likely_ea_final(Dest,_)
	;
		data_section(Name),
		section(Name,SizeSect,Base),
		Dest>=Base,
		Dest<Base+SizeSect
	).

.decl labeled_data_size(EA:address,Size:number)
//.output labeled_data_size

labeled_data_size(EA,Size):-
	symbolic_operand_candidate(_,_,EA,Size),
	data_byte(EA,_).
	
// overapproximation of labels
labeled_data(EA):-
	labeled_data_size(EA,_).
	
labeled_data(Val):-
	address_in_data(_,Val),
	data_byte(Val,_).

// group data according to labels
.decl data_label(ea:address,ea_label:address)

data_label(EA,EA):-
	labeled_data(EA).
	
data_label(EA+1,EA_label):-
	data_label(EA,EA_label),
	data_byte(EA+1,_),
	!labeled_data(EA+1).


.decl address_in_data2(EA:address,Val:number)

address_in_data2(EA,Val):-
      address_in_data(EA,Val),
      data_section(Name),
      section(Name,Size,Beg),
      Val>=Beg,
      Val<Size+Beg.
      
address_in_data2(EA,Val):-
      address_in_data(EA,Val),
      likely_ea_final(_,Val).


.decl label_can_contain_pointers(ea:address)

label_can_contain_pointers(Label):-
	(
	labeled_data_size(Label,64)
	;
	labeled_data_size(Label,0)
	;
	address_in_data(_,Label)
	).   

//FIXME maybe we have to refine this
symbolic_operand(EA,Op_index):-
	symbolic_operand_candidate(EA,Op_index,_,_).
	



symbolic_data(EA,Val):-
 	address_in_data2(EA,Val),
	data_label(EA,Label),
	label_can_contain_pointers(Label),
 	!labeled_data(EA+1),
	!labeled_data(EA+2),
	!labeled_data(EA+3),
	!labeled_data(EA+4),
	!labeled_data(EA+5),
	!labeled_data(EA+6),
	!labeled_data(EA+7).



// for bss there is no decision to make

bss_data(EA):-
	(
	symbolic_operand_candidate(_,_,EA,_)
	;
	symbolic_data(_,EA)
	),
	section(".bss",SizeSect,Base),
	EA>=Base,
	EA<Base+SizeSect.
// This is not necessary but helful for debugging



float_data(EA):-
	labeled_data(EA),
	symbolic_operand_candidate(Ref,_,EA,_),
	float_instruction(Ref).

.decl float_instruction(ea:address)

float_instruction(EA):-
	instruction_get_operation(EA,Operation),
	float_operation(Operation).


string(Beg,End+1):-
	data_byte(End,0),
	string_candidate(End-1,Beg),
	!labeled_data(End).

   

.decl string_candidate(ea:address,base:address)

string_candidate(EA,EA):-
    labeled_data(EA),
    !float_data(EA),
    !symbolic_data(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).

string_candidate(EA+1,Base):-
   string_candidate(EA,Base),
   !labeled_data(EA+1),
   data_byte(EA+1,Byte),
   printable_char(Byte).
