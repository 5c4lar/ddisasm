//////////////////////////////////////////////////////////////////////
//
.decl symbolic_operand(ea:address,operand_index:number)
.output symbolic_operand

.decl symbolic_data(ea:address,value:number)
.output symbolic_data

// data that is dereferenced somewhere in the code
.decl labeled_data(EA:address)
.output labeled_data

// labels of un-initialized data
.decl bss_data(EA:address)
.output bss_data

// type classification heuristics
.decl float_data(ea:address)
.output float_data

.decl string(ea:address,end:address)
.output string


////////////////////////////////////////////////////////////////////////

.decl conditional_mov(EA:address)

conditional_mov(EA):-
	instruction_get_operation(EA,Operation),
	contains("CMOV",Operation).
	
.decl mov(EA:address)

mov(EA):-
	instruction_get_operation(EA,Operation),
	contains("MOV",Operation).	
	

.decl instruction_get_dest_op(ea:address,index:number,op:operand_code)

instruction_get_dest_op(EA,Index,Op):-
	(
	instruction(EA,_,_,_,Op,0),Op!=0,Index=2
	;
	instruction(EA,_,_,_,_,Op),Op!=0,Index=3
	).
.decl instruction_get_src_op(ea:address,Index:operand_index,op:operand_code)

instruction_get_src_op(EA,Index,Op):-
	(
	instruction(EA,_,_,Op,_,_),Index=1
	;
	instruction(EA,_,_,_,Op,Op3),Op3!=0,Index=2
	).
	
// limit the registers that are tracked
// and transform the names to the largest version
.decl track_register(Reg32:symbol,Reg64:symbol)

track_register("EAX","RAX").
track_register("EBX","RBX").
track_register("ECX","RCX").
track_register("EDX","RDX").

track_register("RAX","RAX").
track_register("RBX","RBX").
track_register("RCX","RCX").
track_register("RDX","RDX").

//local underapproximation of control flow
.decl local_next(ea:address,ea_next:address)

local_next(EA,EA_next):-
	likely_ea_final(EA,_),
	may_fallthrough(EA,EA_next).
local_next(EA,EA_next):-
	likely_ea_final(EA,_),
	direct_jump(EA,EA_next).



.decl op_contains_reg(op:operand_code,reg:register)

op_contains_reg(Op,Reg):-
	op_regdirect(Op,Reg).

op_contains_reg(Op,Reg2):-
	op_indirect(Op,_,Reg2,_,_,_,_,_).
	
op_contains_reg(Op,Reg3):-
	op_indirect(Op,_,_,Reg3,_,_,_,_).	


// register is defined in this location
.decl def(EA:address,Reg:register)

def(EA,Super_reg):-
	likely_ea_final(EA,_),
	instruction_get_dest_op(EA,_,Op),
	op_regdirect(Op,Reg),
	track_register(Reg,Super_reg).


//used register is the location
.decl used_local(ea:address,reg:register,where:address, index:operand_index)



used_local(EA,Tracked_reg,EA,Index):-
	likely_ea_final(EA,_),
	instruction_get_src_op(EA,Index,Op),
	op_contains_reg(Op,Reg),
	track_register(Reg,Tracked_reg).

// used (can be in the destination address or an operation that uses the dest e.g. ADD)
used_local(EA,Tracked_reg,EA,Index):-
	likely_ea_final(EA,_),
	instruction_get_dest_op(EA,Index,Op),
	op_contains_reg(Op,Reg),
	(
	  !mov(EA)
	;
	  !op_regdirect(Op,Reg)
	),
	track_register(Reg,Tracked_reg).	

	
//top case
// in all these cases we consider all registers might be
// used in an unkwown manner (index=0)
used_local(EA,Tracked_reg,EA,0):-
	likely_ea_final(EA,_),
	(
	direct_jump(EA,_),
	plt_code_reference(EA,_)
	;
	pc_relative_jump(EA,_),
	plt_code_reference(EA,_)
	;
	reg_jump(EA)
	;
	indirect_jump(EA)
	;
	direct_call(EA,_)
	;
	pc_relative_call(EA,_)
	;
	reg_call(EA)
	;
	indirect_call(EA)
	;
	return(EA)
	),
	track_register(_,Tracked_reg).
	
.decl used(ea:address, reg:register, where:address, index:operand_index)
// used register in the location or later

used(EA,Reg,Where,Index):-
	//weak update with conditional mov
	conditional_mov(EA),
	local_next(EA,EA_next),
	used(EA_next,Reg,Where,Index).
	
used(EA,Reg,Where,Index):-
	local_next(EA,EA_next),
	!conditional_mov(EA),
	used(EA_next,Reg,Where,Index),
	!def(EA,Reg).
	
used(EA,Reg,Where,Index):-
	used_local(EA,Reg,Where,Index).
	
.decl def_used(ea_def:address,ea_used:address,index_used:operand_index)
//.output def_used

def_used(EA_def,EA_used,Index):-
	def(EA_def,Reg),
	local_next(EA_def,EA_next),
	used(EA_next,Reg,EA_used,Index).





.decl used_immediate(EA:address,Index:operand_index,Dest:address,Size:number,Multiplier:number)
.output used_immediate
//untracked register
used_immediate(EA,Index,Dest,0,0):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Index,Op),
	op_immediate(Op,Dest),
	!def(EA,_).

// unknown use
used_immediate(EA,Index,Dest,0,0):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Index,Op),
	op_immediate(Op,Dest),
	(
	def_used(EA,EA_used,0)
	;
	def_used(EA,EA_used,Index_used),
	instruction_get_op(EA_used,Index_used,Op_used),
	!op_indirect(Op_used,_,_,_,_,_,_,_)
	).
// used to access memory but not as multiplier

used_immediate(EA,Index,Dest,0,Size):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Index,Op),
	op_immediate(Op,Dest),
	def(EA,Defined_reg),
	
	def_used(EA,EA_used,Index_used),
	instruction_get_op(EA_used,Index_used,Op_used),
	op_indirect(Op_used,_,Defined_reg,_,_,_,_,Size).

/////////////////////////////////////////////
used_immediate(EA,Index,Dest+Offset,0,Size):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Index,Op),
	op_immediate(Op,Dest),
	def(EA,Defined_reg),
	
	def_used(EA,EA_used,Index_used),
	instruction_get_op(EA_used,Index_used,Op_used),
	op_indirect(Op_used,_,Defined_reg,"NullReg64",_,Offset,_,Size),
	// heuristic
	Dest>Offset.
used_immediate(EA,Index,Dest+Offset,Multiplier,Size):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Index,Op),
	op_immediate(Op,Dest),
	def(EA,Defined_reg),
	
	def_used(EA,EA_used,Index_used),
	instruction_get_op(EA_used,Index_used,Op_used),
	op_indirect(Op_used,_,Defined_reg,Reg_mult,Multiplier,Offset,_,Size),
	// heuristic
	Dest>Offset,
	Reg_mult!="NullReg64".
	
// used_immediate(EA,Index,Dest+Offset,Multiplier,Size):-
// 	likely_ea_final(EA,_),
// 	instruction_get_op(EA,Index,Op),
// 	op_immediate(Op,Dest),
// 	def_used(EA,EA_used,Index_used),
// 	instruction_get_op(EA_used,_,Op_used),
// 	op_indirect(Op_used,"NullSReg",_,"NullReg64",1,Offset,_,Size).


////////////////////////////

.decl symbolic_code_operand_candidate(ea:address,operand_index:number,
				      dest:address,size:number,mul:number)
.decl symbolic_data_operand_candidate(ea:address,operand_index:number,
                                      dest:address,size:number,mul:number)
				      
symbolic_code_operand_candidate(EA,Op_index,Dest,Size,Multiplier):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Op_index,Op),
	(
		used_immediate(EA,Op_index,Dest,Multiplier,Size)

	;
		pc_relative_operand_complete(EA,Op_index,Dest,Size),
		Multiplier=1
	;

   	       op_indirect(Op,_,_,_,Multiplier,Dest,_,Size)
	),
	likely_ea_final(Dest,_).
	

symbolic_data_operand_candidate(EA,Op_index,Dest,Size,Multiplier):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Op_index,Op),
	(
		used_immediate(EA,Op_index,Dest,Multiplier,Size)
	;
		pc_relative_operand_complete(EA,Op_index,Dest,Size),
		Multiplier=1
	;

   	       op_indirect(Op,_,_,_,Multiplier,Dest,_,Size)
	),
	data_section(Name),
	section(Name,SizeSect,Base),
	Dest>=Base,
	Dest<Base+SizeSect.




	
.decl labeled_data_access(EA:address,Size:number,Mul:number)
.output labeled_data_access

labeled_data_access(EA,Size,Multiplier):-
	symbolic_data_operand_candidate(_,_,EA,Size,Multiplier),
	data_byte(EA,_).

// overapproximation of labels
labeled_data(EA):-
	labeled_data_access(EA,_Size,_Multiplier).

labeled_data(Val):-
	address_in_data(_,Val),
	data_byte(Val,_).
///////////////////////////////////////////////////////////////////////////////////////////


// group data according to labels
.decl data_label(ea:address,ea_label:address)
.output data_label
data_label(EA,EA):-
	labeled_data(EA).
	
data_label(EA+Multiplier,EA_label):-
	data_label(EA,EA_label),
	labeled_data_access(EA_label,_,Multiplier),
	data_byte(EA+Multiplier,_),
	!labeled_data(EA+Multiplier).


.decl address_in_data2(EA:address,Val:number)

address_in_data2(EA,Val):-
      address_in_data(EA,Val),
      data_section(Name),
      section(Name,Size,Beg),
      Val>=Beg,
      Val<Size+Beg.
      
address_in_data2(EA,Val):-
      address_in_data(EA,Val),
      likely_ea_final(_,Val).


.decl address_can_contain_pointers(ea:address)
// address accessed from recognized pattern
address_can_contain_pointers(EA):-
	data_label(EA,Label),
	(
	labeled_data_access(Label,64,_)
	;
	labeled_data_access(Label,0,_)
	).
// address accessed from other pattern
address_can_contain_pointers(EA):-
	address_in_data2(EA,_),
	!data_label(EA,_).

address_can_contain_pointers(EA):-
	address_in_data2(_,EA).
	   

//FIXME maybe we have to refine this
symbolic_operand(EA,Op_index):-
	symbolic_code_operand_candidate(EA,Op_index,_,_,_).
symbolic_operand(EA,Op_index):-
	symbolic_data_operand_candidate(EA,Op_index,_,_,_).	
	

symbolic_data(EA,Val):-
 	address_in_data2(EA,Val),
	address_can_contain_pointers(EA),
 	!labeled_data(EA+1),
	!labeled_data(EA+2),
	!labeled_data(EA+3),
	!labeled_data(EA+4),
	!labeled_data(EA+5),
	!labeled_data(EA+6),
	!labeled_data(EA+7).

// for bss there is no decision to make
bss_data(EA):-
	(
	symbolic_data_operand_candidate(_,_,EA,_,_)
	;
	symbolic_data(_,EA)
	),
	section(".bss",SizeSect,Base),
	EA>=Base,
	EA<Base+SizeSect.
// This is not necessary but helful for debugging



float_data(EA):-
	labeled_data(EA),
	symbolic_data_operand_candidate(Ref,_,EA,_,_),
	float_instruction(Ref).

.decl float_instruction(ea:address)

float_instruction(EA):-
	instruction_get_operation(EA,Operation),
	float_operation(Operation).


string(Beg,End+1):-
	data_byte(End,0),
	string_candidate(End-1,Beg),
	!labeled_data(End).

   

.decl string_candidate(ea:address,base:address)

string_candidate(EA,EA):-
    labeled_data(EA),
    !float_data(EA),
    !symbolic_data(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).

string_candidate(EA+1,Base):-
   string_candidate(EA,Base),
   !labeled_data(EA+1),
   data_byte(EA+1,Byte),
   printable_char(Byte).
