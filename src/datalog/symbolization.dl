//////////////////////////////////////////////////////////////////////
//
.decl symbolic_operand(ea:address,index:operand_index)
.output symbolic_operand

.decl symbolic_data(ea:address,value:address)
.output symbolic_data

// data that is dereferenced somewhere in the code
.decl labeled_data(ea:address)
.output labeled_data

// labels of un-initialized data
.decl bss_data(ea:address)
.output bss_data

// string (just for pretty printing)
.decl string(ea:address,end:address)
.output string

#include "empty_range.dl"

////////////////////////////////////////////////////////////////////////
// hard-coded facts about the analysis
///////////////////////////////////////////////////
	
// limit the registers that are tracked
// and transform the names to their 64 bits version
.decl track_register(Reg32:register,Reg64:register)

track_register("EAX","RAX").
track_register("RAX","RAX").

track_register("EBX","RBX").
track_register("RBX","RBX").

track_register("ECX","RCX").
track_register("RCX","RCX").


track_register("EDX","RDX").
track_register("RDX","RDX").

track_register("EDI","RDI").
track_register("RDI","RDI").

track_register("ESI","RSI").
track_register("RSI","RSI").



////////////////////////////////////////////////////////////////////////
// Auxiliary predicates
/////////////////////////////////////////////////////

.decl op_indirect_contains_reg(op:operand_code,reg:register)

// ignore section registers

op_indirect_contains_reg(Op,Reg_uniform):-
	op_indirect(Op,_,Reg2,_,_,_,_),
	track_register(Reg2,Reg_uniform).
	
op_indirect_contains_reg(Op,Reg_uniform):-
	op_indirect(Op,_,_,Reg3,_,_,_),
	track_register(Reg3,Reg_uniform).

.decl op_regdirect_contains_reg(op:operand_code,reg:register)

op_regdirect_contains_reg(Op,Reg_uniform):-
	op_regdirect(Op,Reg),
	track_register(Reg,Reg_uniform).
	
//////////////////////////////////////////////////////////////////////////////
//local underapproximation of control flow
.decl local_next(ea:address,ea_next:address)

//do not cross calls
local_next(EA,EA_next):-
	code(EA),
	!instruction_get_operation(EA,"CALL"),
	may_fallthrough(EA,EA_next).
	
local_next(EA,EA_next):-
	code(EA),
	direct_jump(EA,EA_next).



//////////////////////////////////////////////////////////////////////////////////
// Def-used analysis: start from memory accesses and walk back
// tracking the registers involved (used)
//////////

// register is defined in this location
.decl def(EA:address,Reg:register)

def(EA,Reg):-
	code(EA),
	instruction_get_dest_op(EA,_,Op),
	op_regdirect_contains_reg(Op,Reg).


.decl used_for_address(ea:address,reg:register,where:address, index:operand_index)
// the register 'reg' at address 'ea' is later used in a memory address in 'where'
// in the operand 'index'


//BASE CASE: used register for memory here
used_for_address(EA,Reg,EA,Index):-
	code(EA),
	//lea does not access memory
	!instruction_get_operation(EA,"LEA"),
	instruction_get_op(EA,Index,Op),
	op_indirect_contains_reg(Op,Reg).

//USED TRANSITIVELY: used to compute something used for memory later
used_for_address(EA,Tracked_reg,EA,Index):-
	//the instruction defines a register that is used for memory
	used_for_address(EA_next,Reg_defined,_,_),
	local_next(EA,EA_next),
	def(EA,Reg_defined),	
	instruction_get_src_op(EA,Index,Op),
	(
	op_indirect_contains_reg(Op,Tracked_reg)
	;
	op_regdirect_contains_reg(Op,Tracked_reg)
	).

//SPECIAL CASE: the register is not used to compute an address but it is
// compared to a register possibly containing an address
// FIXME generalize comparisons
used_for_address(EA,Reg_compared,EA,Index2):-
	used_for_address(EA_next,Reg_used,_,_),
	local_next(EA,EA_next),
	instruction_get_operation(EA,"CMP"),
	instruction_get_src_op(EA,_,Op),
	op_regdirect_contains_reg(Op,Reg_used),
	//track the other operand
	instruction_get_src_op(EA,Index2,Op2),
	Op2!=Op,
	op_regdirect_contains_reg(Op2,Reg_compared).

// propagation of uses when the register is not (necessarily) re-defined	
used_for_address(EA,Reg,Where,Index):-
	used_for_address(EA_next,Reg,Where,Index),
	local_next(EA,EA_next),
	(
	!def(EA,Reg)
	;
	conditional_mov(EA)
	).


//The 'reg' is defined in 'ea_def' and used in 'ea_used' in the operand with index 'index_used'	
.decl def_used(ea_def:address,reg:register,ea_used:address,index_used:operand_index)
.output def_used

def_used(EA_def,Reg,EA_used,Index):-
	def(EA_def,Reg),
	local_next(EA_def,EA_next),
	used_for_address(EA_next,Reg,EA_used,Index).


//////////////////////////////////////////////////////////////////////////////////
// Basic value analysis:
// the value of a register at a point (ea) is expressed as the value of another
// at another point (EA_reg1)
// multiplied by a multiplier plus an offset
// val(Reg,EA) = val(Reg1,EA_reg1)* Multiplier+ Offset
.decl value_reg_edge(EA:address,Reg:register,
                EA_reg1:address,Reg1:register,Multiplier:number,Offset:number)


.decl value_reg(EA:address,Reg:register,
                EA_reg1:address,Reg1:register,Multiplier:number,Offset:number,steps:number)
.output value_reg

// mov reg immediate
value_reg_edge(EA,Reg,0,"NullReg64",0,Immediate):-
	def_used(EA,Reg,_,_),
	instruction(EA,_,"MOV",Op1,Op2,0),
	op_immediate(Op1,Immediate),
	op_regdirect_contains_reg(Op2,Reg).

//add reg immediate
value_reg_edge(EA,Reg,EA_prev,Reg,1,Immediate):-
	def_used(EA_prev,Reg,EA,_),
	instruction(EA,_,"ADD",Op1,Op2,0),
	op_immediate(Op1,Immediate),
	op_regdirect_contains_reg(Op2,Reg),
	EA!=EA_prev.

//shl reg immediate
value_reg_edge(EA,Reg,EA_prev,Reg,2^Immediate,0):-
	def_used(EA_prev,Reg,EA,_),
	instruction(EA,_,"SHL",Op1,Op2,0),
	op_immediate(Op1,Immediate),
	op_regdirect_contains_reg(Op2,Reg),
	EA!=EA_prev.

//mul reg reg immediate
value_reg_edge(EA,Reg,EA_prev,Reg,Immediate,0):-
	def_used(EA_prev,Reg,EA,_),
	instruction(EA,_,"IMUL3",Op1,Op2,Op1),
	op_immediate(Op2,Immediate),
	op_regdirect_contains_reg(Op1,Reg),
	EA!=EA_prev.

//mov reg reg_origin
value_reg_edge(EA,Reg,EA_prev,Reg_origin,1,0):-
	def(EA,Reg),
	def_used(EA_prev,Reg_origin,EA,_),
	instruction(EA,_,"MOV",Op1,Op2,0),
	op_regdirect_contains_reg(Op1,Reg_origin),
	op_regdirect_contains_reg(Op2,Reg),
	EA!=EA_prev.
//lea reg [reg_origin*Multiplier+Offset]
value_reg_edge(EA,Reg,EA_prev,Reg_origin,Multiplier,Offset):-
	def(EA,Reg),
	def_used(EA_prev,Reg_origin,EA,1),
	instruction(EA,_,"LEA",Op1,Op2,0),
	op_indirect(Op1,_,NullReg,Reg_origin_non_uniform,Multiplier,Offset,_),
	null_reg(NullReg),
	track_register(Reg_origin_non_uniform,Reg_origin),
	op_regdirect_contains_reg(Op2,Reg),
	EA!=EA_prev.
//lea reg [reg_origin+reg_origin*Multiplier+Offset]	
value_reg_edge(EA,Reg,EA_prev,Reg_origin,Multiplier+1,Offset):-
	def(EA,Reg),
	def_used(EA_prev,Reg_origin,EA,1),
	instruction(EA,_,"LEA",Op1,Op2,0),
	op_indirect(Op1,_,Reg_origin_non_uniform,Reg_origin_non_uniform,Multiplier,Offset,_),
	track_register(Reg_origin_non_uniform,Reg_origin),
	op_regdirect_contains_reg(Op2,Reg),
	EA!=EA_prev.	
//lea reg [reg_origin+Offset]
value_reg_edge(EA,Reg,EA_prev,Reg_origin,1,Offset):-
	def(EA,Reg),
	def_used(EA_prev,Reg_origin,EA,1),
	instruction(EA,_,"LEA",Op1,Op2,0),
	op_indirect(Op1,_,Reg_origin_non_uniform,NullReg,1,Offset,_),
	null_reg(NullReg),
	track_register(Reg_origin_non_uniform,Reg_origin),
	op_regdirect_contains_reg(Op2,Reg),
	EA!=EA_prev.

///////////////////////////////////////////////////////////////////////////////////////
// once we have the edges that relate the values of registers at different
// instructions we propagate these values forward

//base cases
value_reg(EA,Reg,0,Reg_prev,Mult,Immediate,1):-
	value_reg_edge(EA,Reg,0,Reg_prev,Mult,Immediate).
value_reg(EA,Reg,EA_prev,Reg_prev,Mult,Immediate,1):-
	value_reg_edge(EA,Reg,EA_prev,Reg_prev,Mult,Immediate),
	!value_reg_edge(EA_prev,Reg_prev,_,_,_,_).
	

// possible loop
value_reg(EA,Reg,0,"Unkown",Immediate,Base-Immediate,Steps+1):-
	def_used(EA,Reg,EA,_),
	instruction(EA,_,"ADD",Op1,Op2,0),	
	op_immediate(Op1,Immediate),
	op_regdirect_contains_reg(Op2,Reg),
	// the base case
	value_reg(EA,Reg,0,NullReg,0,Base,Steps),
	null_reg(NullReg).
	
// This is an ad-hoc case observed quite often:
// Reg2=Reg2-Reg1
// where Reg2 is defined in terms of Reg1
// Reg2= (Reg1*mult+offset)-Reg1 = Reg1 *(mult-1)+offset
value_reg(EA,Reg2,EA2,Reg1,Multiplier-1,Offset,1):-
	def(EA,Reg2),
	instruction(EA,_,"SUB",Op1,Op2,0),
	op_regdirect_contains_reg(Op1,Reg1),
	op_regdirect_contains_reg(Op2,Reg2),
	// Reg2 is defined in EA_prev in terms of reg1
	def_used(EA_prev,Reg2,EA,_),
	value_reg_edge(EA_prev,Reg2,EA2,Reg1,Multiplier,Offset),
	Multiplier>1,
	// Reg1 is defined at the same point
	def_used(EA2,Reg1,EA,_),
	op_regdirect_contains_reg(Op1,Reg1),
	EA!=EA2.

// normal propagation
value_reg(EA1,Reg1,EA3,Reg3,Multiplier*Multiplier2,(Offset2*Multiplier)+Offset,Steps+1):-
	value_reg(EA2,Reg2,EA3,Reg3,Multiplier2,Offset2,Steps),
	value_reg_edge(EA1,Reg1,EA2,Reg2,Multiplier,Offset),
	EA1!=EA3,
	Steps+1<6.

//////////////////////////////////////////////////////////////////////////////////
// The address 'Address' is accessed with size 'Size' and multiplier 'Multiplier'
// from an instruction in 'FromWhere'

.decl data_access_pattern(Address:address,Size:number,Multiplier:number,FromWhere:address)
.output data_access_pattern
//single access
data_access_pattern(Address,Size/8 ,0,EA):-
	code(EA),
	instruction_get_op(EA,_Op_index,Op),
	op_indirect(Op,NullSReg,NullReg1,NullReg2,_,Address,Size),
	null_reg(NullSReg),
	null_reg(NullReg1),
	null_reg(NullReg2),
	data_byte(Address,_).

// directly computed
data_access_pattern(Address,Size/8 ,Multiplier,EA):-
	code(EA),
	instruction_get_op(EA,_Op_index,Op),
	op_indirect(Op,NullSReg,NullReg1,RegMult,Multiplier,Address,Size),
	null_reg(NullSReg),
	null_reg(NullReg1),
	!null_reg(RegMult),
	data_byte(Address,_).

// pc relative
data_access_pattern(Address,Size/8 ,0,EA):-
	code(EA),
	pc_relative_operand_complete(EA,_,Address,Size),	
	data_byte(Address,_).
	
//typical byte index
data_access_pattern(Address,1,1,EA):-
	code(EA),
	instruction_get_op(EA,Index,Op),
	op_indirect(Op,NullSReg,Reg,NullReg1,_,Address,8),
	null_reg(NullSReg),
	null_reg(NullReg1),
	!null_reg(Reg),

	def_used(EA_def,Reg,EA,Index),	
	!value_reg(EA_def,Reg,_,_,_,_,_),
	data_byte(Address,_).

//typical word index
data_access_pattern(Address,2,2,EA):-
	code(EA),
	instruction_get_op(EA,Index,Op),
	op_indirect(Op,NullSReg,Reg,Reg,1,Address,16),
	null_reg(NullSReg),
	!null_reg(Reg),
	def_used(EA_def,Reg,EA,Index),	
	!value_reg(EA_def,Reg,_,_,_,_,_),
	data_byte(Address,_).

// indirectly computed
data_access_pattern(Offset+Address,Size/8 ,Multiplier,EA):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	op_indirect(Op,NullSReg,Reg,NullReg1,_,Address,Size),
	null_reg(NullSReg),
	null_reg(NullReg1),
	def_used(EA_def,Reg,EA,Op_index),
	Max_steps=max Steps:{value_reg(EA_def,Reg,_,_,_,_,Steps)},	
	value_reg(EA_def,Reg,_,_,Multiplier,Offset,St),
	St>=Max_steps,	
	data_byte(Offset+Address,_).
	
// TODO check if this one is useful at all
//typical string access
data_access_pattern(Address,0,0,EA):-
	code(EA),
	instruction(EA,_,"MOV",Op1,Op2,0),
	op_immediate(Op1,Address),
	op_regdirect(Op2,Reg),
	string_register(Reg),
	data_byte(Address,_).

.decl string_register(reg:register)

string_register("EDI").
string_register("ESI").

///////////////////////////////////////////////////////////////////////////////
////If threre are two nearby memory accesses

.decl paired_data_access(EA1:address,Size1:number,Multiplier:number,
			 EA2:address,Size2:number,Diff:number)
// size in bytes			 
.output paired_data_access			 
paired_data_access(EA1,Size1,Multiplier,EA2,Size2,Diff):-
			 data_access_pattern(EA1,Size1,Multiplier,Ref1),
			 data_access_pattern(EA2,Size2,Multiplier,Ref2),
			 EA1<EA2,
			 EA1+Multiplier>=EA2+Size2,
			 Diff=EA2-EA1,
			 (
			 Ref1<Ref2,
			 Ref1+200>=Ref2
			 ;
			 Ref2<Ref1,
			 Ref2+200>=Ref1
			 ).


.decl taken_by_data_access_pattern(EA:address,Offset:number)

taken_by_data_access_pattern(EA,Size):-
	data_access_pattern(EA,Size,_,_).
taken_by_data_access_pattern(EA+1,Rem-1):-
	taken_by_data_access_pattern(EA,Rem),
	Rem>1.



////////////////////////////

.decl symbolic_code_operand_candidate(ea:address,operand_index:number,Dest:address)
.decl symbolic_data_operand_candidate(ea:address,operand_index:number,Dest:address)
				      
symbolic_code_operand_candidate(EA,Op_index,Dest):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	(
		op_immediate(Op,Dest)

	;
		pc_relative_operand_complete(EA,Op_index,Dest,_Size)
	;

   	       op_indirect(Op,_,_,_,_,Dest,_Size)
	),
	code(Dest).
	

symbolic_data_operand_candidate(EA,Op_index,Dest):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	(
		op_immediate(Op,Dest)
	;
		pc_relative_operand_complete(EA,Op_index,Dest,_Size)
	;

   	       op_indirect(Op,_,_,_,_Multiplier,Dest,_Size)
	),
	data_section(Name),
	section(Name,SizeSect,Base),
	Dest>=Base,
	Dest<=Base+SizeSect.


.decl address_in_data_refined(EA:address,Val:number)

address_in_data_refined(EA,Val):-
      address_in_data(EA,Val),
      data_section(Name),
      section(Name,Size,Beg),
      Val>=Beg,
      Val<=Size+Beg.
      
address_in_data_refined(EA,Val):-
      address_in_data(EA,Val),
      likely_ea_final(_,Val).

// an array has to have at least 3 elements to give us some confidence
.decl address_array(EA:address)

address_array(EA):-
	address_in_data_refined(EA,_),
	EA % 8 =0,
	address_in_data_refined(EA+8,_),
	address_in_data_refined(EA+16,_).
address_array(EA+8):-
	address_array(EA),
	address_in_data_refined(EA+8,_).

.init address_array_range=empty_range

address_array_range.in_ea(EA):-
	address_array(EA).


.decl moved_label(EA:address,Index:number,Val:address,New_val:address)
.output moved_label

// two cases
// when we it is symbolic but possibly lands in the middle of a pointer

// when it is not symbolic because it misses the data sections

moved_label(EA,Op_index,Dest,New_dest):-
	symbolic_data_operand_candidate(EA,Op_index,Dest),
	1>=count:{symbolic_data_operand_candidate(_,_,Dest)},//it appears only once

	data_access_pattern(New_dest,_,_,EA),
	(Dest>New_dest+3
	;
	Dest+3<New_dest
	),
	//it might collide with a pointer
	(
	address_in_data_refined(Dest-1,_)
	;
	address_in_data_refined(Dest-2,_)
	;
	address_in_data_refined(Dest-3,_)
	;
	address_in_data_refined(Dest-4,_)
	;
	address_in_data_refined(Dest-5,_)
	;
	address_in_data_refined(Dest-6,_)
	;
	address_in_data_refined(Dest-7,_)
	).

moved_label(EA,Op_index,Dest,New_dest):-
	symbolic_data_operand_candidate(EA,Op_index,Dest),
	1>=count:{symbolic_data_operand_candidate(_,_,Dest)},//it appears only once
	//it might collide with a strong pointer
	(
	address_in_data_refined(Dest-1,_),
	(data_access_pattern(Dest-1,8,_,_);address_array(Dest-1)),
	New_dest=Dest-1
	;
	address_in_data_refined(Dest-2,_),
	(data_access_pattern(Dest-2,8,_,_);address_array(Dest-2)),
	New_dest=Dest-2
	;
	address_in_data_refined(Dest-3,_),
	(data_access_pattern(Dest-3,8,_,_);address_array(Dest-3)),
	New_dest=Dest-3
	
	;
	address_in_data_refined(Dest-4,_),	
	(data_access_pattern(Dest-4,8,_,_);address_array(Dest-4)),
	New_dest=Dest-4
	;
	address_in_data_refined(Dest-5,_),
	(data_access_pattern(Dest-5,8,_,_);address_array(Dest-5)),
	New_dest=Dest-5
	
	;
	address_in_data_refined(Dest-6,_),
	(data_access_pattern(Dest-6,8,_,_);address_array(Dest-6)),
	New_dest=Dest-6
	;
	address_in_data_refined(Dest-7,_),
	(data_access_pattern(Dest-7,8,_,_);address_array(Dest-7)),
	New_dest=Dest-7
	).
	

moved_label(EA,Op_index,Dest,Dest+Correction):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	!symbolic_data_operand_candidate(EA,Op_index,Dest),
	!pc_relative_operand_complete(EA,Op_index,_,_),
	op_indirect(Op,_,_,_,_,Dest,_),
	Dest>40000,
	
	data_section(Name),
	section(Name,_,Base),
	Dest<Base,
	Dest+1000>=Base,
	Correction=Base-Dest.
	
moved_label(EA,Op_index,Dest,Dest+Correction):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	!symbolic_data_operand_candidate(EA,Op_index,Dest),
	!pc_relative_operand_complete(EA,Op_index,_,_),
	
	// the ones that miss it for a little
	op_indirect(Op,NullSReg,Reg,_,_,Dest,Size),
	Dest!=0,
	def_used(EA_def,Reg,EA,Op_index),
	Max_steps=max Steps:{value_reg(EA_def,Reg,_,_,_,_,Steps)},	

	(
	//the multiplier
	value_reg(EA_def,Reg,_,_,Correction,0,St)
	;
	// the offset
	value_reg(EA_def,Reg,_,_,_,Correction,St)
	),
	Correction<Dest,
	0-Correction<Dest,
	
	St>=Max_steps,
	
	data_section(Name),

	section(Name,SizeSect,Base),

	(Dest<Base ; Dest>Base+SizeSect),
	

	Dest+Correction>=Base,
	Dest+Correction<=Base+SizeSect.
	
moved_label(EA,Op_index,Dest,Dest-Diff):-
	code(EA),
	instruction_get_src_op(EA,Op_index,Op),
	op_immediate(Op,Dest),
	!symbolic_data_operand_candidate(EA,Op_index,Dest),

	instruction_get_operation(EA,"CMP"),

	def_used(EA_other,_,EA,Index2),
	Index2!=Op_index,
	(
	value_reg(EA_other,_,_,_,Diff,_,_)
	;
	value_reg(EA_other,_,_,_,_,Diff,_)
	),
	Diff!=0,
	(
	symbolic_data_operand_candidate(_,_,Dest-Diff)
	;
	data_section(Name),
        section(Name,Size,Beg),
	Dest-Diff=Size+Beg
	).
	
moved_label(EA,Op_index,Dest,Dest-Diff):-
	code(EA),
	instruction_get_src_op(EA,Op_index,Op),
	op_immediate(Op,Dest),
	!symbolic_data_operand_candidate(EA,Op_index,Dest),

	def_used(EA,_,EA_used,Index1),
	instruction_get_operation(EA_used,"CMP"),
	def_used(EA_other,_,EA_used,Index2),
	Index2!=Index1,
	(
	value_reg(EA_other,_,_,_,Diff,_,_)
	;
	value_reg(EA_other,_,_,_,_,Diff,_)
	),
	Diff!=0,
	(
	symbolic_data_operand_candidate(_,_,Dest-Diff)
	;
	data_section(Name),
        section(Name,Size,Beg),
	Dest-Diff>=Beg,
	Dest-Diff<=Size+Beg
	).


// overapproximation of labels
labeled_data(EA):-
	symbolic_data_operand_candidate(Src,_,EA),
	!moved_label(Src,_,EA,_).
labeled_data(EA_moved):-
	moved_label(_Src,_,_,EA_moved).
	

labeled_data(Val):-
	address_in_data(_,Val),
	data_byte(Val,_).

	
///////////////////////////////////////////////////////////////////////////////////////////


// group data according to labels
.decl individual_data_label(ea:address,ea_label:address,offset:number,multiplier:number)

individual_data_label(EA,EA,0,Mult):-
	data_access_pattern(EA,Size,Mult,_Ref),
	!paired_data_access(EA,Size,Mult,_,_,_),
	!paired_data_access(_,_,Mult,EA,Size,_).	
	
individual_data_label(EA+Multiplier,EA_label,EA+Multiplier-EA_label,Multiplier):-
	individual_data_label(EA,EA_label,_,Multiplier),
	data_byte(EA+Multiplier,_),
//do not cross data access or labels	
	!labeled_data(EA+Multiplier),
	!taken_by_data_access_pattern(EA+Multiplier,_),
	address_array_range.no_overlap(EA,8).


// group data according to labels
.decl paired_data_label(ea:address,ea_label:address,offset:number,multiplier:number)


paired_data_label(EA,EA,0,Mult):-
	data_access_pattern(EA,Size,Mult,_),
	paired_data_access(EA,Size,Mult,_,_,_).
	
paired_data_label(EA,EA,0,Mult):-
	data_access_pattern(EA,Size,Mult,_),
	paired_data_access(_,_,Mult,EA,Size,_).	
	
paired_data_label(EA+Multiplier,EA_label,EA+Multiplier-EA_label,Multiplier):-
	paired_data_label(EA,EA_label,_,Multiplier),
	data_byte(EA+Multiplier,_),
//do not cross data access or labels	
	!labeled_data(EA+Multiplier),
	!taken_by_data_access_pattern(EA+Multiplier,_),
	address_array_range.no_overlap(EA,8),
//propagate paired accesses together
	(
	  paired_data_access(EA_label,_,Multiplier,EA_paired,_,Diff),
 	  paired_data_label(EA+Diff,EA_paired,_,Multiplier)
	;
	   !paired_data_access(EA_label,_,Multiplier,_,_,_)
	),
 	(
          paired_data_access(EA_paired2,_,Multiplier,EA_label,_,Diff2),
          paired_data_label(EA+Multiplier-Diff2,EA_paired2,_,Multiplier)
	   ;
           !paired_data_access(_,_,Multiplier,EA_label,_,_)
	).
	
.decl data_label(ea:address,ea_label:address,offset:number,multiplier:number)
.output data_label

data_label(EA,EA_label,Offset,Multiplier):-
	paired_data_label(EA,EA_label,Offset,Multiplier).
data_label(EA,EA_label,Offset,Multiplier):-
	individual_data_label(EA,EA_label,Offset,Multiplier).
	


.decl preferred_label(ea:address,ea_label:address)
.output preferred_label
preferred_label(EA,EA_label):-
	Min_Offset= min Offset:{data_label(EA,_,Offset,_)},
	data_label(EA,EA_label,Selected_offset,_),
	Min_Offset>=Selected_offset.


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

.decl address_can_contain_pointers(ea:address)
.output address_can_contain_pointers
// address accessed from recognized pattern
// this discard places labeled only labeled with a different size
address_can_contain_pointers(EA):-
	preferred_label(EA,Label),
	(
	data_access_pattern(Label,8,_,_)
	;
	data_access_pattern(Label,0,_,_)	
	).




//FIXME maybe we have to refine this
symbolic_operand(EA,Op_index):-
	symbolic_code_operand_candidate(EA,Op_index,_).
symbolic_operand(EA,Op_index):-
	symbolic_data_operand_candidate(EA,Op_index,_).	
		
symbolic_data(EA,Val):-
 	address_in_data_refined(EA,Val),
	(
	address_array(EA)
	;
	address_can_contain_pointers(EA)
	;
	// no labels at all
	EA % 8 =0,
	!preferred_label(EA,_),
 	!preferred_label(EA+1,_),
	!preferred_label(EA+2,_),
	!preferred_label(EA+3,_),
	!preferred_label(EA+4,_),
	!preferred_label(EA+5,_),
	!preferred_label(EA+6,_),
	!preferred_label(EA+7,_)
	),	
 	!labeled_data(EA+1),
	!labeled_data(EA+2),
	!labeled_data(EA+3),
	!labeled_data(EA+4),
	!labeled_data(EA+5),
	!labeled_data(EA+6),
	!labeled_data(EA+7).	
	
// for bss there is no decision to make
bss_data(EA):-
	(
	labeled_data(EA)
	;
	symbolic_data(_,EA)
	),
	section(".bss",SizeSect,Base),
	EA>=Base,
	EA<=Base+SizeSect.

/////////////////////////////////////////////////////////////////////////////////
// This is not necessary but helful for debugging


string(Beg,End+1):-
	data_byte(End,0),
	string_candidate(End-1,Beg),
	!labeled_data(End).

  
.decl string_candidate(ea:address,base:address)


string_candidate(EA,EA):-
    preferred_label(EA,_),
    !symbolic_data(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).
    
string_candidate(EA,EA):-
    labeled_data(EA),
    !symbolic_data(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).

string_candidate(EA+1,Base):-
   string_candidate(EA,Base),
   !labeled_data(EA+1),
   data_byte(EA+1,Byte),
   printable_char(Byte).


