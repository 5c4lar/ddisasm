//////////////////////////////////////////////////////////////////////
//
.decl symbolic_operand(ea:address,index:operand_index)
.output symbolic_operand

.decl stack_operand(ea:address,index:operand_index)
.output stack_operand

.decl symbolic_data(ea:address,value:address)
.output symbolic_data

.decl symbol_minus_symbol(ea:address,symbol1:address,symbol2:address)
.output symbol_minus_symbol

// symbolic data that points to code
.decl code_pointer_in_data(EA:address,Val:address)

// data that is dereferenced somewhere in the code
.decl labeled_data(ea:address)
.output labeled_data

// labels of un-initialized data
.decl bss_data(ea:address)
.output bss_data

// string (just for pretty printing)
.decl string(ea:address,end:address)
.output string

#include "empty_range.dl"
#include "use_def_analysis.dl"
#include "value_analysis.dl"
#include "data_access_analysis.dl" // data_access_analysis uses predicated here


stack_operand(EA,Op_index):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	op_indirect(Op,NullSReg,"RBP",_,_,_Offset,_),
	!instruction_get_operation(EA,"LEA"),
	null_reg(NullSReg).

stack_operand(EA,Op_index):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	op_indirect(Op,NullSReg,"RSP",NullReg,_,Offset,_),
	!instruction_get_operation(EA,"LEA"),
	null_reg(NullSReg),
	null_reg(NullReg),
	Offset>=0.


////////////////////////////////////////////////////////////////////////
// address_in_data considers anything that points to the code region
// this refinement restricts that to the beginning of the final blocks
.decl address_in_data_refined(EA:address,Val:number)

address_in_data_refined(EA,Val):-
      binary_type("DYN"),
      address_in_data(EA,Val),
      relocation(EA,_,_,_),
      data_section(Name),
      section(Name,Size,Beg),
      Val>=Beg,
      Val<=Size+Beg.

address_in_data_refined(EA,Val):-
      binary_type("DYN"),
      address_in_data(EA,Val),
      relocation(EA,_,_,_),
      block(Val).

address_in_data_refined(EA,Val):-
      binary_type("EXEC"),
      address_in_data(EA,Val),
      data_section(Name),
      section(Name,Size,Beg),
      Val>=Beg,
      Val<=Size+Beg.
      
address_in_data_refined(EA,Val):-
      binary_type("EXEC"),
      address_in_data(EA,Val),
      block(Val).


.init address_in_data_refined_range=empty_range

address_in_data_refined_range.in_ea(EA):-
	address_in_data_refined(EA,_).
	
////////////////////////////////////////////////////////////////////////////////////
// candidates of symbolic values in the code
// symbolic_code_operand_candidate points to code
// symbolic_data_operand_candidate points to data

.decl symbolic_code_operand_candidate(ea:address,operand_index:number,Dest:address)
.decl symbolic_data_operand_candidate(ea:address,operand_index:number,Dest:address)

symbolic_code_operand_candidate(EA,Op_index,Dest):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	(
		can_have_symbolic(EA),
		op_immediate(Op,Dest)
	;
		pc_relative_operand_complete(EA,Op_index,Dest,_Size)
	;
		can_have_symbolic(EA),
	        op_indirect(Op,_,_,_,_,Dest,_Size)
	),
	code(Dest).
	

symbolic_data_operand_candidate(EA,Op_index,Dest):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	(
		can_have_symbolic(EA),
		op_immediate(Op,Dest)
	;
		pc_relative_operand_complete(EA,Op_index,Dest,_Size)
	;
		can_have_symbolic(EA),
   	        op_indirect(Op,_,_,_,_Multiplier,Dest,_Size)
	),
	data_section(Name),
	section(Name,SizeSect,Base),
	Dest>=Base,
	Dest<=Base+SizeSect.

// Heuristic: If there are at least 3 consecutive addresses
//  we consider that we found an array of addresses


.decl after_address_in_data(EA:address,EA_next:address)


after_address_in_data(EA,EA+Pt_size):-
	address_in_data_refined(EA,_),
	pointer_size(Pt_size),
	data_byte(EA+Pt_size,_).
	
after_address_in_data(EA,EA_aux+1):-
	after_address_in_data(EA,EA_aux),
	!address_in_data_refined(EA_aux,_),
	data_byte(EA_aux+1,_).

.decl next_address_in_data(EA:address,EA_next:address)


next_address_in_data(EA,EA_next):-
	address_in_data_refined(EA,_),
	after_address_in_data(EA,EA_next),
	address_in_data_refined(EA_next,_).


.decl address_array_aux(EA:address,Distance:number)

address_array_aux(EA,Diff):-
	address_in_data_refined(EA,_),
	pointer_size(Pt_size),
	EA % Pt_size =0,
	next_address_in_data(EA,EA_next),
	Diff= EA_next-EA,
	address_in_data_refined(EA+Diff,_),
	next_address_in_data(EA+Diff,EA+(2*Diff)).
	
address_array_aux(EA+Diff,Diff):-
	address_array_aux(EA,Diff),
	next_address_in_data(EA,EA+Diff).
	
.decl address_array(EA:address)

address_array(EA):-
	address_array_aux(EA,_).
	
.init address_array_range=empty_range

address_array_range.in_ea(EA):-
	address_array(EA).



////////////////////////////////////////////////////////////////////////////////////
// Pointer reatribution:
// two cases
//1: when it is symbolic but possibly lands in the middle of a pointer
//2: when it is not symbolic because it misses the data sections

.decl moved_label(EA:address,Index:number,Val:address,New_val:address)
.output moved_label

// indirect operand

// label lands in the middle of a pointer
moved_label(EA,Op_index,Dest,New_dest):-
	symbolic_data_operand_candidate(EA,Op_index,Dest),
	1>=count:{symbolic_data_operand_candidate(_,_,Dest)},//it appears only once
	data_access_pattern(New_dest,_,_,EA),
	(Dest>New_dest+3
	;
	Dest+3<New_dest
	),
	//it might collide with a pointer
	pointer_size(Pt_size),
	address_in_data_refined_range.overlap(Dest,Pt_size,_).

moved_label(EA,Op_index,Dest,New_dest):-
	symbolic_data_operand_candidate(EA,Op_index,Dest),
	1>=count:{symbolic_data_operand_candidate(_,_,Dest)},//it appears only once
	//it might collide with a very likely pointer
	pointer_size(Pt_size),
	address_in_data_refined_range.overlap(Dest,Pt_size,New_dest),
	(
	preferred_data_access(New_dest,Label),
	data_access_pattern(Label,Pt_size,_,_)
	;
	address_array(New_dest)
	).
	
// the pointer is likely to point to the wrong section
moved_label(EA,Op_index,Dest,New_dest):-
	symbolic_data_operand_candidate(EA,Op_index,Dest),
	data_access_pattern(Access_dest,_,Mult,EA),
	(
	Access_dest!=Dest,
	New_dest=Access_dest
	;
	Access_dest=Dest,
	New_dest=Dest+Mult
	),
	
	data_section(Name),
	section(Name,SectSize,Base),
	Dest>=Base,Dest<=Base+SectSize,



	data_section(Name2), Name2!= Name,
	section(Name2,SectSize2,Base2),
	New_dest>=Base2,New_dest<=Base2+SectSize2,

	// sections can have one overlapping address
	Dest!=Base2,
	
	//we are going to move in the direction of the other section
	(
	Mult>0,New_dest>Dest
	;
	Mult<0, New_dest<Dest
	).


// labels that miss the data sections but should be symbolic
// the destination is before the data section
moved_label(EA,Op_index,Dest,Base):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	!symbolic_operand(EA,Op_index),
	!pc_relative_operand_complete(EA,Op_index,_,_),
	op_indirect(Op,_,_,_,_,Dest,_),
	Dest>40000,
	
	data_section(Name),
	section(Name,_,Base),
	Dest<Base,
	Dest+4000>=Base.

// the destination is more than the end of the section
moved_label(EA,Op_index,Dest,Base+SizeSect):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	!symbolic_operand(EA,Op_index),
	!pc_relative_operand_complete(EA,Op_index,_,_),
	op_indirect(Op,_,_,_,_,Dest,_),
	data_access_pattern(Other_dest,_,_,EA),

	data_section(Name),
	section(Name,SizeSect,Base),
	Other_dest>=Base,
	Other_dest<=Base+SizeSect,
	Dest>Base+SizeSect,
	Dest<=Base+SizeSect+(SizeSect/2).






//immediate operand used
moved_label(EA,Op_index,Dest,New_dest):-
	code(EA),
	instruction_get_src_op(EA,Op_index,Op),
	op_immediate(Op,Dest),
	Dest>40000,
	!symbolic_operand(EA,Op_index),
	(
	  instruction_get_operation(EA,Operation),
	  comparison_operation(Operation)
	;
	  mov(EA)
	),
	instruction_get_op(EA,_,Op2),
	Op2!=Op,
	op_regdirect_contains_reg(Op2,Reg),

	local_next(EA,EA_next),
	used_for_address(EA_next,Reg,EA_used,Op_index_used),
	!symbolic_operand(EA_used,Op_index_used),

	//get the section where it is supposed to go
	(
	value_reg(EA_used,_,_,_,_,Other_dest,_)
	;
	// a related register
	def_used(EA_def,_,EA_used,_),
	value_reg(EA_def,_,_,_,_,Other_dest,_)
	),
	Other_dest!=0,
	data_section(Name),
        section(Name,SizeSect,Beg),
	Other_dest>=Beg,
	Other_dest<=SizeSect+Beg,
	(
	Dest< Beg,
	Dest+4000>=Beg,
	New_dest=Beg
	;
	Dest>SizeSect+Beg,
	Dest<=Beg+SizeSect+(SizeSect/2),
	New_dest=SizeSect+Beg
	).

.decl moved_data_label(EA:address,Dest:address,New_dest:address)
.output moved_data_label

moved_data_label(EA,Dest,New_dest):-
	address_in_data_refined(EA,Dest),
	address_in_data_refined_range.overlap(Dest,8,New_dest).



///////////////////////////////////////////////////////////////////////////////////////////



symbol_minus_symbol(EA,EA,Symbol2):-
	data_access_pattern(EA,4,4,_Ref),
	relative_address(EA,EA,Symbol2),
	block(Symbol2),
	relative_address(EA+4,EA,Symbol3),
	block(Symbol3).

	
symbol_minus_symbol(EA,EA_ref,Symbol2):-
	symbol_minus_symbol(EA_label,EA_ref,_),
	preferred_data_access(EA,EA_label),
	relative_address(EA,EA_ref,Symbol2),
	block(Symbol2).




///////////////////////////////////////////////////////////////////////////////////////////
// Final label decision

labeled_data(EA):-
	symbol(EA,_,_,"GLOBAL",_).

labeled_data(EA):-
	symbolic_data_operand_candidate(Src,_,EA),
	!moved_label(Src,_,EA,_).
labeled_data(EA_moved):-
	moved_label(_Src,_,_,EA_moved).
	
labeled_data(Val):-
	address_in_data_refined(EA,Val),
	!moved_data_label(EA,Val,_),
	data_byte(Val,_).

labeled_data(EA):-
	symbol_minus_symbol(EA,EA,_).

labeled_data(New_dest):-
	address_in_data_refined(EA,Val),
	moved_data_label(EA,Val,New_dest),
	data_byte(Val,_).

/////////////////////////////////////////////////////////////////////////////////
// Detect strings


string(Beg,End+1):-
	data_byte(End,0),
	string_candidate(End-1,Beg),
	!labeled_data(End).


.decl string_candidate(ea:address,base:address)


string_candidate(EA,EA):-
    preferred_data_access(EA,_),
    !address_in_data_refined(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).

string_candidate(EA,EA):-
    labeled_data(EA),
    !address_in_data_refined(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).

string_candidate(EA+1,Base):-
   string_candidate(EA,Base),
   !labeled_data(EA+1),
   data_byte(EA+1,Byte),
   printable_char(Byte).

.decl in_string(EA:address,Size:number)

in_string(EA,End-Beg):-
	string(Beg,End),
	string_candidate(EA,Beg).
//////////////////////////////////////////////////////////////////////////////////
// Final decision on symbolization

.decl address_can_contain_pointers(ea:address)
.output address_can_contain_pointers
// address accessed from recognized pattern
// this discard places labeled only labeled with a different size
address_can_contain_pointers(EA):-
	preferred_data_access(EA,Label),
	pointer_size(Pt_size),
	(
	data_access_pattern(Label,Pt_size,_,_)
	;
	data_access_pattern(Label,0,_,_)	
	).



//FIXME maybe we have to refine this (are there false positives?)
symbolic_operand(EA,Op_index):-
	symbolic_code_operand_candidate(EA,Op_index,_).
symbolic_operand(EA,Op_index):-
	symbolic_data_operand_candidate(EA,Op_index,_).	
		
symbolic_data(EA,Val):-
 	address_in_data_refined(EA,Val),
	(
	address_array(EA)
	;
	address_can_contain_pointers(EA)
	;
	// no labels at all and aligned
	pointer_size(Pt_size),
	EA % Pt_size =0,
	//not in the middle of a string
	!in_string(EA,_),
	//fixme: make pointer size parametric
	!preferred_data_access(EA,_),
 	!preferred_data_access(EA+1,_),
	!preferred_data_access(EA+2,_),
	!preferred_data_access(EA+3,_),
	!preferred_data_access(EA+4,_),
	!preferred_data_access(EA+5,_),
	!preferred_data_access(EA+6,_),
	!preferred_data_access(EA+7,_)
	),	
 	!labeled_data(EA+1),
	!labeled_data(EA+2),
	!labeled_data(EA+3),
	!labeled_data(EA+4),
	!labeled_data(EA+5),
	!labeled_data(EA+6),
	!labeled_data(EA+7).	


code_pointer_in_data(EA,Val):-
	symbolic_data(EA,Val),
	block(Val).
	
/////////////////////////////////////////////////////////////////////////////////
// for bss there is no decision to make
bss_data(EA):-
	(
	labeled_data(EA)
	;
	symbolic_data(_,EA)
	),
	section(".bss",SizeSect,Base),
	EA>=Base,
	EA<=Base+SizeSect.




