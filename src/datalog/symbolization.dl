//////////////////////////////////////////////////////////////////////
//
.decl symbolic_operand(ea:address,index:operand_index)
.output symbolic_operand

.decl symbolic_data(ea:address,value:address)
.output symbolic_data

// data that is dereferenced somewhere in the code
.decl labeled_data(ea:address)
.output labeled_data

// labels of un-initialized data
.decl bss_data(ea:address)
.output bss_data

// string (just for pretty printing)
.decl string(ea:address,end:address)
.output string

#include "empty_range.dl"
#include "use_def_analysis.dl"
#include "value_analysis.dl"
#include "data_access_analysis.dl" // data_access_analysis uses predicated here


////////////////////////////////////////////////////////////////////////
// address_in_data considers anything that points to the code region
// this refinement restricts that to the beginning of the final blocks
.decl address_in_data_refined(EA:address,Val:number)

address_in_data_refined(EA,Val):-
      address_in_data(EA,Val),
      data_section(Name),
      section(Name,Size,Beg),
      Val>=Beg,
      Val<=Size+Beg.
      
address_in_data_refined(EA,Val):-
      address_in_data(EA,Val),
      likely_ea_final(_,Val).

.init address_in_data_refined_range=empty_range

address_in_data_refined_range.in_ea(EA):-
	address_in_data_refined(EA,_).
	
////////////////////////////////////////////////////////////////////////////////////
// candidates of symbolic values in the code
// symbolic_code_operand_candidate points to code
// symbolic_data_operand_candidate points to data 
.decl symbolic_code_operand_candidate(ea:address,operand_index:number,Dest:address)
.decl symbolic_data_operand_candidate(ea:address,operand_index:number,Dest:address)
				      
symbolic_code_operand_candidate(EA,Op_index,Dest):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	(
		op_immediate(Op,Dest)

	;
		pc_relative_operand_complete(EA,Op_index,Dest,_Size)
	;

   	       op_indirect(Op,_,_,_,_,Dest,_Size)
	),
	code(Dest).
	

symbolic_data_operand_candidate(EA,Op_index,Dest):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	(
		op_immediate(Op,Dest)
	;
		pc_relative_operand_complete(EA,Op_index,Dest,_Size)
	;

   	       op_indirect(Op,_,_,_,_Multiplier,Dest,_Size)
	),
	data_section(Name),
	section(Name,SizeSect,Base),
	Dest>=Base,
	Dest<=Base+SizeSect.

// Heuristic: If there are at least 3 consecutive addresses
//  we consider that we found an array of addresses 
.decl address_array(EA:address)

address_array(EA):-
	address_in_data_refined(EA,_),
	EA % 8 =0,
	address_in_data_refined(EA+8,_),
	address_in_data_refined(EA+16,_).
address_array(EA+8):-
	address_array(EA),
	address_in_data_refined(EA+8,_).

.init address_array_range=empty_range

address_array_range.in_ea(EA):-
	address_array(EA).



////////////////////////////////////////////////////////////////////////////////////
// Pointer reatribution:
// two cases
//1: when it is symbolic but possibly lands in the middle of a pointer
//2: when it is not symbolic because it misses the data sections

.decl moved_label(EA:address,Index:number,Val:address,New_val:address)
.output moved_label


// label lands in the middle of a pointer
moved_label(EA,Op_index,Dest,New_dest):-
	symbolic_data_operand_candidate(EA,Op_index,Dest),
	1>=count:{symbolic_data_operand_candidate(_,_,Dest)},//it appears only once
	data_access_pattern(New_dest,_,_,EA),
	(Dest>New_dest+3
	;
	Dest+3<New_dest
	),
	//it might collide with a pointer	
	address_in_data_refined_range.overlap(Dest,8,_).

moved_label(EA,Op_index,Dest,New_dest):-
	symbolic_data_operand_candidate(EA,Op_index,Dest),
	1>=count:{symbolic_data_operand_candidate(_,_,Dest)},//it appears only once
	//it might collide with a very likely pointer
	address_in_data_refined_range.overlap(Dest,8,New_dest),
	(
	data_access_pattern(New_dest,8,_,_)
	;
	address_array(New_dest)
	).

// labels that miss the data sections but should be symbolic

// indirect operand
// the destination is before the data section
moved_label(EA,Op_index,Dest,Base):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	!symbolic_data_operand_candidate(EA,Op_index,Dest),
	!pc_relative_operand_complete(EA,Op_index,_,_),
	op_indirect(Op,_,_,_,_,Dest,_),
	Dest>40000,
	
	data_section(Name),
	section(Name,_,Base),
	Dest<Base,
	Dest+1000>=Base.

// the destination is more than the end of the section
moved_label(EA,Op_index,Dest,Base+SizeSect):-
	code(EA),
	instruction_get_op(EA,Op_index,Op),
	!symbolic_data_operand_candidate(EA,Op_index,Dest),
	!pc_relative_operand_complete(EA,Op_index,_,_),
	op_indirect(Op,_,_,_,_,Dest,_),
	data_access_pattern(Other_dest,_,_,EA),

	data_section(Name),
	section(Name,SizeSect,Base),
	Other_dest>=Base,
	Other_dest<=Base+SizeSect,
	Dest>Base+SizeSect.


//immediate operand used
moved_label(EA,Op_index,Dest,New_dest):-
	code(EA),
	instruction_get_src_op(EA,Op_index,Op),
	op_immediate(Op,Dest),
	Dest>40000,
	!symbolic_data_operand_candidate(EA,Op_index,Dest),
	(
	instruction_get_operation(EA,"CMP")
	;
	instruction_get_operation(EA,"MOV")
	),
	instruction_get_op(EA,_,Op2),
	Op2!=Op,
	op_regdirect_contains_reg(Op2,Reg),

	local_next(EA,EA_next),
	used_for_address(EA_next,Reg,EA_used,_),

	//get the section where it is supposed to go
	(
	value_reg(EA_used,_,_,_,_,Other_dest,_)
	;
	// a related register
	def_used(EA_def,_,EA_used,_),
	value_reg(EA_def,_,_,_,_,Other_dest,_)
	),
	Other_dest!=0,
	data_section(Name),
        section(Name,SizeSect,Beg),
	Other_dest>=Beg,
	Other_dest<=SizeSect+Beg,
	(
	Dest< Beg, New_dest=Beg
	;
	Dest>SizeSect+Beg, New_dest=SizeSect+Beg
	).

///////////////////////////////////////////////////////////////////////////////////////////
// Final label decision
labeled_data(EA):-
	symbolic_data_operand_candidate(Src,_,EA),
	!moved_label(Src,_,EA,_).
labeled_data(EA_moved):-
	moved_label(_Src,_,_,EA_moved).
	
labeled_data(Val):-
	address_in_data_refined(_,Val),
	data_byte(Val,_).


//////////////////////////////////////////////////////////////////////////////////
// Final decision on symbolization

.decl address_can_contain_pointers(ea:address)
.output address_can_contain_pointers
// address accessed from recognized pattern
// this discard places labeled only labeled with a different size
address_can_contain_pointers(EA):-
	preferred_data_access(EA,Label),
	(
	data_access_pattern(Label,8,_,_)
	;
	data_access_pattern(Label,0,_,_)	
	).


//FIXME maybe we have to refine this (are there false positives?)
symbolic_operand(EA,Op_index):-
	symbolic_code_operand_candidate(EA,Op_index,_).
symbolic_operand(EA,Op_index):-
	symbolic_data_operand_candidate(EA,Op_index,_).	
		
symbolic_data(EA,Val):-
 	address_in_data_refined(EA,Val),
	(
	address_array(EA)
	;
	address_can_contain_pointers(EA)
	;
	// no labels at all
	EA % 8 =0,
	!preferred_data_access(EA,_),
 	!preferred_data_access(EA+1,_),
	!preferred_data_access(EA+2,_),
	!preferred_data_access(EA+3,_),
	!preferred_data_access(EA+4,_),
	!preferred_data_access(EA+5,_),
	!preferred_data_access(EA+6,_),
	!preferred_data_access(EA+7,_)
	),	
 	!labeled_data(EA+1),
	!labeled_data(EA+2),
	!labeled_data(EA+3),
	!labeled_data(EA+4),
	!labeled_data(EA+5),
	!labeled_data(EA+6),
	!labeled_data(EA+7).	

/////////////////////////////////////////////////////////////////////////////////
// for bss there is no decision to make
bss_data(EA):-
	(
	labeled_data(EA)
	;
	symbolic_data(_,EA)
	),
	section(".bss",SizeSect,Base),
	EA>=Base,
	EA<=Base+SizeSect.

/////////////////////////////////////////////////////////////////////////////////
// This is not necessary but helful for debugging

string(Beg,End+1):-
	data_byte(End,0),
	string_candidate(End-1,Beg),
	!labeled_data(End).

  
.decl string_candidate(ea:address,base:address)


string_candidate(EA,EA):-
    preferred_data_access(EA,_),
    !symbolic_data(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).
    
string_candidate(EA,EA):-
    labeled_data(EA),
    !symbolic_data(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).

string_candidate(EA+1,Base):-
   string_candidate(EA,Base),
   !labeled_data(EA+1),
   data_byte(EA+1,Byte),
   printable_char(Byte).


