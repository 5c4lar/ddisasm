//===- use_def_analysis.dl --------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This modules computes def-uses chains for a subset of the registers (defined in track_register).
and only if those chains are related eventually to an access to memory.

-'def' computes definitions of registers at each of the locations.

-'def_used_for_address' compute the set of live uses backwards at each of the locations.
 However, it only computes uses starting at accesses to memory.

-'def_used' intersects the two previous facts to obtain def-use chains.

-'straight_line_def_used` is a weaker version of 'def_used' that can be used before
code inference.

The traversal of def_used_for_address is kept intra-procedural (not following call edges).
*/

//////////////////////////////////////////////////////////////////////////////
//local underapproximation of control flow
.decl local_next(ea:address,ea_next:address) inline

local_next(EA,EA_next):-
    code_in_block(EA,Block),
    may_fallthrough(EA,EA_next),
    code_in_block(EA_next,Block).

.decl inter_procedural_edge(Src:address,Dest:address)

inter_procedural_edge(Src,Dest):-
    unconditional_jump(Src),
    direct_jump(Src,Dest),
    // If a function begins between Src and Dest (including at Dest), then it
    // is an interprocedural edge (assumes that functions are contiguous).
    function_inference.function_entry_initial(Between),
    Src < Between, Between <= Dest.

inter_procedural_edge(Src,Dest):-
    may_fallthrough(Src,Dest),
    !pc_load_call(Src,Dest),
    function_inference.function_entry_initial(Dest).

.decl block_next(Block:address,BlockEnd:address,NextBlock:address)
.output block_next

block_next(Block,EA,Block2):-
    block_last_instruction(Block,EA),
    may_fallthrough(EA,Block2),
    !no_return_call_propagated(EA),
    !inter_procedural_edge(EA,Block2),
    block(Block2).

block_next(Block,EA,EA_next):-
    block_last_instruction(Block,EA),
    !arch.delay_slot(_,EA),
    direct_jump(EA,EA_next),
    !inter_procedural_edge(EA,EA_next).

block_next(Block,EA,EA_next):-
    block_last_instruction(Block,EA),
    arch.delay_slot(JumpEA,EA),
    direct_jump(JumpEA,EA_next),
    !inter_procedural_edge(JumpEA,EA_next).

block_next(Block,EA,Dest):-
    block_last_instruction(Block,EA),
    jump_table_target(EA,Dest).

// Path created by exception handling.
block_next(Block,EA,Block2):-
    lsda_callsite_addresses(Beg,End, Block2),
    block_last_instruction(Block,EA),
    EA >= Beg, EA < End,
    block(Block2).

//////////////////////////////////////////////////////////////////////////////
// Main definitions

/**
Which registers are tracked for use-def and value analysis.
*/
.decl track_register(Reg:register)

track_register(Reg):-
    arch.general_purpose_reg(Reg);
    arch.frame_pointer(Reg);
    arch.stack_pointer(Reg);
    arch.return_reg(Reg);
    arch.condition_flags_reg(Reg).


/**
The AbstractDefUse component defines relations and rules shared by def-use
analysis for both registers and stack variables.
*/
.comp AbstractDefUse<T> {

    /**
    Var is defined in this location
    */
    .decl def(EA:address,Var:T)

    /**
    Instruction at address 'EA' uses Var at operand index 'Index'.
    */
    .decl used(EA:address,Var:T,Index:operand_index)

    /**
    A <T> is implicitly defined by being compared to a constant and then jumping
    this definition only takes place in between the jump and the target that implies equality
    */
    .decl flow_def(EA:address,Var:T,EA_next:address,Value:number)

    /**
    A <T> is unconditionally defined at EA.
    */
    .decl must_def(EA:address,Var:T) inline

    must_def(EA,Var):-
        def(EA,Var),
        !arch.conditional(EA,_).

    /**
    A Var <T> can propagate through the instruction at EA.

    Intended to be extended by child components to modify behavior of AbstractDefUse.
    */
    .decl ea_propagates_def(EA:address,Var:T) inline

    /**
    A Var <T> can propagate through Block.
    */
    .decl block_propagates_def(Block:address,Var:T) inline

    /**
    A Var <T> is defined in the Block
    */
    .decl defined_in_block(Block:address,Var:T)

    defined_in_block(Block,Var):-
        def(EA,Var),
        code_in_block(EA,Block).

    .decl used_in_block(Block:address,EA_used:address,Var:T,Index:operand_index)

    /**
    A Var <T> is used in the Block
    */
    used_in_block(Block,EA_used,Var,Index):-
        used(EA_used,Var,Index),
        code_in_block(EA_used,Block).

    /**
    The last address prior to EA where Var was defined within the block
    */
    .decl block_last_def(EA:address,EA_def:address,Var:T)

    block_last_def(EA_next,EA,Var):-
        def(EA,Var),
        local_next(EA,EA_next).

    block_last_def(EA_next,EA_def,Var):-
        block_last_def(EA,EA_def,Var),
        !must_def(EA,Var),
        ea_propagates_def(EA,Var),
        local_next(EA,EA_next).

    /**
    The last definition(s) of <T> in a given block.

    Multiple are possible in conditional cases.
    */
    .decl last_def_in_block(Block:address,EA_def:address,Var:T)

    last_def_in_block(Block,EA_def,Var):-
        block_last_instruction(Block,BlockEnd),
        (
            def(BlockEnd,Var),
            EA_def=BlockEnd
            ;
            !must_def(BlockEnd,Var),
            ea_propagates_def(BlockEnd,Var),
            block_last_def(BlockEnd,EA_def,Var)
        ).

    /**
    A <T> is referenced in a block
    */
    .decl ref_in_block(Block:address,Var:T)

    ref_in_block(Block,Var):-
        defined_in_block(Block,Var);
        used_in_block(Block,_,Var,_).

    /**
    A <T> is defined in a block, and is still live at the end of the block.

    This can potentially be paired with a live_var_used if there is a path
    between the Blocks.
    */
    .decl live_var_def(Block:address,VarIdentify:T,LiveVar:T,EA_def:address)

    live_var_def(Block,Var,Var,EA_def):-
        last_def_in_block(Block,EA_def,Var).

    live_var_def(Block,Var,Var,EA_def):-
        flow_def(EA_def,Var,Block,_),
        !defined_in_block(Block,Var),
        block_propagates_def(Block,Var).

    /**
    A <T> is used in a block, but a live definition for that use is not found
    within the block.

    We consider a <T> to be live only if it is live for interblock edges.
    Intrablock cases are handled directly by the def_used relation.

    To find the definition for this use, live_var_at_block_end will have to
    propagate backward from the block.
    */
    .decl live_var_used(Block:address,Var:T,EA_used:address,Index:operand_index,Moves:unsigned) overridable
    .output live_var_used

    // Used in this block
    live_var_used(Block,Var,EA_used,Index,0):-
        used_in_block(Block,EA_used,Var,Index),
        !block_last_def(EA_used,_,Var).

    /**
    The <T> is live at the end of Block, and will be used in BlockUsed.

    Propagates backward from usages to search for defs.

    This is faster than propagating forward from defs, since a used value should
    always be defined in well-behaved code. In addition, we know to stop
    propagating once the definition is found.

    The alternative strategy of propagating forward from defs means that it must
    propagate indefinitely, in case it is used multiple times. Further, side-effect
    definitions are often unused.

    To further optimize this strategy, if another use is encountered, we don't
    propagate any further. Later, the relation live_var_at_prior_used() propagates
    defs forward through adjacent uses.
    */
    .decl live_var_at_block_end(Block:address,BlockUsed:address,Var:T)
    .output live_var_at_block_end

    // Base case
    live_var_at_block_end(PrevBlock,Block,Var):-
        block_next(PrevBlock,PrevBlockEnd,Block),
        live_var_used(Block,Var,_,_,_),
        !flow_def(PrevBlockEnd,Var,Block,_).

    // Recursive case
    live_var_at_block_end(PrevBlock,BlockUsed,Var):-
        live_var_at_block_end(Block,BlockUsed,Var),
        !ref_in_block(Block,Var), // !flow_def is implied by !ref_in_block
        block_propagates_def(Block,Var),
        block_next(PrevBlock,_,Block).

    // Ensure we partition on the delta relation in each version of the rule
    // for best performance: in rule version 1, swap delta_block_next (2) with
    // live_var_at_block_end (1).
    .plan 1: (2,1)

    /**
    The <T> is live at EA_used and at the beginning of BlockUsed, and
    holds the same value from the same definition. The <T> is used in
    BlockUsed.

    Forms an edge between two used() that depend on the same def.
    */
    .decl live_var_at_prior_used(EA_used:address,BlockUsed:address,Var:T)
    .output live_var_at_prior_used

    live_var_at_prior_used(EA_used,BlockUsed,Var):-
        live_var_at_block_end(Block,BlockUsed,Var),
        used_in_block(Block,EA_used,Var,_),
        // Although this does not generate a live_var_at_prior used for a used
        // where the def was in the same block, it shouldn't be necessary since
        // the def will generate a live_var_def, which will connect directly to
        // the used via the normal interblock def_used rule (i.e., we don't
        // need to do used-used chaining if for a used in the same block as the
        // def).
        !defined_in_block(Block,Var).


    /**
    A <T> is defined in 'EA_def' and used in 'EA_used' in the operand with index 'Index_used'
    */
    .decl def_used(EA_def:address,Var:T,EA_used:address,Index_used:operand_index)
    .output def_used

    // Intra-block def-use
    def_used(EA_def,Var,EA_used,Index):-
        used(EA_used,Var,Index),
        block_last_def(EA_used,EA_def,Var).

    // Inter-blocks def-use (explicit def)
    def_used(EA_def,VarIdentity,EA_used,Index):-
        live_var_at_block_end(Block,BlockUsed,Var),
        live_var_def(Block,VarIdentity,Var,EA_def),
        live_var_used(BlockUsed,Var,EA_used,Index,_).

    .plan 1: (3, 1, 2)

    // Forward propagate def_used to downstream used
    def_used(EA_def,Var,Next_EA_used,NextIndex):-
        live_var_at_prior_used(EA_used,NextUsedBlock,Var),
        def_used(EA_def,Var,EA_used,_),
        live_var_used(NextUsedBlock,Var,Next_EA_used,NextIndex,_),
        !block_last_def(Next_EA_used,_,Var).
}

.comp RegisterDefUse : AbstractDefUse<register> {

    // Define any registers defined by the instruction
    def(EA,Reg):-
        (
            register_access(EA,RegIn,"W"),
            reg_map(RegIn,Reg),
            !arch.register_access_override(EA,Reg,"W",0)
            ;
            arch.register_access_override(EA,Reg,"W",1)
        ),
        track_register(Reg).

    // A call "defines" the return value register
    def(EA,Reg):-
        arch.call(EA,_),
        !arch.delay_slot(EA,_),
        arch.return_reg(Reg).

    // A call "defines" the return value register (variant for delay slots)
    def(EA,Reg):-
        arch.call(Call,_),
        arch.delay_slot(Call,EA),
        arch.return_reg(Reg).

    def(EA,Reg):-
        direct_call(EA,EA_pc_thunk),
        get_pc_thunk(EA_pc_thunk,Reg),
        track_register(Reg).

    flow_def(EA_jump,Reg,EA_target,Immediate):-
        code(EA),
        cmp_immediate_to_reg(EA,Reg,_,Immediate),
        track_register(Reg),
        next(EA,EA_jump),
        direct_jump(EA_jump,EA_target),
        arch.jump(EA_jump),
        arch.conditional(EA_jump,"E").

    flow_def(EA_jump,Reg,EA_target,Immediate):-
        code(EA),
        cmp_immediate_to_reg(EA,Reg,_,Immediate),
        track_register(Reg),
        next(EA,EA_jump),
        direct_jump(EA_jump,_),
        next(EA_jump,EA_target),
        arch.jump(EA_jump),
        arch.conditional(EA_jump,"NE").

    // Register defs are never invalidated.
    ea_propagates_def(EA,Reg):-
        UNUSED(EA),
        UNUSED(Reg).

    block_propagates_def(Block,Reg):-
        UNUSED(Block),
        UNUSED(Reg).

    /**
    The register is explicitly used in an operand.
    */
    .decl used_explicit(EA:address,Reg:register,Index:operand_index)

    used_explicit(EA,Reg,Index):-
        instruction_get_src_op(EA,Index,Op),
        op_regdirect_contains_reg(Op,Reg),
        track_register(Reg),
        !is_xor_reset(EA).

    used_explicit(EA,Reg,Index):-
        instruction_get_op(EA,Index,Op),
        op_indirect_contains_reg(Op,Reg),
        track_register(Reg).

    /**
    Instruction at address 'EA' uses register 'Reg' at operand index 'Index'.
    This is supposed to be used before code inference.
    */
    .decl used_before_code_inference(EA:address,Reg:register,Index:operand_index)

    used_before_code_inference(EA,Reg,Index):-
        used_explicit(EA,Reg,Index).

    // Implicitly-used registers use an operand index of zero.
    used_before_code_inference(EA,Reg,0):-
        (
            register_access(EA,RegIn,"R"),
            reg_map(RegIn,Reg),
            !arch.register_access_override(EA,Reg,"R",0)
            ;
            arch.register_access_override(EA,Reg,"R",1)
        ),
        track_register(Reg),
        !used_explicit(EA,Reg,_),
        !is_xor_reset(EA).

    used(EA,Reg,Index):-
        used_before_code_inference(EA,Reg,Index).

    /**
    A value returned from a function is used.
    */
    .decl return_val_used(EA_call:address,Callee:address,Reg:register,EA_used:address,Index_used:operand_index)

    return_val_used(EA_call,Callee,Reg,EA_used,Index_used):-
        arch.return_reg(Reg),
        def_used(EA_call,Reg,EA_used,Index_used),
        direct_call(EA_call,Callee).

    /**
    A value is returned from a called procedure Callee, from the last Block with
    the last instruction at BlockEnd.
    */
    .decl return_block_end(Callee:address,CalleeEnd:address,Block:address,BlockEnd:address)

    return_block_end(Callee,CalleeEnd,Block,BlockEnd):-
        direct_call(_,Callee),
        fde_addresses(Callee,CalleeEnd),
        arch.return(CalleeReturn),
        Callee <= CalleeReturn,
        CalleeReturn < CalleeEnd,
        code_in_block(CalleeReturn,Block),
        block_last_instruction(Block,BlockEnd).

    // Extend for values returned in this block
    live_var_used(RetBlock,Reg,EA_used,Index,1):-
        return_block_end(Callee,_,RetBlock,RetBlockEnd),
        !block_last_def(RetBlockEnd,_,Reg),
        return_val_used(_,Callee,Reg,EA_used,Index).

    // Inter-procedural def-use
    def_used(EA_def,Reg,EA_used,Index):-
        return_val_used(_,Callee,Reg,EA_used,Index),
        return_block_end(Callee,_,_,BlockEnd),
        block_last_def(BlockEnd,EA_def,Reg).

}

.init reg_def_use = RegisterDefUse

.type stack_var = [BaseReg:register,StackPos:number]

/**
An offset is added to a stack pointer register at EA.
*/
.decl adjusts_stack_in_block(Block:address,EA:address,BaseReg:register,Offset:number)
.output adjusts_stack_in_block

adjusts_stack_in_block(Block,EA,BaseReg,Offset):-
    (
        arch.frame_pointer(BaseReg);
        arch.stack_pointer(BaseReg)
    ),
    arch.reg_arithmetic_operation(EA,BaseReg,BaseReg,1,Offset),
    code_in_block(EA,Block).

/**
BaseReg is modified in a manner in Block that is not a handled type of stack
adjustment.
*/
.decl unsupported_stack_def(EA:address,BaseReg:register)
.output unsupported_stack_def

unsupported_stack_def(EA,BaseReg):-
    (
        arch.frame_pointer(BaseReg);
        arch.stack_pointer(BaseReg)
    ),
    reg_def_use.def(EA,BaseReg),
    !adjusts_stack_in_block(_,EA,BaseReg,_).

/**
The total offset added to BaseReg in Block between the block start and EA.
*/
.decl block_differential_stack_adjustment(EA_ref:address,EA:address,BaseReg:register,Offset:number)
.output block_differential_stack_adjustment

// Start at the beginning of blocks if there is a stack adjustment in the block
block_differential_stack_adjustment(Block,Block,BaseReg,0):-
    block(Block),
    adjusts_stack_in_block(Block,_,BaseReg,_).

// Start after unsupported stack definitions
block_differential_stack_adjustment(EA_next,EA_next,BaseReg,0):-
    block(Block),
    adjusts_stack_in_block(Block,_,BaseReg,_),
    code_in_block(EA,Block),
    unsupported_stack_def(EA,BaseReg),
    local_next(EA,EA_next).

// Propagate
block_differential_stack_adjustment(EA_ref,EA_next,BaseReg,Sum+Offset):-
    block_differential_stack_adjustment(EA_ref,EA,BaseReg,Sum),
    code_in_block(EA,Block),
    (
        adjusts_stack_in_block(Block,EA,BaseReg,Offset);
        !adjusts_stack_in_block(Block,EA,BaseReg,_), Offset=0
    ),
    local_next(EA,EA_next),
    !unsupported_stack_def(EA,BaseReg).

/**
A stack adjustment affects live variables at the end of Block.
*/
.decl block_adjusts_stack(Block:address,EA_ref:address,BaseReg:register,Offset:number)
.output block_adjusts_stack

block_adjusts_stack(Block,EA_ref,BaseReg,Sum+Offset):-
    block_last_instruction(Block,EA),
    block_differential_stack_adjustment(EA_ref,EA,BaseReg,Sum),
    (
        adjusts_stack_in_block(Block,EA,BaseReg,Offset);
        !adjusts_stack_in_block(Block,EA,BaseReg,_), Offset=0
    ),
    !unsupported_stack_def(EA,BaseReg).

/**
A stack base register is moved to another potential stack base register.
*/
.decl stack_base_reg_move(Block:address,EA:address,Src:register,Dst:register)

stack_base_reg_move(Block,EA,Src,Dst):-
    (
        arch.frame_pointer(Src);
        arch.stack_pointer(Src)
    ),
    (
        arch.frame_pointer(Dst);
        arch.stack_pointer(Dst)
    ),
    Dst != Src,
    arch.move_reg_reg(EA,Dst,Src),
    code_in_block(EA,Block).

.comp StackVarDefUse : AbstractDefUse<stack_var> {

    // When a value is stored to the stack, it defines a stack value.
    def(EA,[BaseReg,StackPos]):-
        (
            arch.frame_pointer(BaseReg);
            arch.stack_pointer(BaseReg)
        ),
        arch.store(EA,_,_,_,BaseReg,"NONE",_,StackPos).

    // TODO: flow_def (x86 can have these!)
    flow_def(0,nil,0,0):-
        false.

    // When a value is loaded from the stack, it is a use of a stack value.
    used(EA,[BaseReg,StackPos],SrcOp):-
        (
            arch.frame_pointer(BaseReg);
            arch.stack_pointer(BaseReg)
        ),
        arch.load(EA,SrcOp,_,_,BaseReg,"NONE",_,StackPos).

    // A stack variable can also be directly used as an indirect operand
    used(EA,[BaseReg,StackPos],OpIndex):-
        (
            arch.frame_pointer(BaseReg);
            arch.stack_pointer(BaseReg)
        ),
        op_indirect_mapped(IndirectOp,"NONE",BaseReg,"NONE",_,StackPos,_),
        instruction_get_src_op(EA,OpIndex,IndirectOp).

    ea_propagates_def(EA,[BaseReg,StackPos]):-
        !reg_def_use.def(EA,BaseReg),
        UNUSED(StackPos).

    block_propagates_def(Block,[BaseReg,StackPos]):-
        !reg_def_use.defined_in_block(Block,BaseReg),
        UNUSED(StackPos).

    .override live_var_used

    // TODO: can we eliminate this override?

    live_var_used(Block,[BaseReg,StackPos],EA_used,Index,0):-
        used_in_block(Block,EA_used,[BaseReg,StackPos],Index),
        !block_last_def(EA_used,_,[BaseReg,StackPos]),
        !reg_def_use.block_last_def(EA_used,_,BaseReg).

    // stack is adjusted in the block where the var is used
    live_var_used(Block,[BaseReg,StackPos+Offset],EA_used,Index,0):-
        used_in_block(Block,EA_used,[BaseReg,StackPos],Index),
        !block_last_def(EA_used,_,[BaseReg,StackPos]),
        block_differential_stack_adjustment(Block,EA_used,BaseReg,Offset),
        Offset != 0.

    // basereg is moved in the block where the var is used
    live_var_used(Block,[BaseReg,StackPos],EA_used,Index,0):-
        stack_base_reg_move(Block,EA_mov,BaseReg,NewBaseReg),
        used_in_block(Block,EA_used,[NewBaseReg,StackPos],Index),
        reg_def_use.block_last_def(EA_used,EA_mov,NewBaseReg),
        !block_last_def(EA_mov,_,[BaseReg,StackPos]).

    /*
    Intra-block def-use with stack var adjustment, e.g.:

    0000: movq %rax,16(%rsp)
    0004: subq $24,%rsp
    0008: movq 40(%rsp),%rax

    used(8,[RSP,40],1)
    code_in_block(8,0)
    block_differential_stack_adjustments(0,8,RSP,-24)
    adjusts_stack_in_block(0,4,RSP,24)
    block_differential_stack_adjustments(0,4,RSP,0)
    Diff = -24 - 0
    block_last_def(4,EA_def,[RSP,40+(-24)])
    */

    def_used(EA_def,[BaseReg,StackPos+Diff],EA_used,Index):-
        used(EA_used,[BaseReg,StackPos],Index),
        // There should be no last def since BaseReg is modified.
        !block_last_def(EA_used,_,[BaseReg,StackPos]),
        code_in_block(EA_used,Block),
        // query back for last_def with adjusted StackPos from each stack adjustment
        block_differential_stack_adjustment(EA_ref,EA_used,BaseReg,Ref2),
        adjusts_stack_in_block(Block,EA_adjust,BaseReg,_),
        block_differential_stack_adjustment(EA_ref,EA_adjust,BaseReg,Ref1),
        Diff = Ref2 - Ref1,
        block_last_def(EA_adjust,EA_def,[BaseReg,StackPos+Diff]).

    // Intrablock def-use where the def uses the BaseReg is moved.
    def_used(EA_def,[BaseReg,StackPos],EA_used,Index):-
        used(EA_used,[UsedBaseReg,StackPos],Index),
        reg_def_use.block_last_def(EA_used,EA_mov,UsedBaseReg),
        stack_base_reg_move(_,EA_mov,BaseReg,UsedBaseReg),
        // The def of [BaseReg+StackPos] should be the same from both EA_used
        // and EA_mov.
        block_last_def(EA_used,EA_def,[BaseReg,StackPos]),
        block_last_def(EA_mov,EA_def,[BaseReg,StackPos]).

    // Stack pointer is adjusted before the end of the Block, altering the live def
    live_var_def(Block,[BaseReg,StackPos],[BaseReg,StackPos-Diff],EA_def):-
        block_last_instruction(Block,EA),
        block_adjusts_stack(Block,EA_ref,BaseReg,Ref2),
        adjusts_stack_in_block(Block,EA_adjust,BaseReg,_),
        block_differential_stack_adjustment(EA_ref,EA_adjust,BaseReg,Ref1),
        Diff = Ref2 - Ref1,
        block_last_def(EA_adjust,EA_def,[BaseReg,StackPos]).

    // def and a BaseReg move in the same block
    live_var_def(Block,[BaseReg,StackPos],[NewBaseReg,StackPos],EA_def):-
        stack_base_reg_move(Block,EA_mov,BaseReg,NewBaseReg),
        block_last_def(EA_mov,EA_def,[BaseReg,StackPos]),
        // [NewBaseReg+StackPos] is not redefined after the move
        !last_def_in_block(Block,_,[NewBaseReg,StackPos]),
        // NewBaseReg is not redefined after the move
        reg_def_use.last_def_in_block(Block,EA_mov,NewBaseReg).

    /**
    Block adjust a stack pointer register, and a stack variable relative to
    that stack pointer is live at the end of Block.

    Does *not* verify that the variable is live at any particular adjustment
    instruction.

    This exists primarily as an optimization for the rules that use it.
    */
    .decl live_stack_var_at_stack_adjustment(Block:address,Var:stack_var,EA_used:address,Index:operand_index,Adjustment:number,Moves:unsigned)

    live_stack_var_at_stack_adjustment(Block,[BaseReg,StackPos],EA_used,Index,Adjustment,Moves):-
        block_adjusts_stack(Block,Block,BaseReg,Adjustment),
        live_var_at_block_end(Block,BlockUsed,[BaseReg,StackPos]),
        live_var_used(BlockUsed,[BaseReg,StackPos],EA_used,Index,Moves).

    /*
    Generate live_var_used for live stack variables at a stack variable adjustment.

    Ensures these moved live stack variables continue propagating back to their def.

    Generates a live_var_used where !code_in_block(EA_used,Block), similar to
    return value rules
    */
    live_var_used(Block,[BaseReg,StackPos+Offset],EA_used,Index,Moves+1):-
        live_stack_var_at_stack_adjustment(Block,[BaseReg,StackPos],EA_used,Index,Offset,Moves),
        // Ensure that this used() has not already propagated to this block too many times.
        // This breaks loops.
        Moves <= 1,
        // TODO: in addition to this last_def check, if it's defined under a
        // different alias when there are multiple stack adjustments in the
        // block, it really shouldn't propagate.
        // This is the inverse of the latter half of the two above def_used
        // rules
        !last_def_in_block(Block,_,[BaseReg,StackPos]).

    live_var_used(Block,[BaseReg,StackPos],EA_used,Index,Moves+1):-
        live_var_at_block_end(Block,BlockUsed,[NewBaseReg,StackPos]),
        live_var_used(BlockUsed,[NewBaseReg,StackPos],EA_used,Index,Moves),
        stack_base_reg_move(Block,EA_mov,BaseReg,NewBaseReg),
        reg_def_use.last_def_in_block(Block,EA_mov,NewBaseReg),
        !last_def_in_block(Block,_,[NewBaseReg,StackPos]).

    .plan 1: (2,1,3,4)

}

.init stack_def_use = StackVarDefUse

/**
 * The register 'Reg' used as an address at address 'EA'.
 */
.decl used_for_address(EA:address,Reg:register)
.output used_for_address

used_for_address(EA,Reg):-
    reg_def_use.used(EA,Reg,Index),
    instruction_get_op(EA,Index,Op),
    op_indirect_contains_reg(Op,Reg).

used_for_address(EA,Reg):-
    reg_jump(EA,Reg),
    reg_def_use.used(EA,Reg,_).

used_for_address(EA,Reg):-
    reg_call(EA,Reg),
    reg_def_use.used(EA,Reg,_).

/**
 * The register 'Reg' as defined at address 'EA_def' is later used either as an address
 * or to compute an address.
 */
.decl def_used_for_address(EA_def:address,Reg:register)
.output def_used_for_address

def_used_for_address(EA_def,Reg):-
    reg_def_use.def_used(EA_def,Reg,EA,_),
    used_for_address(EA,Reg).

def_used_for_address(EA_def,Reg):-
    def_used_for_address(EA_used,_),
    reg_def_use.def_used(EA_def,Reg,EA_used,_).

def_used_for_address(EA,Reg):-
    arch.pc_relative_addr(EA,Reg,_).


// the last address where a register was defined within the block
.decl straight_line_last_def(EA:address,EA_def:address,Reg:register)

straight_line_last_def(EA_next,EA,Reg):-
    reg_def_use.def(EA,Reg),
    possible_ea(EA),
    must_fallthrough(EA,EA_next),
    possible_ea(EA_next).

straight_line_last_def(EA_next,EA_def,Reg):-
    straight_line_last_def(EA,EA_def,Reg),
    !reg_def_use.must_def(EA,Reg),
    must_fallthrough(EA,EA_next),
    possible_ea(EA_next).

/**
straight_line_def_used is a weaker version than reg_def_use.def_used
that can be used BEFORE code inference.
*/
.decl straight_line_def_used(EA_def:address,Reg:register,EA_used:address,Index:unsigned)

straight_line_def_used(EA_def,Reg,EA_used,Index):-
    reg_def_use.used_before_code_inference(EA_used,Reg,Index),
    straight_line_last_def(EA_used,EA_def,Reg).
