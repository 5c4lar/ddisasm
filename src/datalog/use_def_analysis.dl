//===- use_def_analysis.dl --------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This modules computes def-uses chains for a subset of the registers (defined in track_register).
and only if those chains are related eventually to an access to memory.

-'def' computes definitions of registers at each of the locations.

-'def_used_for_address' compute the set of live uses backwards at each of the locations.
 However, it only computes uses starting at accesses to memory.

-'def_used' intersects the two previous facts to obtain def-use chains.

-'straight_line_def_used` is a weaker version of 'def_used' that can be used before
code inference.

The traversal of def_used_for_address is kept intra-procedural (not following call edges).
*/

//////////////////////////////////////////////////////////////////////////////
//local underapproximation of control flow
.decl local_next(ea:address,ea_next:address) inline

local_next(EA,EA_next):-
    code_in_block(EA,Block),
    may_fallthrough(EA,EA_next),
    code_in_block(EA_next,Block).

.decl inter_procedural_edge(Src:address,Dest:address)

inter_procedural_edge(Src,Dest):-
    unconditional_jump(Src),
    direct_jump(Src,Dest),
    // If a function begins between Src and Dest (including at Dest), then it
    // is an interprocedural edge (assumes that functions are contiguous).
    function_inference.function_entry_initial(Between),
    Src < Between, Between <= Dest.

inter_procedural_edge(Src,Dest):-
    may_fallthrough(Src,Dest),
    !pc_load_call(Src,Dest),
    function_inference.function_entry_initial(Dest).

.decl block_next(Block:address,BlockEnd:address,NextBlock:address)
.output block_next

block_next(Block,EA,Block2):-
    block_last_instruction(Block,EA),
    may_fallthrough(EA,Block2),
    !no_return_call_propagated(EA),
    !inter_procedural_edge(EA,Block2),
    block(Block2).

block_next(Block,EA,EA_next):-
    block_last_instruction(Block,EA),
    !arch.delay_slot(_,EA),
    direct_jump(EA,EA_next),
    !inter_procedural_edge(EA,EA_next).

block_next(Block,EA,EA_next):-
    block_last_instruction(Block,EA),
    arch.delay_slot(JumpEA,EA),
    direct_jump(JumpEA,EA_next),
    !inter_procedural_edge(JumpEA,EA_next).

block_next(Block,EA,Dest):-
    block_last_instruction(Block,EA),
    jump_table_target(EA,Dest).

// Path created by exception handling.
block_next(Block,EA,Block2):-
    lsda_callsite_addresses(Beg,End, Block2),
    block_last_instruction(Block,EA),
    EA >= Beg, EA < End,
    block(Block2).

//////////////////////////////////////////////////////////////////////////////
// Main definitions

/**
Which registers are tracked for use-def and value analysis.
*/
.decl track_register(Reg:register)

track_register(Reg):-
    arch.general_purpose_reg(Reg);
    arch.frame_pointer(Reg);
    arch.stack_pointer(Reg);
    arch.return_reg(Reg);
    arch.condition_flags_reg(Reg).


.comp AbstractDefUse<T> {

    /**
    Obj is defined in this location
    */
    .decl def(EA:address,Obj:T)
    .output def

    /**
    Instruction at address 'EA' uses Obj at operand index 'Index'.
    */
    .decl used(EA:address,Obj:T,Index:operand_index)
    .output used

    /**
    A <T> is implicitly defined by being compared to a constant and then jumping
    this definition only takes place in between the jump and the target that implies equality
    */
    .decl flow_def(EA:address,Obj:T,EA_next:address,Value:number)
    .output flow_def

    /**
    A <T> is unconditionally defined at EA.
    */
    .decl must_def(EA:address,Obj:T) inline

    must_def(EA,Obj):-
        def(EA,Obj),
        !arch.conditional(EA,_).

    /**
    An Obj <T> can propagate through the instruction at EA.

    Intended to be extended by child components to modify behavior of AbstractDefUse.
    */
    .decl ea_propagates_def(EA:address,Obj:T) inline

    /**
    An Obj <T> can propagate through Block.
    */
    .decl block_propagates_def(Block:address,Obj:T) inline

    .decl defined_in_block(EA:address,Obj:T)
    .output defined_in_block

    defined_in_block(Block,Obj):-
        def(EA,Obj),
        code_in_block(EA,Block).

    .decl used_in_block(Block:address,EA_used:address,Obj:T,Index:operand_index)
    .output used_in_block

    used_in_block(Block,EA_used,Obj,Index):-
        used(EA_used,Obj,Index),
        code_in_block(EA_used,Block).

    /**
    The last address prior to EA where Reg was defined within the block
    */
    .decl block_last_def(EA:address,EA_def:address,Obj:T) overridable
    .output block_last_def

    block_last_def(EA_next,EA,Obj):-
        def(EA,Obj),
        local_next(EA,EA_next).

    block_last_def(EA_next,EA_def,Obj):-
        block_last_def(EA,EA_def,Obj),
        !must_def(EA,Obj),
        ea_propagates_def(EA,Obj),
        local_next(EA,EA_next).

    /**
    The last definition(s) of <T> in a given block.

    Multiple are possible in conditional cases.
    */
    .decl last_def_in_block(Block:address,EA_def:address,Obj:T)
    .output last_def_in_block

    last_def_in_block(Block,EA_def,Obj):-
        block_last_instruction(Block,BlockEnd),
        (
            def(BlockEnd,Obj),
            EA_def=BlockEnd
            ;
            !must_def(BlockEnd,Obj),
            block_last_def(BlockEnd,EA_def,Obj)
        ).

    /**
    A <T> is referenced in a block
    */
    .decl ref_in_block(Block:address,Obj:T)
    .output ref_in_block

    ref_in_block(Block,Obj):-
        defined_in_block(Block,Obj);
        used_in_block(Block,_,Obj,_).

    /**
    A <T> is used in a block, but a live definition for that use is not found
    within the block.

    We consider a <T> to be live only if it is live for interblock edges.
    Intrablock cases are handled directly by the def_used relation.

    To find the definition for this use, live_var_at_block_end will have to
    propagate backward from the block.
    */
    .decl live_var_used(Block:address,Obj:T,EA_used:address,Index:operand_index,Moves:unsigned) overridable
    .output live_var_used

    // Used in this block
    live_var_used(Block,Obj,EA_used,Index,0):-
        used_in_block(Block,EA_used,Obj,Index),
        !block_last_def(EA_used,_,Obj).

    /**
    The <T> is live at the end of Block, and will be used in BlockUsed.

    Propagates backward from usages to search for defs.

    This is faster than propagating forward from defs, since a used value should
    always be defined in well-behaved code. In addition, we know to stop
    propagating once the definition is found.

    The alternative strategy of propagating forward from defs means that it must
    propagate indefinitely, in case it is used multiple times. Further, side-effect
    definitions are often unused.

    To further optimize this strategy, if another use is encountered, we don't
    propagate any further. Later, the relation live_var_at_prior_used() propagates
    defs forward through adjacent uses.
    */
    .decl live_var_at_block_end(Block:address,BlockUsed:address,Obj:T) overridable
    .output live_var_at_block_end

    // Base case
    live_var_at_block_end(PrevBlock,Block,Obj):-
        block_next(PrevBlock,PrevBlockEnd,Block),
        live_var_used(Block,Obj,_,_,_),
        !flow_def(PrevBlockEnd,Obj,Block,_).

    // Recursive case
    live_var_at_block_end(PrevBlock,BlockUsed,Obj):-
        live_var_at_block_end(Block,BlockUsed,Obj),
        // TODO: propagate through conditional defs
        !ref_in_block(Block,Obj), // !flow_def is implied by !ref_in_block
        block_propagates_def(Block,Obj),
        block_next(PrevBlock,_,Block).

    // Ensure we partition on the delta relation in each version of the rule
    // for best performance: in rule version 1, swap delta_block_next (2) with
    // live_var_at_block_end (1).
    .plan 1: (2,1)

    /**
    The <T> is live at EA_used and at the beginning of BlockUsed, and
    holds the same value from the same definition. The <T> is used in
    BlockUsed.

    Forms an edge between two used() that depend on the same def.
    */
    .decl live_var_at_prior_used(EA_used:address,BlockUsed:address,Obj:T)
    .output live_var_at_prior_used

    live_var_at_prior_used(EA_used,BlockUsed,Obj):-
        live_var_at_block_end(Block,BlockUsed,Obj),
        used_in_block(Block,EA_used,Obj,_),
        !defined_in_block(Block,Obj). // TODO: should this technically be !block_next_def?


    /**
    A <T> is defined in 'EA_def' and used in 'EA_used' in the operand with index 'Index_used'
    */
    .decl def_used(EA_def:address,Obj:T,EA_used:address,Index_used:operand_index) overridable
    .output def_used

    // Intra-block def-use
    def_used(EA_def,Obj,EA_used,Index):-
        used(EA_used,Obj,Index),
        block_last_def(EA_used,EA_def,Obj).

    // Inter-blocks def-use (explicit def)
    def_used(EA_def,Obj,EA_used,Index):-
        live_var_at_block_end(Block,BlockUsed,Obj),
        last_def_in_block(Block,EA_def,Obj),
        live_var_used(BlockUsed,Obj,EA_used,Index,_).
        // TODO: verify that the stack frame is not invalidated after EA_def?

    .plan 1: (3,1,2)

    // Inter-blocks def-use (flow def)
    def_used(EA_def,Obj,EA_used,Index):-
        live_var_at_block_end(Block,BlockUsed,Obj),
        !defined_in_block(Block,Obj), // TODO: should !defined_in_block, block_propagates_def be here?
        block_propagates_def(Block,Obj),
        flow_def(EA_def,Obj,Block,_),
        live_var_used(BlockUsed,Obj,EA_used,Index,_).

    // Forward propagate def_used to downstream used
    def_used(EA_def,Obj,Next_EA_used,NextIndex):-
        live_var_at_prior_used(EA_used,NextUsedBlock,Obj),
        def_used(EA_def,Obj,EA_used,_),
        live_var_used(NextUsedBlock,Obj,Next_EA_used,NextIndex,_),
        !block_last_def(Next_EA_used,_,Obj).
}

.comp RegisterDefUse : AbstractDefUse<register> {

    // Define any registers defined by the instruction
    def(EA,Reg):-
        (
            register_access(EA,RegIn,"W"),
            reg_map(RegIn,Reg),
            !arch.register_access_override(EA,Reg,"W",0)
            ;
            arch.register_access_override(EA,Reg,"W",1)
        ),
        track_register(Reg).

    // A call "defines" the return value register
    def(EA,Reg):-
        arch.call(EA,_),
        !arch.delay_slot(EA,_),
        arch.return_reg(Reg).

    // A call "defines" the return value register (variant for delay slots)
    def(EA,Reg):-
        arch.call(Call,_),
        arch.delay_slot(Call,EA),
        arch.return_reg(Reg).

    def(EA,Reg):-
        direct_call(EA,EA_pc_thunk),
        get_pc_thunk(EA_pc_thunk,Reg),
        track_register(Reg).

    flow_def(EA_jump,Reg,EA_target,Immediate):-
        code(EA),
        cmp_immediate_to_reg(EA,Reg,_,Immediate),
        track_register(Reg),
        next(EA,EA_jump),
        direct_jump(EA_jump,EA_target),
        arch.jump(EA_jump),
        arch.conditional(EA_jump,"E").

    flow_def(EA_jump,Reg,EA_target,Immediate):-
        code(EA),
        cmp_immediate_to_reg(EA,Reg,_,Immediate),
        track_register(Reg),
        next(EA,EA_jump),
        direct_jump(EA_jump,_),
        next(EA_jump,EA_target),
        arch.jump(EA_jump),
        arch.conditional(EA_jump,"NE").

    // Register defs are never invalidated.
    ea_propagates_def(EA,Reg):-
        UNUSED(EA),
        UNUSED(Reg).

    block_propagates_def(Block,Reg):-
        UNUSED(Block),
        UNUSED(Reg).

    /**
    The register is explicitly used in an operand.
    */
    .decl used_explicit(EA:address,Reg:register,Index:operand_index)

    used_explicit(EA,Reg,Index):-
        instruction_get_src_op(EA,Index,Op),
        op_regdirect_contains_reg(Op,Reg),
        track_register(Reg),
        !is_xor_reset(EA).

    used_explicit(EA,Reg,Index):-
        instruction_get_op(EA,Index,Op),
        op_indirect_contains_reg(Op,Reg),
        track_register(Reg).

    used(EA,Reg,Index):-
        used_explicit(EA,Reg,Index).

    // Implicitly-used registers use an operand index of zero.
    used(EA,Reg,0):-
        (
            register_access(EA,RegIn,"R"),
            reg_map(RegIn,Reg),
            !arch.register_access_override(EA,Reg,"R",0)
            ;
            arch.register_access_override(EA,Reg,"R",1)
        ),
        track_register(Reg),
        !used_explicit(EA,Reg,_),
        !is_xor_reset(EA).

    /**
    A value returned from a function is used.
    */
    .decl return_val_used(EA_call:address,Callee:address,Reg:register,EA_used:address,Index_used:operand_index)

    return_val_used(EA_call,Callee,Reg,EA_used,Index_used):-
        arch.return_reg(Reg),
        def_used(EA_call,Reg,EA_used,Index_used),
        direct_call(EA_call,Callee).

    /**
    A value is returned from a called procedure Callee, from the last Block with
    the last instruction at BlockEnd.
    */
    .decl return_block_end(Callee:address,CalleeEnd:address,Block:address,BlockEnd:address)

    return_block_end(Callee,CalleeEnd,Block,BlockEnd):-
        direct_call(_,Callee),
        fde_addresses(Callee,CalleeEnd),
        arch.return(CalleeReturn),
        Callee <= CalleeReturn,
        CalleeReturn < CalleeEnd,
        code_in_block(CalleeReturn,Block),
        block_last_instruction(Block,BlockEnd).

    // Extend for values returned in this block
    live_var_used(RetBlock,Reg,EA_used,Index,1):-
        return_block_end(Callee,_,RetBlock,RetBlockEnd),
        !block_last_def(RetBlockEnd,_,Reg),
        return_val_used(_,Callee,Reg,EA_used,Index).

    // Inter-procedural def-use
    def_used(EA_def,Reg,EA_used,Index):-
        return_val_used(_,Callee,Reg,EA_used,Index),
        return_block_end(Callee,_,_,BlockEnd),
        block_last_def(BlockEnd,EA_def,Reg).

}

.init reg_def_use = RegisterDefUse

.type stack_var = [BaseReg:register,StackPos:number]

/**
Generate distinct stack frames (identifying them by the location at which the
stack or frame pointer register is defined.)
*/
.decl stack_frame(EA:address,BaseReg:register)
.output stack_frame

stack_frame(EA,BaseReg):-
    // TODO: if the frame pointer, ensure the def is in terms of the stack pointer?
    reg_def_use.def(EA,BaseReg),
    (
        arch.frame_pointer(BaseReg);
        arch.stack_pointer(BaseReg)
    ).

/**
A stack frame is defined in terms of a previous stack frame.
*/
.decl adjacent_stack_frame(PrevAt:address,NextAt:address,BaseReg:register,Offset:number)
.output adjacent_stack_frame

adjacent_stack_frame(PrevEA,NextEA,BaseReg,Offset):-
    reg_def_use.def_used(PrevEA,BaseReg,NextEA,_),
    (
        arch.frame_pointer(BaseReg);
        arch.stack_pointer(BaseReg)
    ),
    arch.reg_arithmetic_operation(NextEA,BaseReg,BaseReg,1,Offset).

/**
Find uses of a given stack frame.
*/
.decl stack_frame_used_in_block(FrameDefinedAt:address,BaseReg:register,Block:address)
.output stack_frame_used_in_block

stack_frame_used_in_block(FrameDefinedAt,BaseReg,Block):-
    stack_frame(FrameDefinedAt,BaseReg),
    reg_def_use.def_used(FrameDefinedAt,BaseReg,EA_used,_),
    code_in_block(EA_used,Block).

.decl adjusts_stack_in_block(Block:address,EA:address,BaseReg:register,Offset:number)
.output adjusts_stack_in_block

adjusts_stack_in_block(Block,EA,BaseReg,Offset):-
    (
        arch.frame_pointer(BaseReg);
        arch.stack_pointer(BaseReg)
    ),
    arch.reg_arithmetic_operation(EA,BaseReg,BaseReg,1,Offset),
    code_in_block(EA,Block).


.decl block_adjusts_stack(Block:address,BaseReg:register,Offset:number)
.output block_adjusts_stack

// TODO: ensure we only generate block_adjusts_stack if we understand all the
// definitions of BaseReg in the block
block_adjusts_stack(Block,BaseReg,TotalOffset):-
    block(Block),
    (
        arch.frame_pointer(BaseReg);
        arch.stack_pointer(BaseReg)
    ),
    TotalOffset != 0,
    TotalOffset = sum Offset : {
        adjusts_stack_in_block(Block,_,BaseReg,Offset)
    }.
/**

EA: the address where the stack is adjusted
PrevEA: the previous definition of EA in the Block (or what if there is no prev?)
BaseReg:
Offset: the accumulated adjustment in the Block
*/
.decl block_accumulated_stack_adjustments(EA:address,BaseReg:register,Offset:number)
.output block_accumulated_stack_adjustments

block_accumulated_stack_adjustments(Block,BaseReg,0):-
    block_adjusts_stack(Block,BaseReg,_).

block_accumulated_stack_adjustments(EA_next,BaseReg,Sum+Offset):-
    block_accumulated_stack_adjustments(EA,BaseReg,Sum),
    code_in_block(EA,Block),
    block_adjusts_stack(Block,BaseReg,_),
    (
        adjusts_stack_in_block(Block,EA,BaseReg,Offset);
        !adjusts_stack_in_block(Block,EA,BaseReg,_), Offset=0
    ),
    local_next(EA,EA_next).

.comp StackVarDefUse : AbstractDefUse<stack_var> {

    // When a value is stored to the stack, it defines a stack value.
    def(EA,[BaseReg,StackPos]):-
        (
            arch.frame_pointer(BaseReg);
            arch.stack_pointer(BaseReg)
        ),
        arch.store(EA,_,_,_,BaseReg,"NONE",_,StackPos).

    // TODO: flow_def (x86 can have these!)
    flow_def(0,nil,0,0):-
        false.

    // When a value is loaded from the stack, it is a use of a stack value.
    used(EA,[BaseReg,StackPos],SrcOp):-
        (
            arch.frame_pointer(BaseReg);
            arch.stack_pointer(BaseReg)
        ),
        arch.load(EA,SrcOp,_,_,BaseReg,"NONE",_,StackPos).

    // TODO: ensure we don't propagate through stack frame changes (at least, not without adjustment)

    ea_propagates_def(EA,[BaseReg,StackPos]):-
        !reg_def_use.def(EA,BaseReg),
        UNUSED(StackPos).

    block_propagates_def(Block,[BaseReg,StackPos]):-
        !reg_def_use.defined_in_block(Block,BaseReg),
        UNUSED(StackPos).

    .override live_var_used

    // TODO: can we eliminate this override?

    live_var_used(Block,[BaseReg,StackPos],EA_used,Index,0):-
        used_in_block(Block,EA_used,[BaseReg,StackPos],Index),
        !block_last_def(EA_used,_,[BaseReg,StackPos]),
        !reg_def_use.block_last_def(EA_used,_,BaseReg).

    // stack is adjusted in the block where the var is used
    live_var_used(Block,[BaseReg,StackPos+Offset],EA_used,Index,0):-
        used_in_block(Block,EA_used,[BaseReg,StackPos],Index),
        !block_last_def(EA_used,_,[BaseReg,StackPos]),
        block_accumulated_stack_adjustments(EA_used,BaseReg,Offset),
        Offset != 0.

    /*
    Intra-block def-use with stack var adjustment, e.g.:

    0000: movq %rax,16(%rsp)
    0004: subq $24,%rsp
    0008: movq 40(%rsp),%rax

    used(8,[RSP,40],1)
    code_in_block(8,0)
    adjusts_stack_in_block(0,4,RSP,24)
    block_accumulated_stack_adjustments(8,RSP,-24)
    local_next(0,4)
    block_accumulated_stack_adjustments(8,RSP,0)
    Diff = -24 - 0
    block_last_def(4,EA_def,[RSP,40+(-24)])
    */
    def_used(EA_def,[BaseReg,StackPos+Diff],EA_used,Index):-
        used(EA_used,[BaseReg,StackPos],Index),
        // There should be no last def since BaseReg is modified.
        !block_last_def(EA_used,_,[BaseReg,StackPos]),
        code_in_block(EA_used,Block),
        // query back for last_def with adjusted StackPos from each stack adjustment
        adjusts_stack_in_block(Block,EA_adjust,BaseReg,_),
        block_accumulated_stack_adjustments(EA_used,BaseReg,Ref2),
        local_next(EA_prev,EA_adjust),
        block_accumulated_stack_adjustments(EA_prev,BaseReg,Ref1),
        Diff = Ref2 - Ref1,
        block_last_def(EA_adjust,EA_def,[BaseReg,StackPos+Diff]).

    .decl live_stack_var_at_stack_adjustment(Block:address,Var:stack_var,EA_used:address,Index:operand_index,Adjustment:number,Moves:unsigned)

    live_stack_var_at_stack_adjustment(Block,[BaseReg,StackPos],EA_used,Index,Adjustment,Moves):-
        block_adjusts_stack(Block,BaseReg,Adjustment),
        live_var_at_block_end(Block,BlockUsed,[BaseReg,StackPos]),
        live_var_used(BlockUsed,[BaseReg,StackPos],EA_used,Index,Moves).

    // Interblock def-use with a def and adjustment in the same block
    def_used(EA_def,[BaseReg,StackPos+Diff],EA_used,Index):-
        live_stack_var_at_stack_adjustment(Block,[BaseReg,StackPos],EA_used,Index,Ref2,_),
        // query back for last_def with adjusted StackPos from each stack adjustment
        adjusts_stack_in_block(Block,EA_adjust,BaseReg,_),
        may_fallthrough(EA_prev,EA_adjust),
        code_in_block(EA_prev,Block),
        block_accumulated_stack_adjustments(EA_prev,BaseReg,Ref1),
        Diff = Ref2 - Ref1,
        block_last_def(EA_adjust,EA_def,[BaseReg,StackPos+Diff]).

    /*
    Generates a live_var_used where !code_in_block(EA_used,Block), similar to
    return value rules
    */
    live_var_used(Block,[BaseReg,StackPos+Offset],EA_used,Index,Moves+1):-
        live_stack_var_at_stack_adjustment(Block,[BaseReg,StackPos],EA_used,Index,Offset,Moves),
        // Ensure that this used() has not already propagated to this block too many times.
        // This breaks loops.
        Moves <= 1,
        // TODO: in addition to this last_def check, if it's defined under a
        // different alias when there are multiple stack adjustments in the
        // block, it really shouldn't propagate.
        // This is the inverse of the latter half of the two above def_used
        // rules
        !last_def_in_block(Block,_,[BaseReg,StackPos]).

}

.init stack_def_use = StackVarDefUse

/**
 * The register 'Reg' used as an address at address 'EA'.
 */
.decl used_for_address(EA:address,Reg:register)
.output used_for_address

used_for_address(EA,Reg):-
    reg_def_use.used(EA,Reg,Index),
    instruction_get_op(EA,Index,Op),
    op_indirect_contains_reg(Op,Reg).

used_for_address(EA,Reg):-
    reg_jump(EA,Reg),
    reg_def_use.used(EA,Reg,_).

used_for_address(EA,Reg):-
    reg_call(EA,Reg),
    reg_def_use.used(EA,Reg,_).

/**
 * The register 'Reg' as defined at address 'EA_def' is later used either as an address
 * or to compute an address.
 */
.decl def_used_for_address(EA_def:address,Reg:register)
.output def_used_for_address

def_used_for_address(EA_def,Reg):-
    reg_def_use.def_used(EA_def,Reg,EA,_),
    used_for_address(EA,Reg).

def_used_for_address(EA_def,Reg):-
    def_used_for_address(EA_used,_),
    reg_def_use.def_used(EA_def,Reg,EA_used,_).

def_used_for_address(EA,Reg):-
    arch.pc_relative_addr(EA,Reg,_).


// the last address where a register was defined within the block
.decl straight_line_last_def(EA:address,EA_def:address,Reg:register)

straight_line_last_def(EA_next,EA,Reg):-
    reg_def_use.def(EA,Reg),
    possible_ea(EA),
    must_fallthrough(EA,EA_next),
    possible_ea(EA_next).

straight_line_last_def(EA_next,EA_def,Reg):-
    straight_line_last_def(EA,EA_def,Reg),
    !reg_def_use.must_def(EA,Reg),
    must_fallthrough(EA,EA_next),
    possible_ea(EA_next).

/**
straight_line_def_used is a weaker version than reg_def_use.def_used
that can be used BEFORE code inference.
*/
.decl straight_line_def_used(EA_def:address,Reg:register,EA_used:address,Index:unsigned)

straight_line_def_used(EA_def,Reg,EA_used,Index):-
    reg_def_use.used_explicit(EA_used,Reg,Index),
    straight_line_last_def(EA_used,EA_def,Reg).
