//===- value_analysis.dl ------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module performs a basic value analysis.

The value of a register at a point (ea) is expressed as the value of another
at another point (EA_reg1)  multiplied by a multiplier plus an offset:

 val(Reg,EA) = val(Reg1,EA_reg1)* Multiplier+ Offset

In some cases we can obtain a term of the form:

- val(Reg,EA) =  Offset

If we can obtain that the register is assigned a constant

- val(Reg,EA) = Unknown * Multiplier+ Offset

If we detect a loop where the register gets incremented 'Multiplier' in each iteration

The analysis first computes `value_reg_edge` which are facts of the form
above defined for different instruction and using the def-use chains.

Then, we have a propagation phase where `value_reg` is computed. This
phase chains individual `value_reg_edge` together.  In addition to
chaining edges together it takes care of cases such as two registers
added together or substracted if it turns out that they can be
expressed in terms of the same register.  It also detects possible
loops.

This propagation is limited in the number of steps using `step_limit`
to ensure termination and efficiency.

As a result, we might obtain more than one 'value' for a certain
register at a certain location. best_value_reg selects only one of
these values prioritizing the two special cases from above (constant
or loop) and considering the value with most steps.

*/

.decl value_reg_edge(EA:address,Reg:register,
                EA_reg1:address,Reg1:register,Multiplier:number,Offset:number)
.output value_reg_edge
.decl value_reg(EA:address,Reg:register,
                EA_reg1:address,Reg1:register,Multiplier:number,Offset:number,steps:number)
.output value_reg

.decl best_value_reg(EA:address,Reg:register,EA_from:address,Multiplier:number,Offset:number,type:symbol)
.output best_value_reg

// mov reg immediate
value_reg_edge(EA,Reg,EA,"NONE",0,Immediate):-
    def_used_for_address(EA,Reg),
    arch.move_operation(Operation),
    op_immediate_and_reg(EA,Operation,Reg,_,Immediate).

.decl reg_stored_in_stack(EA:address,Reg:register,StackPos:number, StackFrameDefinedAt: address)
.output reg_stored_in_stack

reg_stored_in_stack(EA,Reg,StackPos,StackFrameDefinedAt):-
    (
        arch.frame_pointer(Base);
        arch.stack_pointer(Base)
    ),
    def_used(StackFrameDefinedAt,Base,EA,_),
    arch.mov(EA),
    instruction_get_dest_op(EA,_,DestOp),
    op_indirect(DestOp,"NONE",Base,"NONE",_,StackPos,_),
    instruction_get_src_op(EA,_,SrcOp),
    op_regdirect_contains_reg(SrcOp,Reg).

.decl reg_loaded_from_stack(EA:address,Reg:register,Base:register,StackPos:number, StackFrameDefinedAt: address)
.output reg_loaded_from_stack

reg_loaded_from_stack(EA,Reg,Base,StackPos,StackFrameDefinedAt):-
    (
        arch.frame_pointer(Base);
        arch.stack_pointer(Base)
    ),
    def_used(StackFrameDefinedAt,Base,EA,_),
    arch.mov(EA),
    instruction_get_src_op(EA,_,SrcOp),
    op_indirect(SrcOp,"NONE",Base,"NONE",_,StackPos,_),
    instruction_get_dest_op(EA,_,DestOp),
    op_regdirect_contains_reg(DestOp,Reg).

reg_loaded_from_stack(EA,Reg,Base,StackPos,PrevStackFrame):-
    reg_stored_in_stack(_,_,StackPos,PrevStackFrame),
    arch.stack_pointer(Base),
    last_def(NextStackFrame,PrevStackFrame,Base),
    (
        op_immediate_and_reg(NextStackFrame,"SUB",Base,_,Immediate),
        reg_loaded_from_stack(EA,Reg,Base,StackPos+Immediate,NextStackFrame)
        ;
        op_immediate_and_reg(NextStackFrame,"ADD",Base,_,Immediate),
        reg_loaded_from_stack(EA,Reg,Base,StackPos-Immediate,NextStackFrame)
    ).

// Register saved and loaded from stack
// This is flow insensitive but we make sure that the load and store
// refer to the same stack frame, identified by the address where RBP is defined.
value_reg_edge(EALoad,Reg,EAPrev,Reg,1,0):-
    reg_stored_in_stack(EAStore,Reg,StackPos, StackFrameDefinedAt),
    reg_loaded_from_stack(EALoad,Reg,_,StackPos, StackFrameDefinedAt),
    def_used(EAPrev,Reg,EAStore,_).

// mov DWORD from memory
value_reg_edge(EA,Reg,EA,"NONE",0,Val):-
    def_used_for_address(EA,Reg),
    arch.move_operation(Operation),
    instruction(EA,_,_,Operation,Op1,Op2,0,0,_,_),
    op_regdirect_contains_reg(Op2,Reg),
    op_indirect(Op1,"NONE","NONE","NONE",_,Offset,32),
    Offset >= 0,
    Offset_addr = as(Offset,address),
    data_byte(Offset_addr,Byte0),
    data_byte(Offset_addr+1,Byte1),
    data_byte(Offset_addr+2,Byte2),
    data_byte(Offset_addr+3,Byte3),
    Byte3 <= 128,
    Val = as(Byte3*2^24+ Byte2*2^16 + Byte1*2^8 + Byte0,number).

value_reg_edge(EA,Reg,EA,"NONE",0,Val):-
    def_used_for_address(EA,Reg),
    arch.move_operation(Operation),
    instruction(EA,_,_,Operation,Op1,Op2,0,0,_,_),
    op_regdirect_contains_reg(Op2,Reg),
    op_indirect(Op1,_,_,_,_,_,32),
    pc_relative_operand(EA,1,Offset),
    data_byte(Offset,Byte0),
    data_byte(Offset+1,Byte1),
    data_byte(Offset+2,Byte2),
    data_byte(Offset+3,Byte3),
    Byte3 <= 128,
    Val = as(Byte3*2^24+ Byte2*2^16 + Byte1*2^8 + Byte0,number).

// register implicitly defined
value_reg_edge(EA,Reg,EA,"NONE",0,Immediate):-
    def_used_for_address(EA,Reg),
    flow_def(EA,Reg,_,Immediate).

// pc-relative LEA
value_reg_edge(EA,Reg,EA,"NONE",0,Address):-
    code(EA),
    instruction(EA,Size,_,"LEA",Op1,Op2,0,0,_,_),
    op_indirect(Op1,_,PcReg,"NONE",_,Offset,_),
    arch.pc_register(PcReg),
    op_regdirect_contains_reg(Op2,Reg),
    Address = as(EA+Size,number)+Offset.

// GOT-relative LEA. (Note that We drop the GOT Register.)
value_reg_edge(EA,Reg,EA,"NONE",0,Address):-
    got_relative_operand(EA,1,Offset),
    instruction(EA,_,_,"LEA",_,Op2,0,0,_,_),
    op_regdirect_contains_reg(Op2,Reg),
    Address = as(Offset,number).

//mov reg reg_origin
value_reg_edge(EA,Reg,EA_prev,Reg_origin,1,0):-
    def_used_for_address(EA_prev,Reg_origin),
    def_used(EA_prev,Reg_origin,EA,_),
    arch.mov(EA),
    instruction_get_op(EA,1,Op1),
    op_regdirect_contains_reg(Op1,Reg_origin),
    instruction_get_op(EA,2,Op2),
    op_regdirect_contains_reg(Op2,Reg),
    EA != EA_prev.

//reset a register
value_reg_edge(EA,Reg,EA,"NONE",0,0):-
    def_used_for_address(EA,Reg),
    is_xor_reset(EA).

// basic arithmetic operations
value_reg_edge(EA,Dst,EA_prev,Src,Mult,Immediate):-
    def_used_for_address(EA_prev,Src),
    def_used(EA_prev,Src,EA,_),
    arch.reg_arithmetic_operation(EA,Dst,Src,Mult,Immediate).

/** A register is defined using an unknown value
 This predicate is used to create trivial leaf edges in
 the value_reg graph `step_limit` .*/
.decl value_reg_unsupported(EA:address, Reg:register)

// Load a register from a non-constant memory address
value_reg_unsupported(EA,Reg):-
    def_used_for_address(EA,Reg),
    arch.mov(EA),
    instruction(EA,_,_,_,Op1,Op2,0,0,_,_),
    op_regdirect_contains_reg(Op2,Reg),
    op_indirect(Op1,_,RegBase,RegIndex,_,_,_),
    (
        RegBase != "NONE",
        RegIndex = RegIndex // avoid warning
        ;
        RegIndex != "NONE",
        RegBase = RegBase // avoid warning
    ).

// Load a register from a register that is not tracked
value_reg_unsupported(EA,Reg):-
    def_used_for_address(EA,Reg),
    arch.mov(EA),
    instruction(EA,_,_,_,Op1,Op2,0,0,_,_),
    op_regdirect_contains_reg(Op2,Reg),
    op_regdirect(Op1,_),
    !op_regdirect_contains_reg(Op1,_).

// Register defined in a call
value_reg_unsupported(EA,Reg):-
    def_used_for_address(EA,Reg),
    instruction_get_operation(EA,Operation),
    arch.call_operation(Operation).

///////////////////////////////////////////////////////////////////////////////////////
// once we have the edges that relate the values of registers at different
// instructions we propagate these values forward

.decl step_limit(Limit:number)

step_limit(12).

//base cases
value_reg(EA,Reg,EA,"NONE",Mult,Immediate,1):-
    value_reg_edge(EA,Reg,EA,"NONE",Mult,Immediate).

value_reg(EA,Reg,EA,Reg,1,0,1):-
    def_used_for_address(EA,Reg),
    value_reg_unsupported(EA,Reg).

// possible loop
value_reg(EA,Reg,EA_from,"Unknown",Immediate,Base,Steps+1):-
    step_limit(StepLimit),
    value_reg(EA,Reg,EA_from,"NONE",0,Base,Steps),
    value_reg_edge(EA,Reg,EA,Reg,1,Immediate),
    Immediate != 0,
    Steps+1 < StepLimit.

/**
This is an auxiliary predicate used for computing `value_reg`.
It captures an instruction at `EA` that defines register `Reg_def` by operating
with two register `Reg1` and `Reg2` defined at `EA_def1` and `EA_def1`.

The operation is Reg_def = Reg1 + Reg2 * Mult + Offset.
*/
.decl reg_reg_arithmetic_operation_defs(EA:address,Reg_def:register,EA_def1:address,Reg1:register,EA_def2:address,Reg2:register,Mult:number,Offset:number)

reg_reg_arithmetic_operation_defs(EA,Reg_def,EA_def1,Reg1,EA_def2,Reg2,Mult,Offset):-
    def_used_for_address(EA,Reg_def),
    arch.reg_reg_arithmetic_operation(EA,Reg_def,Reg1,Reg2,Mult,Offset),
    Reg1 != Reg2,
    def_used(EA_def1,Reg1,EA,_),
    def_used(EA_def2,Reg2,EA,_),
    EA != EA_def1,
    EA != EA_def2.

// deal with arithmetic operations on two registers when their value ultimately refers to the same register
value_reg(EA,Reg_def,EA_third,Reg3,Mult1+(Mult*Mult2),Offset+Offset1+Offset2*Mult,Steps3):-
    step_limit(StepLimit),
    reg_reg_arithmetic_operation_defs(EA,Reg_def,EA_def1,Reg1,EA_def2,Reg2,Mult,Offset),

    value_reg(EA_def1,Reg1,EA_third,Reg3,Mult1,Offset1,Steps1),
    Steps1+2 < StepLimit,
    EA != EA_third,
    value_reg(EA_def2,Reg2,EA_third,Reg3,Mult2,Offset2,Steps2),

    Steps2+2 < StepLimit,
    Steps3 = max(Steps1,Steps2)+2.

// deal with arithmetic operation on two registers when one of the registers contains a constant
value_reg(EA,Reg_def,EA_third,Reg3,Mult*Mult2,Offset+Offset1+Offset2*Mult,Steps3):-
    step_limit(StepLimit),
    reg_reg_arithmetic_operation_defs(EA,Reg_def,EA_def1,Reg1,EA_def2,Reg2,Mult,Offset),

    value_reg(EA_def1,Reg1,_,"NONE",_,Offset1,Steps1),
    Steps1+2 < StepLimit,
    value_reg(EA_def2,Reg2,EA_third,Reg3,Mult2,Offset2,Steps2),
    EA != EA_third,
    Reg3 != "NONE",
    Steps2+2 < StepLimit,
    // this is an empirical restriction. There is no logical problem
    // with having a negative multiplier but it appears in cases
    // where it leads to false positives.
    Mult >= 0,
    Steps3 = max(Steps1,Steps2)+2.

// the other register constains a constant.
value_reg(EA,Reg_def,EA_third,Reg3,Mult1,Offset+Offset1+Offset2*Mult,Steps3):-
    step_limit(StepLimit),
    reg_reg_arithmetic_operation_defs(EA,Reg_def,EA_def1,Reg1,EA_def2,Reg2,Mult,Offset),
    def_used_for_address(EA,Reg_def),
    value_reg(EA_def2,Reg2,_,"NONE",_,Offset2,Steps2),
    Steps2+2 < StepLimit,
    value_reg(EA_def1,Reg1,EA_third,Reg3,Mult1,Offset1,Steps1),
    Reg3 != "NONE",
    EA != EA_third,
    Steps1+2 < StepLimit,

    Steps3 = max(Steps1,Steps2)+2.

// normal propagation
value_reg(EA1,Reg1,EA3,Reg3,Multiplier*Multiplier2,(Offset2*Multiplier)+Offset,Steps2):-
    step_limit(StepLimit),
    value_reg(EA2,Reg2,EA3,Reg3,Multiplier2,Offset2,Steps),
    value_reg_edge(EA1,Reg1,EA2,Reg2,Multiplier,Offset),
    EA1 != EA2,
    // we allow less back steps
    (
        EA2 < EA1,
        Steps2 = Steps+1
        ;
        EA2 >= EA1,
        Steps2 = Steps+5
    ),
    Steps2 < StepLimit.

// For a given EA, Reg, EA_from and Multiplier we keep the minimum and maximum offsets
best_value_reg(EA,Reg,EA_from,Multiplier,MinOffset,"loop"):-
    !def_used_return_val_reg(EA,_,Reg,_,_),
    value_reg(EA,Reg,EA_from,"Unknown",Multiplier,MinOffset,_),
    MinOffset <= min Offset:{value_reg(EA,Reg,EA_from,"Unknown",Multiplier,Offset,_)}.

best_value_reg(EA,Reg,EA_from,Multiplier,MaxOffset,"loop"):-
    !def_used_return_val_reg(EA,_,Reg,_,_),
    value_reg(EA,Reg,EA_from,"Unknown",Multiplier,MaxOffset,_),
    MaxOffset >= max Offset:{value_reg(EA,Reg,EA_from,"Unknown",Multiplier,Offset,_)}.

best_value_reg(EA,Reg,EA_from,Multiplier,Offset,"complete"):-
    value_reg(EA,Reg,EA_from,"NONE",Multiplier,Offset,_),
    !value_reg(EA,Reg,_,"Unknown",_,_,_).

best_value_reg(EA,Reg,0,MaxMultiplier,Offset,"incomplete"):-
    value_reg(EA,Reg,_,OtherReg,MaxMultiplier,Offset,_),
    OtherReg != "NONE",
    !value_reg(EA,Reg,_,"Unknown",_,_,_),
    MaxMultiplier >= max Multiplier:{value_reg(EA,Reg,_,_,Multiplier,_,_)}.
