#pragma once

#include <map>
#include <string>
#include <cstdint>
#include <vector>
#include "Table.h"

///
/// \class Disasm
///
/// Port of the prolog disasm.
///
class Disasm
{
public:
	///
	/// Read all of the expected file types out of a directory.
	///
	void parseDirectory(std::string x);

	///
	/// Parse the statistics facts file.
	///
	void parseSymbol(const std::string& x);
	void parseSection(const std::string& x);
	void parseRelocation(const std::string& x);
	void parseInstruction(const std::string& x);
	void parseOpRegdirect(const std::string& x);
	void parseOpImmediate(const std::string& x);
	void parseOpIndirect(const std::string& x);
	void parseDataByte(const std::string& x);

	void parseBlock(const std::string& x);
	void parseCodeInblock(const std::string& x);
	void parseRemainingEA(const std::string& x);
	void parseFunctionSymbol(const std::string& x);
	void parseMainFunction(const std::string& x);
	void parseStartFunction(const std::string& x);
	void parseFunctionEntry(const std::string& x);
	void parseAmbiguousSymbol(const std::string& x);
	void parseDirectCall(const std::string& x);
	void parsePLTReference(const std::string& x);
	void parseSymbolicOperand(const std::string& x);
	void parseMovedLabel(const std::string& x);
	void parseLabeledData(const std::string& x);
	void parseSymbolicData(const std::string& x);
	void parseSymbolMinusSymbol(const std::string& x);
	void parseMovedDataLabel(const std::string& x);
	void parseString(const std::string& x);
	void parseBSSData(const std::string& x);
	void parseStackOperand(const std::string& x);
	void parsePreferredDataAccess(const std::string& x);
	void parseDataAccessPattern(const std::string& x);
	void parseDiscardedBlock(const std::string& x);
	void parseDirectJump(const std::string& x);
	void parsePCRelativeJump(const std::string& x);
	void parsePCRelativeCall(const std::string& x);
	void parseBlockOverlap(const std::string& x);
	void parseDefUsed(const std::string& x);
	void parsePairedDataAccess(const std::string& x);
	void parseValueReg(const std::string& x);
	void parseIncompleteCFG(const std::string& x);
	void parseNoReturn(const std::string& x);
	void parseInFunction(const std::string& x);

private:
	// these are facts generated by the decoder
	Table symbol{5};
	Table section{3};
	Table relocation{4};
	Table instruction{6};
	Table op_regdirect{2};
	Table op_immediate{2};
	Table op_indirect{7};
	Table data_byte{2};

	// these facts are necessary for printing the asm
	Table block{1};
	Table code_in_block{2};
	Table remaining_ea{1};
	Table function_symbol{2};
	Table main_function{1};
	Table start_function{1};
	Table function_entry{1};
	Table ambiguous_symbol{1};
	Table direct_call{2};
	Table plt_reference{2};
	Table symbolic_operand{2};
	Table moved_label{4};
	Table labeled_data{1};
	Table symbolic_data{2};
	Table symbol_minus_symbol{3};
	Table moved_data_label{3};
	Table string{2};
	Table bss_data{1};

	// these facts are only used for generating hints
	Table stack_operand{2};
	Table preferred_data_access{2};
	Table data_access_pattern{4};

	// these facts are only collected for printing debugging information
	Table discarded_block{1};
	Table direct_jump{2};
	Table pc_relative_jump{2};
	Table pc_relative_call{2};
	Table block_overlap{2};
	Table def_used{4};
	Table paired_data_access{6};
	Table value_reg{7};
	Table incomplete_cfg{1};
	Table no_return{1};
	Table in_function{2};
};
