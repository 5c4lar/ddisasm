//===- no_return_analysis.dl ------------------------------------*- C++ -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
 no_return and no_return_call are mutually recursive definitions
 that implement a must analysis that propagates over (potentially) the
 whole program.

 The analysis is a must analysis so it cannot propagate if there are jumps that are not defined
 In order to propagate through SCC we need to compute their exits
 if none of their exits return, and the CFG is complete, the SCC never returns.
*/
.number_type address
.number_type scc

.decl cfg_edge(src:address,dest:address,conditional:symbol,indirect:symbol,type:symbol)
.input cfg_edge

.decl cfg_edge_to_top(src:address,conditional:symbol,indirect:symbol,type:symbol)
.input cfg_edge_to_top

.decl cfg_edge_to_symbol(src:address,symbol:symbol,conditional:symbol,indirect:symbol,type:symbol)
.input cfg_edge_to_symbol

.decl in_scc(scc:scc,index:number,block:address)
.input in_scc


.decl direct_call(src:address,dest:address)
.decl direct_jump(src:address,dest:address)
.decl fallthrough(src:address,dest:address)
.decl return(srd:address)

direct_call(Src,Dest):-
    cfg_edge(Src,Dest,_,"false","call").

direct_jump(Src,Dest):-
    cfg_edge(Src,Dest,_,"false","jump").

fallthrough(Src,Dest):-
    cfg_edge(Src,Dest,_,"false","fallthrough").

return(Src):-
    cfg_edge(Src,Dest,_,_,"return");
    cfg_edge_to_top(Src,_,_,"return").

.decl incomplete_block(src:address)

incomplete_block(Src):-
    cfg_edge(Src,_,_,"true","jump");
    cfg_edge_to_top(Src,_,"true","jump");
    cfg_edge_to_symbol(Src,_,_,"true","jump").

.decl no_return(Block:address)
.output no_return

.decl block_call_no_return(Block:address)
.output no_return

.decl scc_no_return(Scc:scc)

// initial seeds for the analysis
.decl no_return_function(Name:symbol)

no_return_function("exit").
no_return_function("_exit").
no_return_function("abort").
no_return_function("__stack_chk_fail").
no_return_function("__assert_fail").
no_return_function("longjump").

////////////////////////////////////////////////////////////////////////////
.decl block_in_scc_has_exit(scc:scc,block:address,exit:address)


block_in_scc_has_exit(Scc,Block,Exit):-
    in_scc(Scc,_,Block),
    (
        direct_jump(Block,Exit);
        fallthrough(Block,Exit)
    ),
    !in_scc(Scc,_,Exit).


.decl last_in_scc(Scc:scc, MaxIndex:number)

last_in_scc(Scc,MaxIndex):-
    in_scc(Scc,_,_),
    MaxIndex = max X: {in_scc(Scc,X,_)}.

.decl scc_complete_block(Scc:scc,Index:number)

scc_complete_block(Scc,0):-
    in_scc(Scc,0,Block),
    !incomplete_block(Block),
    !return(Block).

scc_complete_block(Scc,N+1):-
    scc_complete_block(Scc,N),
    in_scc(Scc,N+1,Block),
    !incomplete_block(Block),
    !return(Block).

.decl scc_exit_no_return(Scc:scc,Index:number)

scc_exit_no_return(Scc,0):-
    in_scc(Scc,0,Block),
    (
        block_in_scc_has_exit(Scc,Block,Exit),
        no_return(Exit)
        ;
        !block_in_scc_has_exit(Scc,Block,_)
    ).

scc_exit_no_return(Scc,N+1):-
    scc_exit_no_return(Scc,N),
    in_scc(Scc,N+1,Block),
    (
        block_in_scc_has_exit(Scc,Block,Exit),
        no_return(Exit)
        ;
        !block_in_scc_has_exit(Scc,Block,_)
    ).

scc_no_return(Scc):-
    last_in_scc(Scc,MaxBlockIndex),
    scc_complete_block(Scc,MaxBlockIndex),
    scc_exit_no_return(Scc,MaxBlockIndex).

/////////////////////////////////////////////////////////////////////

// a block does not return if it ends in a call that does no return
block_call_no_return(Block):-
    cfg_edge_to_symbol(Block,Symbol,_,_,"call"),
    no_return_function(Symbol).

block_call_no_return(Block):-
    no_return(Next),
    direct_call(Block,Next).

no_return(Block):-
    block_call_no_return(Block).

//inconditional jump
no_return(Block):-
    no_return(Dest),
    direct_jump(Block,Dest),
    !fallthrough(Block,_).

// conditional jump
no_return(Block):-
    no_return(Next),
    fallthrough(Block,Next),
    direct_jump(Block,Dest),
    no_return(Dest).

// only fallthrough
no_return(Block):-
    no_return(Next),
    fallthrough(Block,Next),
    !direct_jump(Block,_),
    !incomplete_block(Block).


no_return(Block):-
    scc_no_return(SCC),
    in_scc(SCC,_,Block).
