.decl depend_addr(N:depend, EA:address) inline

depend_addr(N, EA):-
    value_depend(_, [EA, _, _], N).
    
.decl addr_in_tree(N:depend, EA:address)
addr_in_tree(N, EA):-
    depend_addr(N, EA).

addr_in_tree($Node(x, h, l, r), EA):-
    value_depend(_, _, $Node(x, h, l, r)),
    l=l, r=r,
    (addr_in_tree(l, EA);
    addr_in_tree(r, EA)).

.decl tree_leaf(N:depend, EA:address)
tree_leaf($Leaf(EA), EA):-
    value_depend(_, _, $Leaf(EA)).

tree_leaf($Node(x, h, l, r), EA):-
    value_depend(_, _, $Node(x, h, l, r)),
    l=l,r=r,
    (tree_leaf(l, EA);
    tree_leaf(r, EA)).

value_depend($Register(EA_call, Reg, 0, "reg", "in"), [EA_call, 0, 0], $Leaf(EA_call)):-
    direct_call(EA_call, _),
    return_val_reg(Reg).

value_depend(Val, [EA, 0, 0], $Leaf(EA)):-
    instruction_get_operation(EA, Operation),
    Operation="LEA",
    op_to_val(EA, _, _, "in", _, Val),
    op_to_val(EA, _, _, "out", "global", _).

// value_depend($Register(EA, Reg, 0, "reg", "in"), [EA, 0, 0], $Leaf(EA)):-
//     best_symexpr_symbol(as(Address, address), _, _),
//     !is_xor_reset(EA),
//     Address != 0,
//     value_reg(EA, Reg, EA, "NONE", 0, Address, _).

value_depend($Register(EA, Reg, Index, "reg", "in"), [EA, 0, 0], $Leaf(EA)):-
    value_def($Register(EA, Reg, Index, "reg", "in")),
    frame_pointer(Reg).

// value_depend(DstVal, [EA, 0, 0], $Leaf(EA)):-
//     mov(EA),
//     instruction_get_dest_op(EA, Index1, Op1),
//     op_to_val(EA, Op1, Index1, "in", _, DstVal),
//     instruction_get_src_op(EA, Index2, Op2),
//     op_to_val(EA, Op2, Index2, "out", _, $Immediate(EA, _, "data")).

value_depend($Immediate(EA, Val, "data"), [EA, 0, 0], $Leaf(EA)):-
    op_to_val(EA, _, _, "out", _, $Immediate(EA, Val, "data")).

value_depend(Val, From, Depend):-
    op_to_val(_, _, _, "out", _, Val),
    address_expr_simplified(Val, Exp),
    op_to_val(_, _, _, "in", _, Src),
    address_expr_simplified(Src, Exp),
    value_depend(Src, From, Depend),
    !value_def_used(_, Val, _).

value_depend($Empty_val(), [0, 0, 0], $Leaf(0)).

value_depend(Used, From, Depend):-
    value_def_used(Def, Used, _),
    value_depend(Def, From, Depend).

value_depend(Dst, From, Depend):-
    value_edge(Src, Dst, _),
    value_depend(Src, From, Depend).

value_depend(Dst, [EA, EA1, EA2], $Node(EA, h, Depend1, Depend2)):-
    op_to_val(EA, _, _, _, _, Dst),
    value_arithmetic_edge(Dst, Src1, Src2, _, _),
    (value_depend(Src1, [EA1, _, _], $Node(EA1, h1, l1, r1)), Depend1=$Node(EA1, h1, l1, r1);
    value_depend(Src1, [EA1, _, _], $Leaf(x)),h1=0,Depend1=$Leaf(x)),
    (value_depend(Src2, [EA2, _, _], $Node(EA2, h2, l2, r2)),Depend2=$Node(EA2, h2, l2, r2);
    value_depend(Src2, [EA2, _, _], $Leaf(y)),h2=0,Depend2=$Leaf(y)),
    h = max(h1, h2) + 1.

.decl not_ptr(EA:address)
not_ptr(EA):-
    value_arithmetic_edge(_, _, Src2, Mult, _),
    value_depend(Src2, _, Depend),
    Mult != 1,
    tree_leaf(Depend, EA).

not_ptr(EA):-
    op_to_val(EA_mem, _, Index, _, _, $Memory(_, _, _, Mult, _, _)),
    op_to_val(EA_mem, _, Index, "idx", _, Val),
    value_depend(Val, _, Depend),
    Mult != 1,
    tree_leaf(Depend, EA).

ptr_candidate(EA_leaf):-
    value_depend(Val, _, Depend),
    (op_to_val(_, _, _, "base", _, Val);
    op_to_val(_, _, _, "idx", _, Val)),
    tree_leaf(Depend, EA_leaf).

ptr_candidate(EA_leaf):-
    type_hint(Depend, "ptr"),
    tree_leaf(Depend, EA_leaf).

ptr_candidate(EA_may) <= ptr_candidate(_):-
    not_ptr(EA_may).

.decl type_hint(Depend:depend, Type:symbol)
type_hint(Depend, Type):-
    function_reg_arg(EA, Callee, $Register(EA, Reg, Index, "reg", "in")),
    value_depend($Register(EA, Reg, Index, "reg", "in"), _, Depend),
    cfg_edge_to_symbol(Callee, Function, _),
    arg_idx(Reg, Idx),
    function_prototype(Function, Idx, Type).

// .decl ptr_false_positive(Depend:depend)
// .output ptr_false_positive
// ptr_false_positive(Depend):-
//     ptr_candidate(_, Depend),
//     evaluate_val(_, _, _, Depend, "data", _).