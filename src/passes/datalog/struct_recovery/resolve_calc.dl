value_arithmetic_operation(EA, [EA, Base, Offset, "mem_calc"], [EA, Base, Offset, "mem"], nil, 1, Offset_res):-
    code(EA),
    instruction_get_operation(EA, Operation),
    instruction_get_dest_op(EA, Idx1, Op1),
    instruction_get_src_op(EA, Idx1, Op1),
    instruction_get_src_op(EA, Idx2, Op2),
    Idx2 != Idx1,
    op_indirect(Op1,"NONE",Base,"NONE",_,Offset,_),
    op_immediate(Op2, Immediate),
    (Operation="ADD",Offset_res=as(Immediate, number); Operation="SUB",Offset_res=-as(Immediate, number)).
    
value_arithmetic_edge([EA, Reg, 0, "calc"], [EA, Reg1, 0, "reg"], nil, 1, Offset):-
    code(EA),
    reg_arithmetic_operation(EA, Reg, Reg1, 1, Offset).

value_arithmetic_edge([EA, Reg, 0, "calc"], nil, [EA, Reg1, 0, Type], Mult, Offset):-
    code(EA),
    instruction_get_operation(EA, Operation),
    (Operation != "LEA", Type="reg";
    Operation = "LEA", Type="idx"),
    reg_arithmetic_operation(EA, Reg, Reg1, Mult, Offset),
    Mult != 1.

value_arithmetic_edge([EA, Reg1, 0, "calc"], [EA, Reg2, 0, Type1], [EA, Reg3, 0, Type2], Mult, Offset):-
    code(EA),
    instruction_get_operation(EA, Operation),
    (Operation != "LEA", Type1="reg", Type2="reg";
    Operation = "LEA", Type1="base", Type2="idx"),
    reg_reg_arithmetic_operation(EA, Reg1, Reg2, Reg3, Mult, Offset).

value_arithmetic_edge([EA, Reg1, 0, "calc"], [EA, Reg2, 0, Type1], [EA, Reg3, 0, Type2], Mult, Offset):-
    code(EA),
    instruction_get_operation(EA, Operation),
    (Operation != "LEA", Type1="reg", Type2="reg";
    Operation = "LEA", Type1="idx", Type2="base"),
    reg_reg_arithmetic_operation(EA, Reg1, Reg2, Reg3, Mult, Offset),
    Mult = 1.
  
value_arithmetic_edge([EA, Reg, 0, "calc"], [EA, Base, 0, "base"], [EA, Idx, 0, "idx"], Mult, Offset):-
    (value_def([EA, Reg, _, "mem_bias"]);
    value_used([EA, Reg, _, "mem_bias"])),
    mov(EA),
    code(EA),
    instruction_get_op(EA,_,DestOp),
    op_indirect(DestOp,"NONE",Base,Idx,Mult,Offset,_).

value_arithmetic_edge([EA, Reg, 0, "calc"], [EA, Base, 0, "base"], [EA, Idx, 0, "idx"], 1, Offset):-
    (value_def([EA, Reg, _, "mem_bias"]);
    value_used([EA, Reg, _, "mem_bias"])),
    mov(EA),
    code(EA),
    instruction_get_op(EA,_,DestOp),
    op_indirect(DestOp,"NONE",Base,Idx,1,Offset,_).
  
value_arithmetic_edge(Dst, Src, nil, Mult, Offset):-
    value_arithmetic_operation(_, Dst, Src, nil, Mult, Offset).

loop_detected(Start, End, Steps, Counter):-
    code(EA),
    instruction_get_operation(EA, Operation),
    cmp_operation(Operation),
    code_in_refined_block(EA, Block),
    block_last_instruction(Block, Block_end),
    instruction_get_op(EA,Idx1,Op1),
    instruction_get_op(EA,Idx2,Op2),
    Idx1 != Idx2,
    op_indirect(Op1,"NONE",Base,"NONE",_,Offset,_),
    op_immediate(Op2, End_imm),
    value_root([EA, Base, Offset, Type], Src1, _),
    value_root([EA, Base, Offset, Type], Src2, _),
    Src1 != Src2,
    Counter=Src1,
    resolve_calc(Src1, nil, nil, 1, Start),
    value_arithmetic_edge(Src2, Val, _, _, Unit),
    value_root(Val, Src1, _),
    Steps = Unit,
    instruction_get_operation(Block_end, Operation_jmp),
    (Operation_jmp="JLE",
    (End = End_imm + 1, Steps > 0;End = End_imm,Steps < 0)).

resolve_calc_helper([EA, Reg, 0, "calc"], [0, "NONE", 0, "global"], nil, 1, Address):-
    value_reg(EA, Reg, EA, "NONE", 0, Address, _).

resolve_calc_helper([EA, Base, Address, "global"], [0, "NONE", 0, "global"], nil, 1, Address):-
    value_def([EA, Base, Address, "global"]);
    value_used([EA, Base, Address, "global"]).

resolve_calc_helper([EA, Base, Offset, Type], [EA, Base, Offset, Type], nil, 1, 0):-
    value_src([EA, Base, Offset, Type], EA, "function").

resolve_calc_helper([EA, Idx, Address, "global_bias"], [0, "NONE", 0, "global"], Root_idx, Mult, Address):-
    (value_def([EA, Idx, Address, "global_bias"]),
    instruction_get_dest_op(EA,_,Op),
    op_indirect(Op,"NONE","NONE",Idx,Mult,_,_);
    value_used([EA, Idx, Address, "global_bias"]),
    instruction_get_src_op(EA,_,Op),
    op_indirect(Op,"NONE","NONE",Idx,Mult,_,_)),
    value_root([EA, Idx, 0, "idx"], Root_idx, _).

// resolve to root
resolve_calc_helper([EA, Base, 0, "calc"], Root, Idx, Mult, Offset):-
    value_arithmetic_edge([EA, Base, 0, "calc"], Op1, Op2, Mult, Offset),
    value_root(Op1, Root, _),
    value_root(Op2, Idx , _),
    ((Root = [EA_root, Base_root, Offset_root, Type_root],
    EA_root=EA_root, Base_root=Base_root, Offset_root=Offset_root,
    Type_root != "calc");
    Root = nil),
    ((Idx = [EA_idx, Base_idx, Offset_idx, Type_idx],
    EA_idx=EA_idx, Base_idx=Base_idx, Offset_idx=Offset_idx,
    Type_idx != "calc", Type_idx != "mem_calc");
    Idx = nil).

resolve_calc_helper([EA, Base, Offset, Type], [EA, Base, Offset, Type], nil, 1, 0):-
    value_used_for_address(_, _, _, [EA, Base, Offset, Type]),
    !value_src([EA, Base, Offset, Type], EA, "global_ptr"),
    Type!="calc",Type!="global",Type!="global_bias".

resolve_calc_helper([EA, Base, Offset, Type], nil, nil, 1, Immediate):-
    value_src([EA, Base, Offset, Type], EA, "immediate"),
    mov(EA),
    code(EA),
    instruction_get_src_op(EA,_,SrcOp),
    op_immediate(SrcOp, Immediate).

resolve_calc(Calc, Root, Idx, Mult, Offset):-
    resolve_calc_helper(Calc, Root, Idx, Mult, Offset).

// resolve idx
resolve_calc([EA, Base, 0, "calc"], Root, Idx, Mult_res, Offset_res):-
    value_arithmetic_edge([EA, Base, 0, "calc"], Op1, Op2, Mult, Offset),
    value_root(Op1, Root, _),
    value_root(Op2, [EA_idx, Base_idx, 0, "calc"], _),
    ((Root = [EA_root, Base_root, Offset_root, Type_root],
    EA_root=EA_root, Base_root=Base_root, Offset_root=Offset_root,
    Type_root != "calc");
    Root = nil),
    EA!=EA_idx,
    resolve_calc_helper([EA_idx, Base_idx, 0, "calc"], nil, Idx, Mult_idx, Offset_idx),
    Mult_res = Mult * Mult_idx,
    Offset_res = Offset + Mult * Offset_idx.

// resolve base
resolve_calc([EA, Base, 0, "calc"], Root, Idx, Mult, Offset):-
    value_arithmetic_edge([EA, Base, 0, "calc"], Op1, Op2, Mult, Offset1),
    value_root(Op1, [EA_root, Base_root, Offset_root, "calc"], _),
    value_root(Op2, Idx, _),
    ((Idx = [EA_idx, Base_idx, Offset_idx, Type_idx],
    EA_idx=EA_idx, Base_idx=Base_idx, Offset_idx=Offset_idx,
    Type_idx != "calc", Type_idx != "mem_calc");
    Idx = nil),
    resolve_calc_helper([EA_root, Base_root, Offset_root, "calc"], Root, nil, 1, Offset2),
    EA!=EA_root,
    Offset=Offset1+Offset2.

// resolve both
resolve_calc([EA, Base, 0, "calc"], Root, Idx, Mult_res, Offset_res):-
    value_arithmetic_edge([EA, Base, 0, "calc"], Op1, Op2, Mult, Offset1),
    value_root(Op1, [EA_root, Base_root, Offset_root, "calc"], _),
    value_root(Op2, [EA_idx, Base_idx, Offset_idx, "calc"], _),
    resolve_calc_helper([EA_root, Base_root, Offset_root, "calc"], Root, nil, 1, Offset2),
    resolve_calc_helper([EA_idx, Base_idx, Offset_idx, "calc"], nil, Idx, Mult_idx, Offset3),
    EA!=EA_root,
    EA!=EA_idx,
    Mult_res = Mult * Mult_idx,
    Offset=Offset1+Offset2,
    Offset_res = Offset + Mult * Offset3.