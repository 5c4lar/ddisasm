#include "input.dl"
#include "def_used.dl"
#include "expression.dl"
#include "op_to_val.dl"
#include "value_type.dl"
#include "depend.dl"
// #include "loop_detect.dl"
// #include "object.dl"
// #include "point_to.dl"
// #include "resolve_calc.dl"
// #include "value_root.dl"


///////////////////////////////////////////////////////////////////////////////
.type field_desc = [Prev: field_desc, Offset: unsigned, Type: type_desc]
.type type_desc  = Basic   {Size: unsigned, Type: symbol}
                 | Array   {Size: unsigned, Unit: type_desc}
                 | Pointer {Size: unsigned, Pointee: expression}
                 | Struct  {Size: unsigned, Fields: field_desc}
                 | Union   {Size: unsigned, Fields: field_desc}
                 | Empty_type   {}

.type value_desc = Register {EA:address, Reg:symbol, Idx:unsigned, Type:symbol, Direction:symbol}
                 | Memory {EA:address, Base:symbol, Idx:symbol, Mult:number, Offset:number, Direction:symbol}
                 | Global {EA:address, Address:address, Idx:symbol, Mult:number, Direction:symbol}
                 | Immediate {EA:address, Value:number, Type:symbol}
                 | Empty_val {}

.type value_loc  = RegisterLoc {Reg:symbol}
                 | MemoryLoc {Base:symbol, Idx:symbol, Mult:number, Offset:number}
                 | GlobalLoc {Address:address, Idx:symbol, Mult:number}

.type expression = Number {x: number}
                 | Address {x: address}
                 | Symbolic {x: address, y: symbol}
                 | Symbolized{x: src_desc}
                //  | Calc {Base: value_desc, Idx: value_desc, Mult: number, Offset: number}
                //  | Mem {Src1: value_desc, Src2: value_desc, Mult: number, Offset: number}
                 | Add {e_1: expression, e_2: expression}
                 | Sub {e_1: expression, e_2: expression}
                 | Mult {e_1: expression, e_2: expression}

.type depend     = Leaf {EA: address}
                 | Node {EA: address, height:unsigned, left: depend, right: depend}

.type src_desc = [EA:address, Src1:address, Src2:address]

.decl value_def(Val: value_desc)
.output value_def
.decl value_used(Val: value_desc)
.output value_used
.decl value_block_last_def(EA:address, Val:value_desc)
.output value_block_last_def
.decl value_last_def(Block:address, Val:value_desc)
.output value_last_def
// value def_used intraprocedural
.decl value_def_used(Def:value_desc, Used:value_desc, Type:symbol)
.output value_def_used
// detect function args
.decl function_reg_arg(EA_call:address, Callee:address, Arg:value_desc)
.output function_reg_arg
.decl arg_value(EA_call:address, Function:symbol, Idx:unsigned, Arg:value_desc, Val:expression)
.output arg_value
.decl value_edge(Src:value_desc, Dst:value_desc, Type:symbol)
.output value_edge
.decl value_arithmetic_edge(Dst: value_desc, Op1: value_desc, Op2:value_desc, Mult:number, Offset:number)
.output value_arithmetic_edge
.decl address_expr(Val:value_desc, Exp:expression)
.output address_expr
.decl address_expr_simplified(Val:value_desc, Exp:expression)
.output address_expr_simplified
.decl op_to_val(EA:address, Op:operand_code, Idx:unsigned, Direction:symbol, Type:symbol, Val:value_desc)
.output op_to_val
.decl evaluate_val(Val:value_desc, Exp:expression, From:src_desc, Depend:depend, Type:symbol, Reason:symbol) //choice-domain (Val, From)
.output evaluate_val
.decl value_depend(Val:value_desc, Src: src_desc, Depend:depend) choice-domain (Val, Src)
.output value_depend
.decl ptr_candidate(EA:address)
.output ptr_candidate
.decl to_simplify(Exp:expression)
.output to_simplify
.decl simplify_exp(Exp:expression, Res:expression)
.output simplify_exp
.decl value_used_for_address(Mem:value_desc, Offset:number, Size:unsigned, Direction:symbol, Address: expression)
.output value_used_for_address
.decl value_type(Address:expression, Offset:number, Type:type_desc)
.output value_type
// .decl value_must_def(Val:value_desc)
// loc defined intra
// .decl loc_defined_in_block(EA:address, Loc: loc_desc)
// .output loc_defined_in_block
// def at block level
// .decl loc_defined_in(Block:address, Loc: loc_desc)
// .output loc_defined_in
// .decl value_used_in_block(Block:address, Val:value_desc)

// .decl value_last_def(Block:address, Val:value_desc)
// .output value_last_def

// value def_used intraprocedural
// .decl value_def_used(Def:value_desc, Used:value_desc, Type:symbol)
// .output value_def_used

// .decl def_usable_type(Type:symbol, Type1:symbol)
// .decl defined_value(Val:value_desc)
// .decl used_value(Val:value_desc)
// edges connecting values


// .decl value_arithmetic_operation(EA:address, Dst:value_desc, Op1:value_desc, Op2:value_desc, Mult:number, Offset:number)
// .output value_arithmetic_operation
// calculate relative addresses, Dst = Op1 + Op2 * Mult + Offset
// .decl value_arithmetic_edge(Dst: value_desc, Op1: value_desc, Op2:value_desc, Mult:number, Offset:number)
// .output value_arithmetic_edge

// .decl resolve_calc_helper(Calc: value_desc, Src: value_desc, Idx:value_desc, Mult:number, Offset:number)
// .decl resolve_calc(Calc: value_desc, Src: value_desc, Idx:value_desc, Mult:number, Offset:number)
// .output resolve_calc

// where values are from
// .decl value_src(Src: value_desc, Ref: address, From:symbol)
// .output value_src
// where values are used as a pointer
// .decl value_sink(Sink: value_desc)
// .output value_sink

// edges from value to source
// .decl value_root_helper(Val: value_desc, Root: value_desc, Type:symbol)
// .decl value_root(Val: value_desc, Root: value_desc, Type:symbol)
// .output value_root

// locate sources for addresses, i.e. pointers.
// .decl src_for_address(Src: value_desc)
// .decl not_for_address(Val:value_desc)
// .output src_for_address
// Mem is accessed with Size and source of the base pointer is Base_value
// .decl value_used_for_address(Mem:value_desc, Size:unsigned, Direction:symbol, Base_value: value_desc)
// .output value_used_for_address

// .decl value_type_helper(Location:value_desc, Type:symbol)
// .output value_type_helper
// value_type of Location, "ptr" or "data"
// .decl value_type(Location:value_desc, Type:symbol)
// .output value_type
// value at Base[Offset] is pointing to Target 
// .decl point_to(Base: value_desc, Offset:number, Target: value_desc, Idx: value_desc, Mult:number, Target_offset:number)
// .output point_to

// detect loop for array recongnition
// .decl loop_detected(Start:number, End:number, Steps:number, Counter:value_desc)
// .output loop_detected

.decl function_prototype(Name:symbol, Idx:unsigned, Type:symbol)
.input function_prototype
.decl arg_idx(Reg:symbol, Idx: unsigned)
arg_idx("RDI", 1).
arg_idx("RSI", 2).
arg_idx("RDX", 3).
arg_idx("RCX", 4).
arg_idx("R8", 5).
arg_idx("R9", 6).
.decl reg_size(Reg:symbol, Size:unsigned)
reg_size("AL", 1).
reg_size("AX", 2).
reg_size("EAX",4).
reg_size("RAX",8).

reg_size("BL", 1).
reg_size("BX", 2).
reg_size("EBX",4).
reg_size("RBX",8).

reg_size("CL", 1).
reg_size("CX", 2).
reg_size("ECX",4).
reg_size("RCX",8).

reg_size("DL", 1).
reg_size("DX", 2).
reg_size("EDX",4).
reg_size("RDX",8).

reg_size("DI", 1).
reg_size("DIL", 2).
reg_size("EDI",4).
reg_size("RDI",8).

reg_size("SI", 1).
reg_size("SIL", 2).
reg_size("ESI",4).
reg_size("RSI",8).

reg_size("BP",1).
reg_size("BPL",2).
reg_size("EBP",4).
reg_size("RBP",8).

// track register for variable analysis
reg_size("SP",1).
reg_size("SPL",2).
reg_size("ESP",4).
reg_size("RSP",8).

reg_size("R8",8).
reg_size("R8D",4).
reg_size("R8W",2).
reg_size("R8B",1).

reg_size("R9",8).
reg_size("R9D",4).
reg_size("R9W",2).
reg_size("R9B",1).

reg_size("R10",8).
reg_size("R10D",4).
reg_size("R10W",2).
reg_size("R10B",1).

reg_size("R11",8).
reg_size("R11D",4).
reg_size("R11W",2).
reg_size("R11B",1).

reg_size("R12",8).
reg_size("R12D",4).
reg_size("R12W",2).
reg_size("R12B",1).

reg_size("R13",8).
reg_size("R13D",4).
reg_size("R13W",2).
reg_size("R13B",1).

reg_size("R14",8).
reg_size("R14D",4).
reg_size("R14W",2).
reg_size("R14B",1).

reg_size("R15",8).
reg_size("R15D",4).
reg_size("R15W",2).
reg_size("R15B",1).


// TODO: interprocedural global def used
// TODO: solve adjacent global objects