#include "input.dl"
#include "def_used.dl"
#include "expression.dl"
#include "op_to_val.dl"
#include "loop_detect.dl"
#include "value_type.dl"
// #include "object.dl"
// #include "point_to.dl"
// #include "resolve_calc.dl"
// #include "value_root.dl"


///////////////////////////////////////////////////////////////////////////////

.type type_desc  = Basic   {Size: unsigned, Type: symbol}
                 | Array   {Size: unsigned, Unit: type_desc}
                 | Pointer {Size: unsigned, Pointee: type_desc}
                 | Struct  {Size: unsigned, Prev: type_desc, Offset: unsigned, Type: type_desc}
                 | Union   {Size: unsigned, Prev: type_desc, Type: type_desc}
                 | Empty_type   {}

.type value_desc = Register {EA:address, Reg:symbol, Idx:unsigned, Type:symbol, Direction:symbol}
                 | Memory {EA:address, Base:symbol, Idx:symbol, Mult:number, Offset:number, Direction:symbol}
                 | Global {EA:address, Address:address, Idx:symbol, Mult:number, Direction:symbol}
                 | Immediate {EA:address, Value:number, Type:symbol}
                 | Empty_val {}

.type value_loc  = RegisterLoc {Reg:symbol}
                 | MemoryLoc {Base:symbol, Idx:symbol, Mult:number, Offset:number}
                 | GlobalLoc {Address:address, Idx:symbol, Mult:number}

.type expression = Number {x: number}
                 | Address {x: number}
                 | Symbolic {x: address, y: symbol}
                 | Add {e_1: expression, e_2: expression}
                 | Sub {e_1: expression, e_2: expression}
                 | Mult {e_1: expression, e_2: expression}

.decl value_def(Val: value_desc)
.output value_def
.decl value_used(Val: value_desc)
.output value_used
.decl value_block_last_def(EA:address, Val:value_desc)
.output value_block_last_def
.decl value_last_def(Block:address, Val:value_desc)
.output value_last_def
// value def_used intraprocedural
.decl value_def_used(Def:value_desc, Used:value_desc, Type:symbol)
.output value_def_used
// detect function args
.decl function_reg_arg(EA_call:address, Callee:address, Arg:value_desc)
.output function_reg_arg
.decl value_edge(Src:value_desc, Dst:value_desc, Type:symbol)
.output value_edge
.decl value_arithmetic_edge(Dst: value_desc, Op1: value_desc, Op2:value_desc, Mult:number, Offset:number)
.output value_arithmetic_edge
.decl address_expr(Val:value_desc, Exp:expression)
.output address_expr
.decl address_expr_simplified(Val:value_desc, Exp:expression)
.output address_expr_simplified
.decl op_to_val(EA:address, Op:operand_code, Idx:unsigned, Direction:symbol, Val:value_desc)
.output op_to_val
.decl evaluate_val(Val:value_desc, Exp:expression, From:address, Type:symbol, Reason:symbol)
.output evaluate_val
.decl to_simplify(Exp:expression)
.output to_simplify
.decl simplify_exp(Exp:expression, Res:expression)
.output simplify_exp
.decl counter_candidate(Val:value_desc)
.output counter_candidate
.decl counter_src(Counter:value_desc, Src:value_desc)
.output counter_src
.decl block_after(Block:address, Block_after:address)
.output block_after
.decl loop_entry(Block:address)
.output loop_entry
.decl block_in_loop(Block:address, Block_entry:address, Block_exit:address)
.output block_in_loop
.decl loop_exit(Block:address)
.output loop_exit
.decl loop_detected(Val:value_desc)
.output loop_detected
.decl value_used_for_address(Mem:value_desc, Size:unsigned, Direction:symbol, Address: expression)
.output value_used_for_address
// .decl value_must_def(Val:value_desc)
// loc defined intra
// .decl loc_defined_in_block(EA:address, Loc: loc_desc)
// .output loc_defined_in_block
// def at block level
// .decl loc_defined_in(Block:address, Loc: loc_desc)
// .output loc_defined_in
// .decl value_used_in_block(Block:address, Val:value_desc)

// .decl value_last_def(Block:address, Val:value_desc)
// .output value_last_def

// value def_used intraprocedural
// .decl value_def_used(Def:value_desc, Used:value_desc, Type:symbol)
// .output value_def_used

// .decl def_usable_type(Type:symbol, Type1:symbol)
// .decl defined_value(Val:value_desc)
// .decl used_value(Val:value_desc)
// edges connecting values


// .decl value_arithmetic_operation(EA:address, Dst:value_desc, Op1:value_desc, Op2:value_desc, Mult:number, Offset:number)
// .output value_arithmetic_operation
// calculate relative addresses, Dst = Op1 + Op2 * Mult + Offset
// .decl value_arithmetic_edge(Dst: value_desc, Op1: value_desc, Op2:value_desc, Mult:number, Offset:number)
// .output value_arithmetic_edge

// .decl resolve_calc_helper(Calc: value_desc, Src: value_desc, Idx:value_desc, Mult:number, Offset:number)
// .decl resolve_calc(Calc: value_desc, Src: value_desc, Idx:value_desc, Mult:number, Offset:number)
// .output resolve_calc

// where values are from
// .decl value_src(Src: value_desc, Ref: address, From:symbol)
// .output value_src
// where values are used as a pointer
// .decl value_sink(Sink: value_desc)
// .output value_sink

// edges from value to source
// .decl value_root_helper(Val: value_desc, Root: value_desc, Type:symbol)
// .decl value_root(Val: value_desc, Root: value_desc, Type:symbol)
// .output value_root

// locate sources for addresses, i.e. pointers.
// .decl src_for_address(Src: value_desc)
// .decl not_for_address(Val:value_desc)
// .output src_for_address
// Mem is accessed with Size and source of the base pointer is Base_value
// .decl value_used_for_address(Mem:value_desc, Size:unsigned, Direction:symbol, Base_value: value_desc)
// .output value_used_for_address

// .decl value_type_helper(Location:value_desc, Type:symbol)
// .output value_type_helper
// value_type of Location, "ptr" or "data"
// .decl value_type(Location:value_desc, Type:symbol)
// .output value_type
// value at Base[Offset] is pointing to Target 
// .decl point_to(Base: value_desc, Offset:number, Target: value_desc, Idx: value_desc, Mult:number, Target_offset:number)
// .output point_to

// detect loop for array recongnition
// .decl loop_detected(Start:number, End:number, Steps:number, Counter:value_desc)
// .output loop_detected

.decl function_prototype(Name:symbol, Idx:unsigned, Type:symbol)
.input function_prototype
.decl arg_idx(Reg:symbol, Idx: unsigned)
arg_idx("RDI", 1).
arg_idx("RSI", 2).
arg_idx("RDX", 3).
arg_idx("RCX", 4).
arg_idx("R8", 5).
arg_idx("R9", 6).

// TODO: interprocedural global def used
// TODO: solve adjacent global objects