#include "input.dl"
#include "def_used.dl"
#include "expression.dl"
#include "op_to_val.dl"
#include "value_type.dl"
#include "depend.dl"
// #include "loop_detect.dl"
// #include "object.dl"
// #include "point_to.dl"
// #include "resolve_calc.dl"
// #include "value_root.dl"


///////////////////////////////////////////////////////////////////////////////
.type field_desc = [Prev: field_desc, Offset: unsigned, Type: type_desc]
.type type_desc  = Basic   {Size: unsigned, Type: symbol}
                 | Array   {Size: unsigned, Unit: type_desc}
                 | Pointer {Size: unsigned, Pointee: expression}
                 | Struct  {Size: unsigned, Fields: field_desc}
                 | Union   {Size: unsigned, Fields: field_desc}
                 | Empty_type   {}

.type value_desc = Register {EA:address, Reg:symbol, Idx:unsigned, Type:symbol, Direction:symbol}
                 | Memory {EA:address, Base:symbol, Idx:symbol, Mult:number, Offset:number, Direction:symbol}
                 | Global {EA:address, Address:address, Idx:symbol, Mult:number, Direction:symbol}
                 | Immediate {EA:address, Value:number, Type:symbol}
                 | Empty_val {}

.type value_loc  = RegisterLoc {Reg:symbol}
                 | MemoryLoc {Base:symbol, Idx:symbol, Mult:number, Offset:number}
                 | GlobalLoc {Address:address, Idx:symbol, Mult:number}

.type expression = Number {x: number}
                 | Address {x: address}
                 | Symbolic {x: address, y: symbol}
                 | Add {e_1: expression, e_2: expression}
                 | Sub {e_1: expression, e_2: expression}
                 | Mult {e_1: expression, e_2: expression}

.type depend     = Leaf {EA: address}
                 | Node {EA: address, height:unsigned, left: depend, right: depend}
                 | Load {EA: address, Address:expression, Addr_depend:depend, Depend: depend}

.type src_desc = [EA:address, Src1:address, Src2:address]

.decl value_def(Val: value_desc)
.output value_def
.decl value_used(Val: value_desc)
.output value_used
.decl value_block_last_def(EA:address, Val:value_desc)
.output value_block_last_def
.decl value_last_def(Block:address, Val:value_desc)
.output value_last_def
// value def_used intraprocedural
.decl value_def_used(Def:value_desc, Used:value_desc, Type:symbol)
.output value_def_used
// detect function args
.decl function_reg_arg(EA_call:address, Callee:address, Arg:value_desc)
.output function_reg_arg
.decl arg_value(EA_call:address, Function:symbol, Idx:unsigned, Arg:value_desc, Val:expression)
.output arg_value
.decl value_edge(Src:value_desc, Dst:value_desc, Type:symbol)
.output value_edge
.decl value_arithmetic_edge(Dst: value_desc, Op1: value_desc, Op2:value_desc, Mult:number, Offset:number)
.output value_arithmetic_edge
.decl address_expr(Val:value_desc, Ptr:expression, Exp:expression)
.decl address_expr_simplified(Val:value_desc, Ptr:expression, Exp:expression)
.decl op_to_val(EA:address, Op:operand_code, Idx:unsigned, Direction:symbol, Type:symbol, Val:value_desc)
.output op_to_val
.decl evaluate_val(Val:value_desc, Exp:expression, From:src_desc, Depend:depend, Type:symbol, Reason:symbol) //choice-domain (Val, From)
.output evaluate_val
.decl value_depend(Val:value_desc, Src: src_desc, Depend:depend) choice-domain (Val, Src)
.output value_depend
.decl inferred_call(EA:address, Callee:address, Val:value_desc, Depend:depend, Exp:expression)
.output inferred_call
.decl ptr_candidate(EA:address)
.output ptr_candidate
.decl to_simplify(Exp:expression)
.output to_simplify
.decl simplify_exp(Exp:expression, Res:expression)
.output simplify_exp
.decl value_used_for_address(Mem:value_desc, Offset:number, Size:unsigned, Direction:symbol, Depend:depend, Address: expression)
.output value_used_for_address
.decl value_type(Address:expression, Offset:number, Type:type_desc)
.output value_type

.decl function_prototype(Name:symbol, Idx:unsigned, Type:symbol)
.input function_prototype
.decl arg_idx(Reg:symbol, Idx: unsigned)
arg_idx("RDI", 1).
arg_idx("RSI", 2).
arg_idx("RDX", 3).
arg_idx("RCX", 4).
arg_idx("R8", 5).
arg_idx("R9", 6).
.decl reg_size(Reg:symbol, Size:unsigned)
reg_size("AL", 1).
reg_size("AX", 2).
reg_size("EAX",4).
reg_size("RAX",8).

reg_size("BL", 1).
reg_size("BX", 2).
reg_size("EBX",4).
reg_size("RBX",8).

reg_size("CL", 1).
reg_size("CX", 2).
reg_size("ECX",4).
reg_size("RCX",8).

reg_size("DL", 1).
reg_size("DX", 2).
reg_size("EDX",4).
reg_size("RDX",8).

reg_size("DI", 1).
reg_size("DIL", 2).
reg_size("EDI",4).
reg_size("RDI",8).

reg_size("SI", 1).
reg_size("SIL", 2).
reg_size("ESI",4).
reg_size("RSI",8).

reg_size("BP",1).
reg_size("BPL",2).
reg_size("EBP",4).
reg_size("RBP",8).

// track register for variable analysis
reg_size("SP",1).
reg_size("SPL",2).
reg_size("ESP",4).
reg_size("RSP",8).

reg_size("R8",8).
reg_size("R8D",4).
reg_size("R8W",2).
reg_size("R8B",1).

reg_size("R9",8).
reg_size("R9D",4).
reg_size("R9W",2).
reg_size("R9B",1).

reg_size("R10",8).
reg_size("R10D",4).
reg_size("R10W",2).
reg_size("R10B",1).

reg_size("R11",8).
reg_size("R11D",4).
reg_size("R11W",2).
reg_size("R11B",1).

reg_size("R12",8).
reg_size("R12D",4).
reg_size("R12W",2).
reg_size("R12B",1).

reg_size("R13",8).
reg_size("R13D",4).
reg_size("R13W",2).
reg_size("R13B",1).

reg_size("R14",8).
reg_size("R14D",4).
reg_size("R14W",2).
reg_size("R14B",1).

reg_size("R15",8).
reg_size("R15D",4).
reg_size("R15W",2).
reg_size("R15B",1).
