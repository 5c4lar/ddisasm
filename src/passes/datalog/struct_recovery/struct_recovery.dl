#include "def_used.dl"
#include "input.dl"
#include "object.dl"
#include "point_to.dl"
#include "resolve_calc.dl"
#include "value_root.dl"
#include "value_type.dl"


///////////////////////////////////////////////////

.type type_description = [Offset:number, Size:unsigned, Type:symbol]
.type layout = [Prev:layout, Description:type_description]
.type value_desc = [EA:address, Base:register, Offset:number, Type:symbol]
.type loc_desc = [Base:register, Offset:number, Type:symbol]

.decl local_next(EA:address, EA_next:address)
.decl value_def(Val: value_desc)
// .output value_def
.decl value_used(Val: value_desc)
// .output value_used
.decl value_must_def(Val:value_desc)
// loc defined intra
.decl loc_defined_in_block(EA:address, Loc: loc_desc)
// .output loc_defined_in_block
// def at block level
.decl loc_defined_in(Block:address, Loc: loc_desc)
// .output loc_defined_in
.decl value_used_in_block(Block:address, Val:value_desc)
.decl value_block_last_def(EA:address, Val:value_desc)
// .output value_block_last_def
.decl value_last_def(Block:address, Val:value_desc)
// .output value_last_def

// value def_used intraprocedural
.decl value_def_used(Def:value_desc, Used:value_desc, Type:symbol)
.output value_def_used

.decl def_usable_type(Type:symbol, Type1:symbol)
.decl defined_value(Val:value_desc)
.decl used_value(Val:value_desc)
// edges connecting values
.decl value_edge(Src:value_desc, Dst:value_desc, Type:symbol)
// .output value_edge

.decl value_arithmetic_operation(EA:address, Dst:value_desc, Op1:value_desc, Op2:value_desc, Mult:number, Offset:number)
// .output value_arithmetic_operation
// calculate relative addresses, Dst = Op1 + Op2 * Mult + Offset
.decl value_arithmetic_edge(Dst: value_desc, Op1: value_desc, Op2:value_desc, Mult:number, Offset:number)
// .output value_arithmetic_edge

.decl resolve_calc_helper(Calc: value_desc, Src: value_desc, Idx:value_desc, Mult:number, Offset:number)
.decl resolve_calc(Calc: value_desc, Src: value_desc, Idx:value_desc, Mult:number, Offset:number)
.output resolve_calc

// where values are from
.decl value_src(Src: value_desc, Ref: address, From:symbol)
.output value_src
// edges from value to source
.decl value_root_helper(Val: value_desc, Root: value_desc, Type:symbol)
.decl value_root(Val: value_desc, Root: value_desc, Type:symbol)
.output value_root

// locate sources for addresses, i.e. pointers.
.decl src_for_address(Src: value_desc)
.decl not_for_address(Val:value_desc)
.output src_for_address
// Mem is accessed with Size and source of the base pointer is Base_value
.decl value_used_for_address(Mem:value_desc, Size:unsigned, Direction:symbol, Base_value: value_desc)
.output value_used_for_address

.decl value_type_helper(Location:value_desc, Type:symbol)
// .output value_type_helper
// value_type of Location, "ptr" or "data"
.decl value_type(Location:value_desc, Type:symbol)
.output value_type
// value at Base[Offset] is pointing to Target 
.decl point_to(Base: value_desc, Offset:number, Target: value_desc, Idx: value_desc, Mult:number, Target_offset:number)
.output point_to
.decl array_desc(Base:value_desc, Offset:number, Unit:layout, Len:number, Unit_size:number)
.output array_desc

// Combine all access pattern originate from the pointer Src
.decl pattern_tape(Src: value_desc, Idx: value_desc, Mult:number, Offset: number, Type: layout)
.output pattern_tape
.decl access_handle(Src:value_desc, Idx: value_desc, Mult:number, Offset: number, Handle:value_desc)
// .output access_handle
// Merge pattern defined for the same object
.decl merged_tape(Src: value_desc, Idx: value_desc, Mult:number, Offset: number, Type: layout, Last_elem:number)
.output merged_tape
// Select the best object candidate from merged_tape.
.decl object_candidate_helper(Src:value_desc, Idx: value_desc, Mult:number, Offset:number, Type: layout, Max_offset:number)
// .output object_candidate_helper
.decl object_candidate(Src:value_desc, Idx: value_desc, Mult:number, Offset: number, Type: layout)
.output object_candidate

// detect loop for array recongnition
.decl loop_detected(Start:number, End:number, Steps:number, Counter:value_desc)
.output loop_detected
// detect function args
.decl function_reg_arg(Caller:address, Callee:address, Arg:value_desc)
.output function_reg_arg

.decl function_prototype(Name:symbol, Idx:unsigned, Type:symbol)
.input function_prototype
.decl arg_idx(Reg:symbol, Idx: unsigned)
arg_idx("RDI", 1).
arg_idx("RSI", 2).
arg_idx("RDX", 3).
arg_idx("RCX", 4).
arg_idx("R8", 5).
arg_idx("R9", 6).

// TODO: interprocedural global def used
// TODO: solve adjacent global objects