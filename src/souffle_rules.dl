.symbol_type register

.number_type address
.number_type operand_code
/////////////////////////////////////////////////////////////
// Inputs generated by the decoder
/////////////////////////////////////////////////////////////

// metadata
.decl entry_point(ea:address)
.input entry_point

.decl symbol(ea:address,n:number,type:symbol,scope:symbol,name:symbol)
.input symbol

.decl section(name:symbol,size:number,addr:address)
.input section

.decl relocation(ea:address,name:symbol,addend:number)
.input relocation

.decl word_size_in_bytes(n:number)
word_size_in_bytes(8).


//FIXME: add eh_frames


.decl instruction(ea:address, size:number, opcode:symbol,
		  op1:operand_code, op2:operand_code, op3:operand_code)
.input instruction

.decl invalid_op_code(ea:address)
.input invalid_op_code

// three kinds of operators
.decl op_regdirect(code:operand_code,register_name:register)
.input op_regdirect

.decl op_immediate(code:operand_code,offset:number)
.input op_immediate

.decl op_indirect(code:operand_code,reg1:register, reg2:register, reg3:register,
		multiplier:number, offset:number, noidea:number, size_value:number)
.input op_indirect

//data from data sections

.decl data_byte(ea:address,value:number)
.input data_byte

.decl address_in_data(ea:address,value:number)

.input address_in_data


/////////////////////////////////////////////////////////////
// auxiliary definitions
/////////////////////////////////////////////////////////////

.decl instruction_get_operation(ea:address,operation:symbol) 

instruction_get_operation(EA,Operation):-
	instruction(EA,_,Operation,_,_,_).
	
.decl instruction_get_op(ea:address, index:number, operator:operand_code)

instruction_get_op(EA,Index,Op):-
	instruction(EA,_,_,Op1,Op2,Op3),
	(
	Op1!=0,
	Op=Op1,Index=1
	;
	Op2!=0,
	Op=Op2,Index=2
	;
	Op3!=0,
	Op=Op3,Index=3
	).
	


/////////////////////////////////////////////////////////////
// inference of basic facts
/////////////////////////////////////////////////////////////


.decl next(n:address,m:address)

next(EA,EA+Size):-
	instruction(EA,Size,_,_,_,_).
	
.decl pc_relative_operand(src:address,index:number, dest:address)
.output pc_relative_operand

pc_relative_operand(EA,Index,EA_next+Offset):-
	instruction_get_op(EA, Index, Op),
	op_indirect(Op,"NullSReg","RIP","NullReg64",1,Offset,_,_),
	next(EA,EA_next).
	
	
// JUMPS
.decl inconditional_jump(n:address)

inconditional_jump(EA):-
	instruction_get_operation(EA,"JMP").
	
// direct jumps
.decl direct_jump(src:address, dest:address)
.output direct_jump

direct_jump(EA,Dest):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_immediate(Op1,Dest).


// Special kinds of indirect jumps
// PC relative jumps
.decl pc_relative_jump(src:address, dest:address)
.output pc_relative_jump

pc_relative_jump(EA,Dest):-
	instruction_get_operation(EA,Operation),
	jump_operation(Operation),
	pc_relative_operand(EA,1,Dest).

	
// jump to the address of a register
// for now we do not compute anything about these

// .decl reg_jump(src:address)
// .output reg_jump

// reg_jump(EA):-
// 	instruction(EA,_,Operation,Op1,_,_),
// 	jump_operation(Operation),
// 	op_regdirect(Op1,_).
	


	
// indirect jump	

// .decl indirect_jump(src:address)
// .output indirect_jump

// indirect_jump(EA):-
// 	instruction(EA,_,Operation,Op1,_,_),
// 	jump_operation(Operation),
// 	op_indirect(Op1,_,_,_, _,_,_,_),
// 	!pc_relative_jump(EA,_).


	
// CALLS
// direct calls
.decl direct_call(src:address, dest:address)
.output direct_call

direct_call(EA,Dest):-
	instruction(EA,_,"CALL",Op1,_,_),
	op_immediate(Op1,Dest).


.decl pc_relative_call(src:address,dest:address)
.output pc_relative_call

pc_relative_call(Src,Dest):-
	instruction_get_operation(Src,"CALL"),
	pc_relative_operand(Src,1,Dest).


// for now we do not compute anything about these
//.decl reg_call(src:address)
//.output reg_call

// reg_call(EA):-
// 	instruction(EA,_,"CALL",Op1,_,_),
// 	op_regdirect(Op1,_).




// .decl indirect_call(src:address)
// .output indirect_call

// indirect_call(EA):-
// 	instruction(EA,_,"CALL",Op1,_,_),
// 	op_indirect(Op1,_,_,_,_,_,_,_),
// 	!pc_relative_jump(EA,_).


// Returns
.decl return(n:address)

return(EA):-
	instruction_get_operation(EA,"Ret").


.decl ambiguous_symbol(name:symbol)
.output ambiguous_symbol

ambiguous_symbol(Name):-
        symbol(_,_,_,_,Name),
 	1< count :{symbol(_,_,_,_,Name)}.

// Function symbols
.decl function_symbol(ea:address,name:symbol)
.output function_symbol

function_symbol(EA,Name):-
	symbol(EA,_,"FUNC",_,Name).

	

.decl data_section(name:symbol)

data_section(".rodata").
data_section(".data").
data_section(".bss").

.decl code_section(name:symbol)

code_section(".text").
code_section(".plt").


.decl may_fallthrough(o:address,d:address)

may_fallthrough(From,To):-
	next(From,To),
	!return(From),
	!inconditional_jump(From).
	
.decl must_fallthrough(o:address,d:address)

must_fallthrough(From,To):-
	may_fallthrough(From,To),
	instruction_get_operation(From,"CALL").



.decl basic_target(ea:address)

// FIXME: add exception frame addresses

basic_target(Val):-
	address_in_data(_,Val).

basic_target(EA):-
	entry_point(EA).

basic_target(EA):-
	function_symbol(EA,_).
	
	
/////////////////////////////////////////////////////////////
// We go through several phases of increasing confidence
/////////////////////////////////////////////////////////////

// we define a basic phase propagation
// and we later instantiate it for each phase
.comp traverse_code {

// INPUTS
// these are the initial ea considered
.decl possible_ea(a:address)

// the initial targets to be considered
.decl possible_target(ea:address)

// the block limits to be considered
.decl block_limit(ea:address)


//COMPUTED
// propagate from possible targets forward
.decl likely_ea(ea:address,chunk_head:address)

likely_ea(EA,EA):-
	possible_target(EA),
	possible_ea(EA).
//same block
likely_ea(EA,Head):-
	likely_ea(EA2,Start),
	may_fallthrough(EA2,EA),
	(
	block_limit(EA),
	Head=EA
	;
	!block_limit(EA),
	Head=Start
	),
	possible_ea(EA).


// forbid overlaps with likely_ea instructions
// grow the initial invalid set 
.decl overlap(ea_overlap:address,ea_likely:address)


// Compute EAs that overlap with EAs of likely instuctions
overlap(EA2+1,EA2):-
	likely_ea(EA2,_),
	next(EA2,End),
	EA2+1 < End.
overlap(EA+1,EA2):-
	overlap(EA,EA2),
	next(EA2,End),
	EA+1 < End.

.decl invalid(ea:address)

invalid(EA):-
	invalid_op_code(EA).
invalid(EA):-
	(
	direct_jump(EA,Not_code)
	;
	direct_call(EA,Not_code)
	),
	!possible_ea(Not_code).
	

invalid(EA):-
	possible_ea(EA),
	(
	// the starting point of EA is in the middle of a likely instruction
	overlap(EA,Ini)
	;
	// the ending point of EA is in the middle of a likely instruction
	next(EA,EA_end),
	overlap(EA_end,Ini)
	),
	// (and it is not itself likely)
	!likely_ea(EA,_).

//propagate the invalid instructions backward until ret or jmp (encoded in must_fallthrough)
// propagate through direct jumps and calls

invalid(From):-
	invalid(To),
	(
		must_fallthrough(From,To)
	;
		direct_jump(From,To)
	;
		direct_call(From,To)
	;
		pc_relative_jump(From,To)
	;
		pc_relative_call(From,To)
	).


.decl remaining_ea(ea:address)


remaining_ea(EA):-
	possible_ea(EA),
	!invalid(EA).
}

//.output phase1.invalid
//.output phase1.possible_ea
//.output phase1.remaining_ea

/////////////////////////////
// Phase 1
// Get an initial approximation of things that look like code
/////////////////////////////
.init phase1=traverse_code

phase1.possible_ea(EA):-
	instruction(EA,_,_,_,_,_).
	
phase1.block_limit(EA):-
	op_immediate(_,EA).

phase1.block_limit(EA):-
	pc_relative_jump(_,EA).
	
phase1.block_limit(EA):-
	pc_relative_call(_,EA).

phase1.block_limit(EA):-
	basic_target(EA).	
	
// these are many starting points but maybe not all
phase1.possible_target(EA):-
	phase1.block_limit(EA).

.output phase1.likely_ea
/////////////////////////////
// Phase 2
// In this propagation the possible targets
// are discovered incrementally
/////////////////////////////

.init phase2=traverse_code

phase2.possible_ea(EA):-
	phase1.remaining_ea(EA).	

// we can start traversing the code in two places and end up in the same
// sequence, we want to slit those common sequences apart
// get chunks that don't have common tails

phase2.block_limit(EA):-
	phase1.block_limit(EA).
	
phase2.block_limit(EA):-
	common_tail(EA).


.decl common_tail(ea:address)

common_tail(EA):-
	phase1.likely_ea(EA,Chunk),
	may_fallthrough(From,EA),
	//get the head of the tail only
	!phase1.likely_ea(From,Chunk),
	phase1.likely_ea(From,Chunk2),
	Chunk2!=Chunk.
//////////////////////////////////////////	
// This makes the possible target and likely_ea recursive with one athother

.decl possible_target_from(dest:address,src:address)

possible_target_from(Dest,Src):-
	phase2.likely_ea(Src,_),
	instruction_get_op(Src,_,Op),
	op_immediate(Op,Dest).

possible_target_from(Dest,Src):-
	phase2.likely_ea(Src,_),
	pc_relative_jump(Src,Dest).
	
possible_target_from(Dest,Src):-
	phase2.likely_ea(Src,_),
	pc_relative_call(Src,Dest).


phase2.possible_target(EA):-
	basic_target(EA).

phase2.possible_target(EA):-
	possible_target_from(EA,_).


//.output phase2.possible_target
//.output phase2.likely_ea
.output phase2.remaining_ea

////////////////////////////////////////////////////////////////////////
// Even at this point we can have chunks of code that overlap

.decl chunk_start(ea_chunk:address)
.output chunk_start

//special node for function calls
chunk_start(0).
chunk_start(EA):-phase2.likely_ea(_,EA).




.decl chunk_overlap(ea:address,ea2:address)
//.output chunk_overlap

chunk_overlap(EA_chunk,EA_chunk2):-
	phase2.likely_ea(EA,EA_chunk),
	phase2.overlap(EA,EA2),
	phase2.likely_ea(EA2,EA_chunk2).
	
//////////////////////////////////////////////////////////////////////
// We need to solve the chunk overlaps
// we do it with heuristics
///

.decl discarded_chunk(ea_chunk:address)
.output discarded_chunk

discarded_chunk(Chunk):-
	(
	chunk_overlap(Chunk,Chunk2)
	;
	chunk_overlap(Chunk2,Chunk)
	),
	//heuristic: one is a externally defined function
	function_symbol(Chunk2,_),
	!function_symbol(Chunk,_).

discarded_chunk(Chunk):-
	(
	chunk_overlap(Chunk,Chunk2)
	;
	chunk_overlap(Chunk2,Chunk)
	),
	//heuristic: keep the one that has more predecessors
	// but we value different kinds of predecessors differently
	Chunk_pred= sum X:{chunk_pred(Chunk,_,X)},
	Chunk2_pred= sum X:{chunk_pred(Chunk2,_,X)},
	Chunk2_pred>Chunk_pred.
	
.decl chunk_pred(chunk:address,predecessor:address,importance:number)

chunk_pred(Chunk,0,1):-
	basic_target(Chunk).
	
chunk_pred(Chunk,Chunk_pred,3):-
	direct_jump(EA,Chunk),
	phase2.likely_ea(EA,Chunk_pred),
	Chunk_pred!=Chunk.

chunk_pred(Chunk,Chunk_pred,3):-
	may_fallthrough(EA,Chunk),
	phase2.likely_ea(EA,Chunk_pred).
	
chunk_pred(Chunk,Chunk_pred,1):-
	possible_target_from(Chunk,EA),
	!direct_jump(EA,Chunk),
	phase2.likely_ea(EA,Chunk_pred),
	Chunk_pred!=Chunk.
	
	
.decl chunk_overlap2(ea:address,ea2:address)
.output chunk_overlap2

chunk_overlap2(Chunk,Chunk2):-
	chunk_overlap(Chunk,Chunk2),
	!discarded_chunk(Chunk),
	!discarded_chunk(Chunk2).

.decl likely_ea_final(ea:address,chunk:address)
.output likely_ea_final

likely_ea_final(EA,Chunk):-
	phase2.likely_ea(EA,Chunk),
	!discarded_chunk(Chunk).


////////////////////////////////////////////////////////////////////////////
// detect references  to libraries (calls to plt)
.decl plt_reference(ea:address, function:symbol)
.output plt_reference

plt_reference(EA,Function):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,1,Op),
	op_immediate(Op,Dest),
	section(".plt",Size,Beg),
	Dest<Beg+Size,
	Dest>=Beg,
	pc_relative_jump(Dest,Got_entry),
	relocation(Got_entry,Function,_).

plt_reference(EA,Function):-
	symbolic_data(EA,Dest),
	section(".plt",Size,Beg),
	Dest<Beg+Size,
	Dest>=Beg,
	pc_relative_jump(Dest,Got_entry),
	relocation(Got_entry,Function,_).
	
//////////////////////////////////////////////////////////////////////
// Symbolization
//////////////////////////////////////////////////////////////////////

.decl symbolic_operand_candidate(ea:address,operand_index:number,dest:address)

symbolic_operand_candidate(EA,Op_index,Dest):-
	likely_ea_final(EA,_),
	instruction_get_op(EA,Op_index,Op),
	(
		op_immediate(Op,Dest)
	;
		pc_relative_operand(EA,Op_index,Dest)
	;
// FIXME: here we do not compute the real destination but the base address
   	       op_indirect(Op,_,_,_,_,Dest,_,_)
	),
	(
		likely_ea_final(Dest,_)
	;
		data_section(Name),
		section(Name,SizeSect,Base),
		Dest>=Base,
		Dest<Base+SizeSect
	).
		

.decl symbolic_operand(ea:address,operand_index:number)
.output symbolic_operand

//FIXME maybe we have to refine this
symbolic_operand(EA,Op_index):-
	symbolic_operand_candidate(EA,Op_index,_).


// data that is dereferenced somewhere in the code
.decl labeled_data(EA:address)
.output labeled_data

labeled_data(EA):-
	symbolic_operand_candidate(_,_,EA),
	data_byte(EA,_).

labeled_data(Val):-
	address_in_data(_,Val),
	data_byte(Val,_).
	
	
// labels of un-initialized data
.decl bss_data(EA:address)
.output bss_data

bss_data(EA):-
	(
	symbolic_operand_candidate(_,_,EA)
	;
	symbolic_data(_,EA)
	),
	section(".bss",SizeSect,Base),
	EA>=Base,
	EA<Base+SizeSect.


.decl symbolic_data(ea:address,value:number)
.output symbolic_data



.decl address_in_data2(EA:address,Val:number)

address_in_data2(EA,Val):-
      address_in_data(EA,Val),
      data_section(Name),
      section(Name,Size,Beg),
      Val>=Beg,
      Val<Size+Beg.
      
address_in_data2(EA,Val):-
      address_in_data(EA,Val),
      likely_ea_final(_,Val).

symbolic_data(EA,Val):-
 	address_in_data2(EA,Val),
 	!labeled_data(EA+1),
	!labeled_data(EA+2),
	!labeled_data(EA+3),
	!labeled_data(EA+4),
	!labeled_data(EA+5),
	!labeled_data(EA+6),
	!labeled_data(EA+7).

// type classification heuristics
.decl float_data(ea:address)
.output float_data

float_data(EA):-
	labeled_data(EA),
	symbolic_operand_candidate(Ref,_,EA),
	float_instruction(Ref).

.decl float_instruction(ea:address)

float_instruction(EA):-
	instruction_get_operation(EA,Operation),
	float_operation(Operation).


	
.decl string(ea:address,end:address)
.output string

string(Beg,End+1):-
	data_byte(End,0),
	string_candidate(End-1,Beg),
	!labeled_data(End).

   

.decl string_candidate(ea:address,base:address)

string_candidate(EA,EA):-
    labeled_data(EA),
    !float_data(EA),
    !symbolic_data(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).

string_candidate(EA+1,Base):-
   string_candidate(EA,Base),
   !labeled_data(EA+1),
   data_byte(EA+1,Byte),
   printable_char(Byte).
    

.decl main_function(ea:address)
.output main_function

//main_function(EA):-
//	function_symbol(EA,"main").
	
main_function(Main_location):-
	!function_symbol(Main_location,"main"),
	First_call= min EA:{
		    entry_point(Entry),
		    direct_call(EA,_),
		    likely_ea_final(EA,_),
		    EA>=Entry
		    	},
	next(Prev,First_call),
        likely_ea_final(Prev,_),
	symbolic_operand_candidate(Prev,1,Main_location).


	
    
.decl jump_operation(n:symbol)

jump_operation("JCXZ").
jump_operation("JECXZ").
jump_operation("JRCXZ").
jump_operation("JO").
jump_operation("JNO").
jump_operation("JB").
jump_operation("JNB").
jump_operation("JZ").
jump_operation("JNZ").
jump_operation("JNA").	
jump_operation("JA").
jump_operation("JS").
jump_operation("JNS").
jump_operation("JP").
jump_operation("JNP").
jump_operation("JL").
jump_operation("JGE").
jump_operation("JLE").
jump_operation("JG").
jump_operation("JC").
jump_operation("JAE").
jump_operation("JE").
jump_operation("JNE").
jump_operation("JBE").
jump_operation("JNBE").
jump_operation("JMP").

.decl printable_char(n:number)

printable_char(0x9).
printable_char(0xA).
printable_char(0xC).
printable_char(0xD).

printable_char(0x20).
printable_char(0x21).
printable_char(0x22).
printable_char(0x23).
printable_char(0x24).
printable_char(0x25).
printable_char(0x26).
printable_char(0x27).
printable_char(0x28).
printable_char(0x29).
printable_char(0x2A).
printable_char(0x2B).
printable_char(0x2C).
printable_char(0x2D).
printable_char(0x2E).
printable_char(0x2F).
printable_char(0x30).
printable_char(0x31).
printable_char(0x32).
printable_char(0x33).
printable_char(0x34).
printable_char(0x35).
printable_char(0x36).
printable_char(0x37).
printable_char(0x38).
printable_char(0x39).
printable_char(0x3A).
printable_char(0x3B).
printable_char(0x3C).
printable_char(0x3D).
printable_char(0x3E).
printable_char(0x3F).
printable_char(0x40).
printable_char(0x41).
printable_char(0x42).
printable_char(0x43).
printable_char(0x44).
printable_char(0x45).
printable_char(0x46).
printable_char(0x47).
printable_char(0x48).
printable_char(0x49).
printable_char(0x4A).
printable_char(0x4B).
printable_char(0x4C).
printable_char(0x4D).
printable_char(0x4E).
printable_char(0x4F).
printable_char(0x50).
printable_char(0x51).
printable_char(0x52).
printable_char(0x53).
printable_char(0x54).
printable_char(0x55).
printable_char(0x56).
printable_char(0x57).
printable_char(0x58).
printable_char(0x59).
printable_char(0x5A).
printable_char(0x5B).
printable_char(0x5C).
printable_char(0x5D).
printable_char(0x5E).
printable_char(0x5F).
printable_char(0x60).
printable_char(0x61).
printable_char(0x62).
printable_char(0x63).
printable_char(0x64).
printable_char(0x65).
printable_char(0x66).
printable_char(0x67).
printable_char(0x68).
printable_char(0x69).
printable_char(0x6A).
printable_char(0x6B).
printable_char(0x6C).
printable_char(0x6D).
printable_char(0x6E).
printable_char(0x6F).
printable_char(0x70).
printable_char(0x71).
printable_char(0x72).
printable_char(0x73).
printable_char(0x74).
printable_char(0x75).
printable_char(0x76).
printable_char(0x77).
printable_char(0x78).
printable_char(0x79).
printable_char(0x7A).
printable_char(0x7B).
printable_char(0x7C).
printable_char(0x7D).
printable_char(0x7E).

.decl float_operation(operation:symbol)


float_operation("MOVSS").
float_operation("MOVSD").
// am I missing more?
float_operation("MOVSD2").

float_operation("MOVUPS").
float_operation("MOVUPD").
float_operation("MOVAPS").
float_operation("MOVAPD").

float_operation("ADDSS").
float_operation("ADDSD").
float_operation("ADDPS").
float_operation("ADDPD").

float_operation("SUBSS").
float_operation("SUBSD").
float_operation("SUBPS").
float_operation("SUBPD").

float_operation("MULSS").
float_operation("MULSD").
float_operation("MULPS").
float_operation("MULPD").

float_operation("DIVSS").
float_operation("DIVSD").
float_operation("DIVPS").
float_operation("DIVPD").

float_operation("MINSS").
float_operation("MINSD").
float_operation("MINPS").
float_operation("MINPD").

float_operation("MAXSS").
float_operation("MAXSD").
float_operation("MAXPS").
float_operation("MAXPD").


float_operation("ROUNDSS").
float_operation("ROUNDSD").
float_operation("ROUNDPS").
float_operation("ROUNDPD").

float_operation("SQRTSS").
float_operation("SQRTSD").
float_operation("SQRTPS").
float_operation("SQRTPD").

