.symbol_type reg

.number_type address
.number_type op_code
/////////////////////////////////////////////////////////////
// Inputs generated by the decoder
/////////////////////////////////////////////////////////////
.decl symbol(ea:address,n:number,type:symbol,scope:symbol,name:symbol)
.input symbol

.decl section(name:symbol,n:number,addr:address)
.input section


.decl instruction(ea:address,size:number,opcode:symbol,op1:op_code,op2:op_code,op3:op_code)
.input instruction

.decl invalid(n:address)
.input invalid

// three kinds of operators
.decl op_regdirect(code:op_code,reg:reg)
.input op_regdirect

.decl op_immediate(code:op_code,num:number)
.input op_immediate

.decl op_indirect(code:op_code,reg1:reg,reg2:reg,reg3:reg,multiplier:number,offset:number,noidea:number)
.input op_indirect

//data from data sections
.decl static_data(ea:address,value:number)
.input static_data


/////////////////////////////////////////////////////////////
// inference of basic facts
/////////////////////////////////////////////////////////////
	
.decl next(n:address,m:address)

next(EA,EA+Size):-
	instruction(EA,Size,_,_,_,_).
	

.decl jump_operation(n:symbol)

jump_operation("JCXZ").
jump_operation("JECXZ").
jump_operation("JRCXZ").
jump_operation("JO").
jump_operation("JNO").
jump_operation("JB").
jump_operation("JNB").
jump_operation("JZ").
jump_operation("JNZ").
jump_operation("JNA").	
jump_operation("JA").
jump_operation("JS").
jump_operation("JNS").
jump_operation("JP").
jump_operation("JNP").
jump_operation("JL").
jump_operation("JGE").
jump_operation("JLE").
jump_operation("JG").
jump_operation("JC").
jump_operation("JAE").
jump_operation("JE").
jump_operation("JNE").
jump_operation("JBE").
jump_operation("JNBE").	

	
// JUMPS
.decl inconditional_jump(n:address)

inconditional_jump(EA):-
	instruction(EA,_,"JMP",_,_,_).	
	
// direct jumps
.decl direct_jump(n:address,m:address)
.output direct_jump

direct_jump(EA,Dest):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_immediate(Op1,Dest).

// jump to the address of a register
// for now we do not compute anything about these
.decl reg_jump(n:address)
.output reg_jump

reg_jump(EA):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_regdirect(Op1,_).
	
// indirect jump	
.decl indirect_jump(n:address)
.output indirect_jump

indirect_jump(EA):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_indirect(Op1,_,_,_, _,_,_),
	!pc_relative_jump(EA,_).

// Special kinds of indirect jumps
// PC relative jumps
.decl pc_relative_jump(n:address,m:address)
.output pc_relative_jump

pc_relative_jump(EA,EA+Offset):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_indirect(Op1,"NullSReg","RIP","NullReg64",1,Offset,_).
	

// CALLS
// direct calls
.decl direct_call(n:address,m:address)
.output direct_call

direct_call(EA,Dest):-
	instruction(EA,_,"CALL",Op1,_,_),
	op_immediate(Op1,Dest).

// for now we do not compute anything about these
.decl reg_call(n:address)
.output reg_call

reg_call(EA):-
	instruction(EA,_,"CALL",Op1,_,_),
	op_regdirect(Op1,_).

.decl indirect_call(n:address)
.output indirect_call

indirect_call(EA):-
	instruction(EA,_,"CALL",Op1,_,_),
	op_indirect(Op1,_,_,_,_,_,_).


// Returns
.decl return(n:address)

return(EA):-
	instruction(EA,_,"Ret",_,_,_).

// Function symbols
.decl function_symbol(ea:address,name:symbol)
.output function_symbol

function_symbol(EA,Name):-
	symbol(EA,_,"FUNC",_,Name).


.decl fallthrough(o:address,d:address)

fallthrough(From,To):-
	next(From,To),
	!return(From),
	!inconditional_jump(From).
	
/////////////////////////////////////////////////////////////
// We go through several phases of increasing confidence
/////////////////////////////////////////////////////////////

// we define a basic phase propagation
// and we later instantiate it for each phase
.comp phase {
// this has to be defined in each phase
.decl possible_ea(a:address)

// to be completed in each phase
.decl possible_target(ea:address)

possible_target(Val):-
	static_data(_,Val).

possible_target(EA):-
	section(".text",_,EA).

possible_target(EA):-
	function_symbol(EA,_).

// propagate from possible targets forward
.decl likely_ea(n:address,start:address)

likely_ea(EA,EA):-
	possible_target(EA),
	possible_ea(EA).

likely_ea(EA,Start):-
	likely_ea(EA2,Start),
	fallthrough(EA2,EA),
	!possible_target(EA),
	possible_ea(EA).
	
}

/////////////////////////////
// Phase 1
// Get an initial approximation of things that look like code
/////////////////////////////
.init phase1=phase

phase1.possible_ea(EA):-
	instruction(EA,_,_,_,_,_).
	

phase1.possible_target(Val):-
	op_immediate(_,Val).
	
/////////////////////////////
// Second part 
// we have an initial approximation of things that look like
// code.
// Now we discard overlaping instructions not likely to be code.
// we are pretty sure  those are not code
/////////////////////////////


// forbid overlaps with phase1.likely_ea instructions
// grow the initial invalid set 
.decl overlap(ea_overlap:address,ea_likely:address)


// Compute EAs that overlap with EAs of likely instuctions
overlap(EA2+1,EA2):-
	phase1.likely_ea(EA2,_),
	next(EA2,End),
	EA2+1 < End.
overlap(EA+1,EA2):-
	overlap(EA,EA2),
	next(EA2,End),
	EA+1 < End.

// the starting point of EA is in the middle of a likely instruction
// (and it is not itself likely)
invalid(EA):- 
	phase1.likely_ea(Ini,_),
	overlap(EA,Ini),
	phase1.possible_ea(EA),
	!phase1.likely_ea(EA,_).

// the ending point of EA is in the middle of a likely instruction
// (and it not iself likely)
invalid(EA):- 
	phase1.likely_ea(Ini,_),
	overlap(EA_f,Ini),
	next(EA,EA_f),
	phase1.possible_ea(EA),
	!phase1.likely_ea(EA,_).	
	

//propagate the invalid instructions backward until ret or jmp (encoded in fallthrough)
// propagate through direct jumps and calls weakly 

.decl invalid_transitive(n:address)
//.output invalid_transitive(IO=stdout)

invalid_transitive(EA):-invalid(EA).
invalid_transitive(From):-
	invalid_transitive(To),
	(
		fallthrough(From,To)
	;
		direct_jump(From,To),!phase1.likely_ea(From,_)
	;
		direct_call(From,To),!phase1.likely_ea(From,_)
	).
	

/////////////////////////////
// Phase 2
// Repeat the same propagation but with more refined initial relations
/////////////////////////////

.init phase2=phase



phase2.possible_ea(EA):-
	phase1.possible_ea(EA),
	!invalid_transitive(EA).	
// approximation of possible targets

.decl possible_target_from(ea:address,ea2:address)

possible_target_from(Val,Ea):-
	op_immediate(Op,Val),
	(
	instruction(Ea,_,_,Op,_,_)
	;
	instruction(Ea,_,_,_,Op,_)
	;
	instruction(Ea,_,_,_,_,Op)
	),
	phase2.possible_ea(Ea).

phase2.possible_target(Val):-
	possible_target_from(Val,_).
	



////////////////////////////////////////////////////////////////////////
// Phase 3:
// we can start traversing the code in two places and end up in the same
// sequence, we want to slit those common sequences apart
// get chunks that don't have common tails

.decl common_tail(ea:address)


common_tail(EA):-
	phase2.likely_ea(EA,Chunk),
	fallthrough(From,EA),
	//get the head of the tail only
	!phase2.likely_ea(From,Chunk),
	phase2.likely_ea(From,Chunk2),
	Chunk2!=Chunk.

.init phase3=phase

// new propagation where the common tails form new starting points
// for the chunks
phase3.possible_ea(EA):-
	phase2.possible_ea(EA).

// this might be too restrictive
phase3.possible_target(EA):-
	possible_target_from(EA,Origin),
	phase2.likely_ea(Origin,_).

	
phase3.possible_target(EA):-
	common_tail(EA).
	
.output phase3.possible_ea
.output phase3.likely_ea

.decl chunk_start(n:address)
.output chunk_start

//special node for function calls
chunk_start(0).
chunk_start(EA):-phase3.likely_ea(_,EA).




.decl chunk_overlap(ea:address,ea2:address)
.output chunk_overlap

chunk_overlap(EA_chunk,EA_chunk2):-
	phase3.likely_ea(EA,EA_chunk),
	overlap(EA,EA2),
	phase3.likely_ea(EA2,EA_chunk2).
	
//////////////////////////////////////////////////////////////////////
// We need to solve the chunk overlaps
// we do it with heuristics
///

.decl discarded_chunk(ea:address)
.output discarded_chunk

discarded_chunk(Ch):-
	(
	chunk_overlap(Ch,Ch2)
	;
	chunk_overlap(Ch2,Ch)
	),
	//heuristic
	function_symbol(Ch2,_),
	!function_symbol(Ch,_).


.decl chunk_overlap2(ea:address,ea2:address)
.output chunk_overlap2

chunk_overlap2(Ch,Ch2):-
	chunk_overlap(Ch,Ch2),
	!discarded_chunk(Ch),
	!discarded_chunk(Ch2).

// under-approximation
// .decl chunk_succ(Origin:address,Dest:address)
// .output chunk_succ


//  chunk_succ(Origin,0):-
// 	chunk_start(Origin),
// 	function_symbol(Origin,_).
	
//  chunk_succ(Origin,Dest):-
//  	chunk_start(Dest),
//  	//calls, jumps and fallthrough have to go to the beginning of the chunk
//  	// because they define the chunk limits
//  	(
// 	fallthrough(Ea_origin,Dest) 
// 	;
//  	direct_call(EA_origin,Dest)
//  	;
//  	direct_jump(EA_origin,Dest)
//  	),
//  	phase3.likely_ea(EA_origin,Origin),
//  	// we make it non-reflexive
//  	Dest!= Origin.




// .decl loner(n:address)
// .output loner

// loner(Chunk):-
// 	chunk_start(Chunk),
// 	!chunk_succ(_,Chunk).

