.symbol_type name
.symbol_type reg

.number_type address
.number_type op_code
/////////////////////////////////////////////////////////////
// Inputs generated by the decoder
/////////////////////////////////////////////////////////////
.decl symbol(ea:address,n:number,type:symbol,scope:symbol,name:symbol)
.input symbol


.decl instruction(ea:address,size:number,opcode:symbol,op1:op_code,op2:op_code,op3:op_code)
.input instruction

.decl op_regdirect(code:op_code,reg:reg)
.input op_regdirect

.decl op_immediate(code:op_code,num:number)
.input op_immediate

.decl op_indirect(code:op_code,reg1:reg,reg2:reg,reg3:reg,multiplier:number,offset:number,noidea:number)
.input op_indirect

.decl static_data(ea:address,value:number)
.input static_data

.decl invalid(n:address)
.input invalid

/////////////////////////////////////////////////////////////
// inference of basic facts
/////////////////////////////////////////////////////////////
	
.decl next(n:address,m:address)

next(EA,EA+Size):-
	instruction(EA,Size,_,_,_,_).
	

.decl jump_operation(n:symbol)

jump_operation("JMP").
jump_operation("JNZ").
jump_operation("JN").
jump_operation("JGE").
jump_operation("JNA").	
	
// JUMPS
.decl inconditional_jump(n:address)

inconditional_jump(EA):-
	instruction(EA,_,"JMP",_,_,_).	
	
// direct jumps
.decl direct_jump(n:address,m:address)
.output direct_jump

direct_jump(EA,Dest):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_immediate(Op1,Dest).

// computed jump
.decl reg_computed_jump(n:address)
.output reg_computed_jump

reg_computed_jump(EA):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_regdirect(Op1,_).
	
.decl indirect_computed_jump(n:address)
.output indirect_computed_jump

indirect_computed_jump(EA):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_indirect(Op1,_,_,_, _,_,_),
	!pc_relative_jump(EA,_).

// PC relative jumps
.decl pc_relative_jump(n:address,m:address)
.output pc_relative_jump

pc_relative_jump(EA,EA+Offset):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_indirect(Op1,"NullSReg","RIP","NullReg64",1,Offset,_).

// CALLS
// direct calls
.decl direct_call(n:address,m:address)
.output direct_call

direct_call(EA,Dest):-
	instruction(EA,_,"CALL",Op1,_,_),
	op_immediate(Op1,Dest).


// Returns
.decl return(n:address)

return(EA):-
	instruction(EA,_,"Ret",_,_,_).

// Function symbols
.decl function_symbol(ea:address,name:symbol)
.output function_symbol

function_symbol(EA,Name):-
	symbol(EA,_,"FUNC",_,Name).
	
/////////////////////////////////////////////////////////////
// We go through several phases of increasing confidence
/////////////////////////////////////////////////////////////


/////////////////////////////
// Phase 1
// Get an initial approximation of things that look like code
/////////////////////////////

.decl possible_ea(a:address)
    
possible_ea(EA):-
	instruction(EA,_,_,_,_,_).
	
// approximation of possible targets
// it is ok if they are not all but it is desirable

.decl possible_target(ea:address)

possible_target(Val):-
	op_immediate(_,Val).
	
possible_target(Val):-
	static_data(_,Val).
	
possible_target(Val):-
	pc_relative_jump(_,Val).
	
possible_target(EA):-
	function_symbol(EA,_).
// FIXME: add more targets

		
// propagate from possible targets
.decl likely_ea(n:address,start:address)
//.output likely_ea


likely_ea(EA,EA):-
	possible_target(EA),
	possible_ea(EA).

likely_ea(EA,Start):-
	likely_ea(EA2,Start),
	fallthrough(EA2,EA),
	!possible_target(EA),
	possible_ea(EA).

/////////////////////////////
// Second part 
// we have an initial approximation of things that look like
// code.
// Now we discard overlaping instructions, we are pretty sure
// those are not code
/////////////////////////////


// forbid overlaps with likely_ea instructions
// grow the initial invalid set 
.decl overlap(ea:address,ea_origin:address)


//this is kind of ugly but for now it seems to achieve much better performance
overlap(EA2+1,EA2):-
	//this should limit the scope even more
	likely_ea(EA2,_),
	next(EA2,End),
	EA2+1 < End.
overlap(EA+1,EA2):-
	overlap(EA,EA2),
	next(EA2,End),
	EA+1 < End.

// the starting point of EA is in the middle of a likely instruction
// (and it is not itself likely)
invalid(EA):- 
	likely_ea(Ini,_),
	overlap(EA,Ini),
	possible_ea(EA),
	!likely_ea(EA,_).

// the ending point of EA is in the middle of a likely instruction
// (and it not iself likely)
invalid(EA):- 
	likely_ea(Ini,_),
	overlap(EA_f,Ini),
	next(EA,EA_f),
	possible_ea(EA),
	!likely_ea(EA,_).	
	

//propagate the invalid instructions backward until ret or jmp (encoded in fallthrough)
// propagate through direct jumps and calls weakly 
.decl fallthrough(o:address,d:address)

fallthrough(From,To):-
	next(From,To),
	!return(From),
	!inconditional_jump(From).
	
.decl invalid_transitive(n:address)
//.output invalid_transitive(IO=stdout)

invalid_transitive(EA):-invalid(EA).
invalid_transitive(From):-
	invalid_transitive(To),
	(
		fallthrough(From,To)
	;
		direct_jump(From,To),!likely_ea(From,_)
	;
		direct_call(From,To),!likely_ea(From,_)
	).
	

/////////////////////////////
// Phase 2
// Repeat the same idea
/////////////////////////////

.decl possible_ea2(n:address)
.output possible_ea2

possible_ea2(EA):-
	possible_ea(EA),
	!invalid_transitive(EA).
	
	
// approximation of possible targets

.decl possible_target2_from(ea:address,ea2:address)

possible_target2_from(Val,Ea):-
	op_immediate(Op,Val),
	(
	instruction(Ea,_,_,Op,_,_)
	;
	instruction(Ea,_,_,_,Op,_)
	;
	instruction(Ea,_,_,_,_,Op)
	),
	possible_ea2(Ea).

.decl possible_target2(ea:address)

possible_target2(Val):-
	possible_target2_from(Val,_).
	
possible_target2(Val):-
	static_data(_,Val).
	
possible_target2(Val):-
	pc_relative_jump(_,Val).
	
possible_target2(EA):-
	function_symbol(EA,_).
// FIXME: add more targets



// propagate from possible targets
.decl likely_ea2(n:address,start:address)
.output likely_ea2


likely_ea2(EA,EA):-
	possible_target2(EA),
	possible_ea2(EA).

likely_ea2(EA,Start):-
	likely_ea2(EA2,Start),
	fallthrough(EA2,EA),
	!possible_target2(EA),
	possible_ea2(EA).

.decl block_start(n:address)
.output block_start

block_start(EA):-likely_ea2(_,EA).


////////////////////////////////////////////////////////////////////////
// experimenting


.decl conflict(ea:address,ea2:address)
.output conflict

conflict(EA,EA2):-
	likely_ea2(EA,_),
	overlap(EA,EA2),
	likely_ea2(EA2,_).
	

.decl defined_elsewhere(ea:address)
	
defined_elsewhere(EA):-
	block_start(EA),
	possible_target2_from(EA,Caller),
	likely_ea2(Caller,EA2),EA2!=EA.
defined_elsewhere(EA):-
	block_start(EA),
	!possible_target2_from(EA,_),
	possible_target2(EA).


// propagate from possible targets
.decl likely_ea3(n:address,start:address)
.output likely_ea3


likely_ea3(EA,EA):-
	possible_target2(EA),
	(!conflict(EA,_)
	;
	conflict(EA,_),defined_elsewhere(EA)
	),
	possible_ea2(EA).

likely_ea3(EA,Start):-
	likely_ea3(EA2,Start),
	fallthrough(EA2,EA),
	!possible_target2(EA),
	possible_ea2(EA).


.decl conflict3(ea:address,ea2:address)
.output conflict3

conflict3(EA,EA2):-
	likely_ea3(EA,_),
	overlap(EA,EA2),
	likely_ea3(EA2,_).
