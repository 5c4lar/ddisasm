.symbol_type reg

.number_type address
.number_type op_code
/////////////////////////////////////////////////////////////
// Inputs generated by the decoder
/////////////////////////////////////////////////////////////
.decl symbol(ea:address,n:number,type:symbol,scope:symbol,name:symbol)
.input symbol

.decl section(name:symbol,size:number,addr:address)
.input section


.decl instruction(ea:address,size:number,opcode:symbol,
		op1:op_code,op2:op_code,op3:op_code)
.input instruction

.decl invalid_op_code(n:address)
.input invalid_op_code

// three kinds of operators
.decl op_regdirect(code:op_code,reg:reg)
.input op_regdirect

.decl op_immediate(code:op_code,num:number)
.input op_immediate

.decl op_indirect(code:op_code,reg1:reg,reg2:reg,reg3:reg,
		multiplier:number,offset:number,noidea:number)
.input op_indirect

//data from data sections
.decl static_data(ea:address,value:number)
.input static_data


/////////////////////////////////////////////////////////////
// inference of basic facts
/////////////////////////////////////////////////////////////
	
.decl next(n:address,m:address)

next(EA,EA+Size):-
	instruction(EA,Size,_,_,_,_).
	

.decl jump_operation(n:symbol)

jump_operation("JCXZ").
jump_operation("JECXZ").
jump_operation("JRCXZ").
jump_operation("JO").
jump_operation("JNO").
jump_operation("JB").
jump_operation("JNB").
jump_operation("JZ").
jump_operation("JNZ").
jump_operation("JNA").	
jump_operation("JA").
jump_operation("JS").
jump_operation("JNS").
jump_operation("JP").
jump_operation("JNP").
jump_operation("JL").
jump_operation("JGE").
jump_operation("JLE").
jump_operation("JG").
jump_operation("JC").
jump_operation("JAE").
jump_operation("JE").
jump_operation("JNE").
jump_operation("JBE").
jump_operation("JNBE").
jump_operation("JMP").	

	
// JUMPS
.decl inconditional_jump(n:address)

inconditional_jump(EA):-
	instruction(EA,_,"JMP",_,_,_).	
	
// direct jumps
.decl direct_jump(n:address,m:address)
.output direct_jump

direct_jump(EA,Dest):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_immediate(Op1,Dest).

// jump to the address of a register
// for now we do not compute anything about these
.decl reg_jump(n:address)
.output reg_jump

reg_jump(EA):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_regdirect(Op1,_).
	
// indirect jump	
.decl indirect_jump(n:address)
.output indirect_jump

indirect_jump(EA):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_indirect(Op1,_,_,_, _,_,_),
	!pc_relative_jump(EA,_).

// Special kinds of indirect jumps
// PC relative jumps
.decl pc_relative_jump(n:address,m:address)
.output pc_relative_jump

pc_relative_jump(EA,EA+Offset):-
	instruction(EA,_,Operation,Op1,_,_),
	jump_operation(Operation),
	op_indirect(Op1,"NullSReg","RIP","NullReg64",1,Offset,_).
	

// CALLS
// direct calls
.decl direct_call(n:address,m:address)
.output direct_call

direct_call(EA,Dest):-
	instruction(EA,_,"CALL",Op1,_,_),
	op_immediate(Op1,Dest).

// for now we do not compute anything about these
.decl reg_call(n:address)
.output reg_call

reg_call(EA):-
	instruction(EA,_,"CALL",Op1,_,_),
	op_regdirect(Op1,_).

.decl indirect_call(n:address)
.output indirect_call

indirect_call(EA):-
	instruction(EA,_,"CALL",Op1,_,_),
	op_indirect(Op1,_,_,_,_,_,_).


// Returns
.decl return(n:address)

return(EA):-
	instruction(EA,_,"Ret",_,_,_).

// Function symbols
.decl function_symbol(ea:address,name:symbol)
.output function_symbol

function_symbol(EA,Name):-
	symbol(EA,_,"FUNC",_,Name).


.decl data_section(name:symbol)

data_section(".rodata").
data_section(".data").
data_section(".bss").

.decl code_section(name:symbol)

code_section(".text").
code_section(".plt").


.decl fallthrough(o:address,d:address)

fallthrough(From,To):-
	next(From,To),
	!return(From),
	!inconditional_jump(From).


.decl basic_target(ea:address)

// FIXME: add exception frame addresses

basic_target(Val):-
	static_data(_,Val).

basic_target(EA):-
	section(".text",_,EA).

basic_target(EA):-
	function_symbol(EA,_).
	
	
/////////////////////////////////////////////////////////////
// We go through several phases of increasing confidence
/////////////////////////////////////////////////////////////

// we define a basic phase propagation
// and we later instantiate it for each phase
.comp phase {

// INPUTS
// these are the initial ea considered
.decl possible_ea(a:address)

// the initial targets to be considered
.decl possible_target(ea:address)

// the block limits to be considered
.decl block_limit(ea:address)


//COMPUTED
// propagate from possible targets forward
.decl likely_ea(n:address,start:address)

likely_ea(EA,EA):-
	possible_target(EA),
	possible_ea(EA).
//same block
likely_ea(EA,Head):-
	likely_ea(EA2,Start),
	fallthrough(EA2,EA),
	(
	block_limit(EA),
	Head=EA
	;
	!block_limit(EA),
	Head=Start
	),
	possible_ea(EA).



// forbid overlaps with likely_ea instructions
// grow the initial invalid set 
.decl overlap(ea_overlap:address,ea_likely:address)


// Compute EAs that overlap with EAs of likely instuctions
overlap(EA2+1,EA2):-
	likely_ea(EA2,_),
	next(EA2,End),
	EA2+1 < End.
overlap(EA+1,EA2):-
	overlap(EA,EA2),
	next(EA2,End),
	EA+1 < End.

.decl invalid(n:address)
invalid(EA):-
	invalid_op_code(EA).
invalid(EA):-
	(
	direct_jump(EA,Not_code)
	;
	direct_call(EA,Not_code)
	),
	!possible_ea(Not_code).
	


// invalid(EA):- 
// 	overlap(EA_overlap,Ini),
// 	(
// 	// the starting point of EA is in the middle of a likely instruction
// 	possible_ea(EA_overlap),
// 	EA=EA_overlap
// 	;
// 	// the ending point of EA is in the middle of a likely instruction
// 	next(EA,EA_overlap),
// 	possible_ea(EA)
// 	),
// 	// (and it is not itself likely)
// 	!likely_ea(EA,_).

invalid(EA):-
	possible_ea(EA),
	(
	// the starting point of EA is in the middle of a likely instruction
	overlap(EA,Ini)

	;
	// the ending point of EA is in the middle of a likely instruction
	next(EA,EA_end),
	overlap(EA_end,Ini)
	),
	// (and it is not itself likely)
	!likely_ea(EA,_).


	
	

//propagate the invalid instructions backward until ret or jmp (encoded in fallthrough)
// propagate through direct jumps and calls

invalid(From):-
	invalid(To),
	(
		fallthrough(From,To)
	;
		direct_jump(From,To)
	;
		direct_call(From,To)
	).

.decl remaining_ea(n:address)

remaining_ea(EA):-
	possible_ea(EA),
	!invalid(EA).
}

/////////////////////////////
// Phase 1
// Get an initial approximation of things that look like code
/////////////////////////////
.init phase1=phase

phase1.possible_ea(EA):-
	instruction(EA,_,_,_,_,_).
	
phase1.block_limit(Val):-
	op_immediate(_,Val).
phase1.block_limit(Val):-
	basic_target(Val).	
	
// these are many starting points but maybe not all
phase1.possible_target(EA):-
	phase1.block_limit(EA).


/////////////////////////////
// Phase 2
// In this propagation the possible targets
// are discovered incrementally
/////////////////////////////

.init phase2=phase

phase2.possible_ea(EA):-
	phase1.remaining_ea(EA).	

// we can start traversing the code in two places and end up in the same
// sequence, we want to slit those common sequences apart
// get chunks that don't have common tails

phase2.block_limit(Val):-
	phase1.block_limit(Val).
	
//phase2.block_limit(Val):-
//	common_tail(Val).


.decl common_tail(ea:address)

common_tail(EA):-
	phase1.likely_ea(EA,Chunk),
	fallthrough(From,EA),
	//get the head of the tail only
	!phase1.likely_ea(From,Chunk),
	phase1.likely_ea(From,Chunk2),
	Chunk2!=Chunk.
//////////////////////////////////////////	
// This makes the possible target and likely_ea recursive with one athother

.decl possible_target_from(ea:address,ea2:address)

possible_target_from(Val,Ea):-
	phase2.likely_ea(Ea,_),
	(
	instruction(Ea,_,_,Op,_,_)
	;
	instruction(Ea,_,_,_,Op,_)
	;
	instruction(Ea,_,_,_,_,Op)
	),
	op_immediate(Op,Val).
	



phase2.possible_target(EA):-
	basic_target(EA).

phase2.possible_target(EA):-
	possible_target_from(EA,_Origin).



//.output phase2.likely_ea
.output phase2.remaining_ea

////////////////////////////////////////////////////////////////////////

.decl chunk_start(n:address)
.output chunk_start

//special node for function calls
chunk_start(0).
chunk_start(EA):-phase2.likely_ea(_,EA).




.decl chunk_overlap(ea:address,ea2:address)
//.output chunk_overlap

chunk_overlap(EA_chunk,EA_chunk2):-
	phase2.likely_ea(EA,EA_chunk),
	phase2.overlap(EA,EA2),
	phase2.likely_ea(EA2,EA_chunk2).
	
//////////////////////////////////////////////////////////////////////
// We need to solve the chunk overlaps
// we do it with heuristics
///

.decl discarded_chunk(ea:address)
.output discarded_chunk

discarded_chunk(Ch):-
	(
	chunk_overlap(Ch,Ch2)
	;
	chunk_overlap(Ch2,Ch)
	),
	//heuristic
	function_symbol(Ch2,_),
	!function_symbol(Ch,_).


.decl chunk_overlap2(ea:address,ea2:address)
.output chunk_overlap2

chunk_overlap2(Ch,Ch2):-
	chunk_overlap(Ch,Ch2),
	!discarded_chunk(Ch),
	!discarded_chunk(Ch2).

.decl likely_ea_final(ea:address,chunk:address)
.output likely_ea_final

likely_ea_final(EA,Chunk):-
	phase2.likely_ea(EA,Chunk),
	!discarded_chunk(Chunk).

//////////////////////////////////////////////////////////////////////
// Symbolization
//////////////////////////////////////////////////////////////////////


.decl symbolic_imm(ea:address,op_num:op_code)
.output symbolic_imm

// first approximation

// this one is for sure
symbolic_imm(EA,1):-
 	likely_ea_final(EA,_),
 	(
 	direct_call(EA,_)
 	;
 	direct_jump(EA,_)
 	).


// these are heuristic
symbolic_imm(EA,N):-
	likely_ea_final(EA,_),
	instruction(EA,_,_,Op1,Op2,Op3),
	(
	op_points_to_data(Op1),
	N=1
	;
	op_points_to_data(Op2),
	N=2
	;	
	op_points_to_data(Op3),
	N=3
	).

symbolic_imm(EA,N):-
	likely_ea_final(EA,_),
	instruction(EA,_,_,Op1,Op2,Op3),
	(
	op_points_to_code(Op1),
	N=1
	;
	op_points_to_code(Op2),
	N=2
	;	
	op_points_to_code(Op3),
	N=3
	).

.decl op_points_to_code(n:op_code)
.output op_points_to_code

op_points_to_code(Op):-
	op_immediate(Op,Imm),
	likely_ea_final(Imm,_).
	
op_points_to_code(Op):-
	op_indirect(Op,"NullSReg","RIP","NullReg64",1,_Offset,_).
	
op_points_to_code(Op):-
	op_indirect(Op,"NullSReg",Reg,_Reg2,_Mul,Offset,_),
	Reg!="RIP",
	section(Name,Size,Address),
	code_section(Name),
		// we give some margin in case there was constant propagation
	Address-1000<=Offset,
	Address+Size+1000>Offset.



.decl op_points_to_data(n:op_code)
.output op_points_to_data

op_points_to_data(Op):-
	op_indirect(Op,"NullSReg",Reg,_,_Mul,Offset,_),
	Reg!="RIP",
	section(Name,Size,Address),
	data_section(Name),
	// we give some margin in case there was constant propagation
	Address-1000<=Offset,
	Address+Size+1000>Offset.


op_points_to_data(Op):-
	op_immediate(Op,Imm),
	section(Name,Size,Address),
	data_section(Name),
		// we give some margin in case there was constant propagation
	Address-1000<=Imm,
	Address+Size+1000>Imm.

	
